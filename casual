1.测试
白盒测试：也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。
黑盒测试：也称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。

黑盒测试方法：等价类划、边界值分析、因果图、错误推测。
白盒测试方法：程序结构分析、逻辑覆盖测试、基本路径测试。

测试驱动的开发 TDD 要求我们先写单元测试，再写实现代码。
单元测试属于白盒测试。JUnit。

系统测试 自动测试     

2.秒杀场景设计
要达到强一致性

架构原则
尽量将请求拦截在上游：对于秒杀系统来说，系统的瓶颈一般在数据库层，资源是有限的，所以为了更好的保护底层有限的数据库资源，尽量将请求拦截在上游。
充分利用缓存：缓存不但极大的提高了数据的访问效率，更重要的是承载了底层数据库的访问压力，所以对于读多写少的业务场景充分利用好缓存。

热点隔离
业务隔离：将热点数据分散处理，来降低系统负载压力。
系统隔离：实现系统的软硬隔离，不光是实现软件的隔离，还可以实现硬件的隔离，尽最大限度的减少秒杀带来的高并发安全性问题。
数据隔离：启用单独的 cache 集群或数据库来存放热点数据。

优化方案
页面端优化：按钮置灰来禁止用户重复提交请求，通过 JS 控制在一定时间内只能提交一次请求。

web server 层优化
动静分离：如将几乎不变的静态页面直接通过 NG 或 CDN 来路由访问，只有动态变换的页面可以请求到服务端。
页面缓存化
Nginx 反向代理实现 web server 端的水平扩展。

后端 service 服务层优化
使用缓存（Redis、Memchched）：将读多写少的业务数据放入缓存，如秒杀业务中可以将更新频繁的商品库存信息放入 Redis 缓存处理，最好分为多份放入不同 key 的缓存中，这样将数据分散操作可以达到更高的读写性能。
使用队列处理：将请求放入队列排队处理，以可控的速度来访问底层 DB。
异步处理：如将秒杀成功的订单通知信息通过消息队列（RabbitMQ、Kafka）来异步处理。

DB 层优化
读写分离
分表分库
数据库集群

秒杀场景应付突然的爆发流量：消息队列削峰，分层过滤（CDN 静动态资源划分和缓存）。

3.单点登录 SSO
在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。

单系统登录：Session 保存用户信息
用户登录时，验证用户的账户和密码。
生成一个 token 保存在数据库中，将 token 写到 Cookie 中。
将用户数据保存在 Session 中。
请求时都会带上 Cookie，检查有没有登录，如果已经登录则放行。

多系统：Session 不共享
SSO 系统生成一个 token，并将用户信息存到 Redis 中，并设置过期时间。
其他系统请求 SSO 系统进行登录，得到 SSO 返回的 token，写到 Cookie 中。
每次请求时，Cookie 都会带上，拦截器得到 token，判断是否已经登录。

变化：将登陆功能抽取为一个系统 SSO，其他系统请求 SSO 进行登录本来将用户信息存到 Session，现在将用户信息存到 Redis。

Cookie 不能跨域的解决方案：
服务端将 Cookie 写到客户端后，客户端对 Cookie 进行解析，将 token 解析出来，此后请求都把这个 token 带上就行了。
多个域名共享 Cookie，在写到客户端的时候设置 Cookie 的 domain。
将 token 保存在 SessionStroage 中（不依赖 Cookie 就没有跨域的问题了）。

CAS（Central Authentication Service）：SSO 认证中心类似一个中转站。

多点登录和消息漫游
多点登录是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点。
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

消息漫游是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端。
每个端本地存储 last_msg_id，在登录时可以到云端同步历史消息。
云端存储所有消息成本较高，一般会对历史消息时间 (或者条数) 进行限制。

4.CPU 负载特别高的处理
传统的方案一般是 4 步：
1. top oder by with P：1040  //首先按进程负载排序找到 axLoad(pid)
2. top -Hp 进程PID：1073  //找到相关负载的线程PID
3. printf “0x%x\n”线程PID：0x431  //将线程PID转换为 16 进制，为后面查找 jstack 日志做准备
4. jstack 进程PID | vim +/十六进制线程PID -  // 例如：jstack 1040|vim +/0x431 -

工具 show-busy-java-threads.sh 发现：Java 正则表达式回溯和线程死锁两个问题导致的 CPU 负载特别高。
