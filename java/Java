1.数据类型
byte（8）
char（16），short（16）
int（32），float（32）
long（64），double（64）
boolean（true or false）所占大小为 1B 或者 4B，取决于虚拟机。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。
基本数据类型储存在栈中，更加高效。所有数值类型都有正负号。 

包装类型：基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。包装类不能被继承。包装类大部分实现了常量池技术。

《阿里巴巴 Java 开发手册》：所有的 POJO 类属性必须使用包装数据类型。RPC 方法的返回值和参数必须使用包装数据类型。推荐所有的局部变量使用基本数据类型。
POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。

缓存池
new Integer() 与 Integer.valueOf() 的区别：new Integer() 每次都会新建一个对象，Integer.valueOf() 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
在 Java 8 中，Integer 缓存池的大小默认为 -128~127。这个区间是性能和资源之间的权衡。
编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。
基本类型对应的缓冲池：boolean values true and false，all byte values，short values between -128 and 127，int values between -128 and 127，char in the range \u0000 to \u007F。
JDK1.8 Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127，但是这个上界是可调的。

Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
i4=i5+i6   true
语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

强制类型转换 cast。
+=、-=、*=、/=运算符可以执行隐式类型转换。
从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。switch 不支持 long。

大数据类型 BigInteger 和 BigDecimal 实现任意精度。但是运算速度变慢。BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念。
在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。

Java 的参数是按值传递，方法得到的是所有参数值的一个拷贝。不能修改一个基本数据类型的参数（数值型或布尔型），可以改变引用类型的参数所指向对象的值，但不能让该参数引用一个新的对象。

成员变量和局部变量的区别：
成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数。局部变量不能被访问控制修饰符及 static 所修饰，但能被 final 所修饰。成员变量可以被 public,private,static，final 等修饰符所修饰。
成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
成员变量如果没有被赋初值:如果是基本数据类型则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），如果是引用类型 则为 null；而局部变量则不会自动赋值。

2.String 和数组
String 被声明为 final，因此它不可被继承。
在 Java 8 中，String 内部使用 char 数组存储数据  。
在 Java 9 之后，String 类的实现改用 byte 数组 value 存储字符串，同时使用 coder 来标识使用了哪种编码。
value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

不可变的好处：
可以缓存 hash 值：因为 String 的 hash 值经常被使用，不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
安全性：String 经常作为参数，String 不可变性可以保证参数不可变。
线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

自己实现一个不可变的类：
将类声明为 final，所以它不能被继承
将所有的成员声明为私有的，这样就不允许直接访问这些成员
对变量不要提供 setter 方法
将所有可变的成员声明为 final，这样只能对它们赋值一次
通过构造器初始化所有成员，进行深拷贝 (deep copy)
在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝

String, StringBuffer and StringBuilder：
String 不可变，StringBuffer 和 StringBuilder 可变。
String 是线程安全的，StringBuffer 是线程安全的（内部使用 synchronized 进行同步），StringBuilder 不是线程安全的。
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。StringBuilder 比 StringBuffer 性能高，且适用于单线程。

字符串常量池 String Pool：保存着所有字符串字面量，这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。
当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。
在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

String 类和常量池
String 对象的两种创建方式：
String str1 = "abcd";  //先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");  //堆中创建一个新的对象
只要使用 new 方法，便需要创建新的对象。

String 类型的常量池：
直接使用双引号声明出来的 String 对象会直接存储在常量池中。
String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。
字符串拼接会新建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。

问：String s1 = new String("abc"); 这句话创建了几个字符串对象？
将创建 1 或 2 个字符串。如果池中已存在字符串文字 “abc”，则池中只会创建一个字符串 “s1”。如果池中没有字符串文字 “abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

数组：
初始化默认值：大括号初始化数组必须出现在创建数组的地方。
范围检查：不能在数组范围之外被访问。
大小不能改变
数组是一种效率最高的存储和随机访问对象引用序列的方式。
实现了 Iterable 接口，可以用 foreach 方法来遍历。
拷贝：多余赋默认值，不够只拷贝最前面的元素

Arrays.asList() 将数组转换为集合后，底层其实还是数组，不能使用其修改集合相关的方法。体现了适配器模式，只是转换接口。
注意传递的数组必须是对象数组，而不是基本类型。当传入一个基本数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身。

3.面向对象思想
封装：
利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
隐藏内部的细节，用户无需关心对象内部的细节，并可以通过对象对外提供的接口来访问该对象。
好处：减少耦合，减轻维护的负担。

继承：
实现 IS-A 关系，遵循里式替换原则。
父类引用指向子类对象称为向上转型。

访问权限
private：属性和方法可以通过反射访问。
默认包可见
protected：在继承体系中成员对于子类可见，修饰类没有意义。不同包下，在子类中通过父类引用不可以访问其 protected 方法，通过该子类引用可以访问其 protected 方法，不能通过另一个子类引用访问共同基类的 protected 方法。protected 的静态变量，无论是否同一个包，在子类中均可直接访问。
public
可以对类或类中的成员（字段以及方法）加上访问修饰符。
如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。确保满足里氏替换原则。
字段决不能是公有的，可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。
如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

重写与重载
重写 Override：存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。
@Override 注解让编译器帮忙检查重写的三个限制：子类方法的访问权限必须大于等于父类方法；子类方法的返回类型必须是父类方法返回类型或为其子类型。子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。
方法调用的优先级：this.func(this)、super.func(this)、this.func(super)、super.func(super) 转型。
final，private，static 方法不能被重写，其他方法都是运行时绑定。

重载 Overload：存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。返回值不同，其它都相同不算是重载。

父类的构造方法并不能被继承，所以构造器不能被重写，但是可以被重载。
类的构造方法主要作用是完成对类对象的初始化工作。一个类即使没有声明构造方法也会有默认的不带参数的构造方法。
构造方法的特性：名字与类名相同。没有返回值，但不能用 void 声明构造函数。生成类的对象时自动执行，无需调用。

多态：
相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。
编译时多态：方法的重载。
运行时多态：引用变量的具体类型在运行期才知道，即动态绑定。
运行时多态需要满足继承，重写，向上转型。
例子：乐器类有两个子类：吉他和钢琴，它们都覆盖了父类的 play()，使用父类乐器类来引用子类吉他和钢琴对象，使用乐器类调用 play() 时，会执行吉他类和钢琴类的 play()。

SOLID 设计原则
S（单一责任原则）一个类只负责一件事。
O（开放封闭原则）类应该对扩展开放，对修改关闭。在添加新功能时不需要修改代码。符合该原则最典型的是装饰者模式，可以动态地将责任附加到对象上，而不用去修改类的代码。
L（里氏替换原则）子类对象必须能够替换掉所有父类对象。
I（接口分离原则）客户不依赖于他不使用的方法，使用多个专门的接口比使用单一的总接口要好。
D（依赖倒置原则）高层级的模块不应该依赖于低层级的模块，他们应该都依赖于抽象。细节依赖于抽象，而不是抽象依赖于细节。如果高层模块（包含一个应用程序中重要的策略选择和业务模块）依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
依赖于抽象意味着：任何变量都不应该持有一个指向具体类的指针或者引用，任何类都不应该从具体类派生，任何方法都不应该覆写它的任何基类中的已经实现的方法。

4.类和接口
接口和抽象类
abstract 抽象类和抽象方法，包含抽象方法的类叫做抽象类。抽象类不能被实例化，需要继承抽象类并实现所有抽象方法才能实例化其子类。
interface 接口没有任何的方法实现（java8 开始也可以拥有默认的方法实现，修改接口的成本变低），接口的成员（字段 + 方法）默认都是 public ，接口的字段默认都是 static 和 final 的。
接口可以有 public 和包访问权限。将接口从具体实现中解耦。创建一个类，可以代替为创建一个接口和一个工厂。优先选择类而不是接口，如果必须用接口，则必须进行重构。

在很多情况下，接口优先于抽象类（接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为），比较：
抽象类是 IS-A 关系，接口是 LIKE-A 关系
一个类可以实现多个接口，但只能继承一个抽象类。
接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限（抽象方法不能 private）。
接口中所有的方法隐含的都是抽象的（Java 8 开始接口方法可以有默认实现）。而抽象类则可以同时包含抽象和非抽象的方法。

选择接口：需要让不相关的类都实现一个方法。需要使用多重继承。
选择抽象类：需要在几个相关的类中共享代码。需要能控制继承来的成员的访问权限，而不是都为 public。需要继承非静态和非常量字段。
不管是抽象类还是接口，都不能通过抽象类或者接口直接创建对象，但可以通过匿名内部类的方式访问（让接口的引用来指向内部类对象，该内部类实现了接口）。

Comparator 接口：外部排序，定制比较器。出自 java.util 包。compare(Object obj1, Object obj2)。
Comparable 接口：在集合内部定义的方法实现的排序。出自 java.lang 包。compareTo(Object obj)。

枚举类 enum
lambda 表达式，函数式接口

内部类：
嵌套的接口或类可以被实现为 private，从而不允许向上转型。
在外部类的非静态方法中生成指向内部类的引用，在创建内部类对象时需要 Outer.inner。
内部类对象能访问外部类的所有成员。内部类对象会捕获指向外部类对象的引用，如果是嵌套类（静态内部类），就不需要这个引用。
匿名内部类：通过实例初始化，达到为匿名内部类创建一个构造器的效果。继承受限，只能继承一个类或接口。
嵌套类可以有 static 数据、字段和嵌套类，而普通内部类不行。
闭包和回调：闭包是可调用的对象，回调可以在运行时动态地决定需要调用的方法。

内部类最大的优点：每个内部类都能独立地继承一个接口的实现，无论外围类是否已经继承了某个接口的实现，对内部类都没有影响。
利用内部类，可以实现对类的“多重继承”。其他特性：内部类的多个实例与外部类独立；由多个内部类用不同方式实现同一个接口或类；创建内部类时不需要依赖外部类的创建；内部类是独立的实体。

this：表示对当前对象的引用（表示引用类的成员变量，而非函数参数）。在构造方法中引用满足指定参数类型的构造器。除构造器外，禁止在其它方法中调用构造器。
super：从子类访问父类的变量和方法。访问父类的构造函数，委托父类完成一些初始化的工作。在执行子类的构造方法之前，如果没有用 super 来调用父类特定的构造方法，则会调用父类中没有参数的构造方法。如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误。
this 和 super 必须处于构造器的首行，且不能用在 static 方法中。

Object 类方法：
equals()：equals() 判断引用的对象是否等价。equals 方法不能作用于基本数据类型的变量。类没有覆盖 equals() 方法，则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等。
==：基本数据类型==比较的是值，引用数据类型==判断两个变量是否引用同一个对象。
equals() 实现：检查是否为同一个对象的引用，如果是直接返回 true；检查是否是同一个类型，如果不是，直接返回 false；将 Object 对象进行转型；判断每个关键域是否相等。
String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

hashCode()：当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。
但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。
大大减少了 equals 的次数，提高了执行速度。

重写 equals 为什么要重写 hashCode？
相等的两个对象哈希值一定相同，哈希值相同的两个对象不一定相等。
默认的 hashCode() 是根据对象的内存地址经哈希算法得到哈希值。
如果没有重写 hashCode()，hashCode() 得出来的值不同，两个对象无法 equals()。
因此为了能 equals()，必须重写 hashCode()，使相等的对象有相同的哈希值。

主要是针对 HashSet 和 HashMap
如果不重写 hashcode 会出现什么问题？hashCode() 确定对象在 HashSet 中存放的位置，如果不重写 hashCode()，添加了两个等价对象但是存放的位置不同就会破坏 HashSet 的特性。

不能使用一个值为 null 的引用类型变量来调用非静态方法 equals()，否则会抛出空指针异常。
推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。
所有整形包装类对象值得比较必须使用 equals()。
浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。

clone()：protected 方法，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。
如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。
浅拷贝：对于复制对象进行引用传递，拷贝对象和原始对象引用同一个对象。
深拷贝：创建了一个新的对象，并且复制原对象内的成员变量到新对象中，拷贝对象和原始对象的引用类型引用不同对象。每一层的每个对象都进行浅拷贝=深拷贝。
使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。
反序列化 readObject() 从文件中还原类的对象，不通过构造函数创建对象。

toString()，wait(), notify()，notifyAll()，getClass()
finalize()：使用了本地方法，调用非 java 代码的方式，需要用 finalize()。

5.关键字
final：
数据：声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。
对于基本类型，final 使数值不变。
对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

方法：声明方法不能被子类重写。效率问题：在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。
private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

类：声明类不允许被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。

static：
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。静态变量存放在 Java 内存区域的方法区。
静态方法：在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。调用静态方法可以无需创建对象。如果方法执行的操作不依赖于其类的各个变量和方法，设置为静态使程序的占用空间更小。
静态语句块：静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行。 该类不管创建多少对象，在类初始化时运行一次。
静态内部类：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。这就意味着，静态内部类的创建不需要依赖于外部类的创建，不能访问外部类的非静态的成员变量和方法。
静态导包 JDK 1.5
初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序，最后才是构造函数的初始化。
存在继承时的初始化顺序：父类（静态变量、静态语句块），子类（静态变量、静态语句块），父类（实例变量、普通语句块），父类（构造函数），子类（实例变量、普通语句块），子类（构造函数）。

6.反射
在运行时识别对象和类的信息。
三个动态特性：运行时生成对象实例。运行时调用方法。运行时更改属性。
方法：getClass() 或 Class.forName() 得到 Class 对象，.newInstance() 生成对应的对象，invoke() 调用方法。
反射用异常来报告检查结果。

类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName() 这种方式来控制类的加载，该方法会返回一个 Class 对象。
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。
Class 和 java.lang.reflect 一起对反射提供了支持，后者主要包括 Field、Method 和 Constructor 三个类。

优点：可扩展性、用作类浏览器和可视化开发环境、用作调试器和测试工具。
缺点（如果一个功能可以不用反射完成，那么最好就不用）：性能开销、安全限制、内部暴露。

RTTI：在编译时已经知道了所有的类型。使用 Class 对象。通过匿名基类的引用来发现类型信息。尽量使用多台，只在必须时使用 RTTI。
RTTI 和反射的区别：RTTI 编译器在编译时打开和检查.class 文件；对于反射，.class 文件在编译时不可获取，在运行时打开和检查.class 文件。

RMI 远程方法调用：需要在运行时获取类的信息。允许运行在一个 Java 虚拟机上的对象调用运行在另一个 Java 虚拟机上的对象的方法。

动态代理：使用到了反射。

7.异常
Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：Error 和 Exception。
Error 用来表示 JVM 无法处理的错误。它们在应用程序的控制和处理能力之外，这些错误发生时，JVM 一般会选择线程终止。
Exception 分为受检异常（需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复）和非受检异常（是程序运行时错误）。异常能被程序本身处理。

常见异常：NullPointerException 空指针异常，ClassCastException 类型强制转换异常，ArrayIndexOutOfBoundsException 数组下标越界异常，IOException 输入输出异常，SQLException 操作数据库异常。

异常处理：
try 块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。
catch 块：用于处理 try 捕获到的异常。可以重新抛出异常。
finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。
当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。

在以下 4 种特殊情况下，finally 块不会被执行：
在 finally 语句块第一行发生了异常。因为在其他行，finally 块还是会得到执行。
在前面的代码中用了 System.exit(int) 已退出程序。若该语句在异常语句之后，finally 会执行。
程序所在的线程死亡。
关闭 CPU。

throw 和 throws 的区别：
Throw 用于方法内部，Throws 用于方法声明上。
Throw 后跟异常对象，Throws 后跟异常类型。
Throw 后只能跟一个异常对象，Throws 后可以一次声明多种异常类型。

断言和日志

8.泛型
使用参数化类型，使代码可以应用于多种类型。不能使用基本类型用作类型参数。
使用泛型，可以在编译器防止将错误类型的对象放置到容器中。

类型擦除：在泛型代码的内部，无法获得任何有关泛型参数类型的信息。

元组：仅一次方法调用就能返回多个对象。通过创建一个对象，来持有想要返回的多个对象。
通配符：被限制为单一边界。

9.注解 Annontation
Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

注解的用处:
生成文档。
跟踪代码依赖性，实现替代配置文件功能。
在编译时进行格式检查。

注解的原理：注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。
而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 Map 中索引出对应的值。而 memberValues 的来源是 Java 常量池。

元注解（专门注解其他的注解）：@Documented、@Retention、@Target、@Inherited。
常见注解：@Override 重载、@Deprecated 不被推荐使用、@SuppressWarnings 抑制警告

单元测试 JUnit

10.Java SE 8 新特性
lambda 表达式和函数式接口，lambda 表达式匿名函数。
Optional 是一个简单的容器，其值可能是 null 或者不是 null。在 Java 8 之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在 Java 8 中，你应该返回 Optional 而不是 null。用于防止 NullPointerException。

Stream：能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回 Stream 本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源。Stream 的操作可以串行执行或者并行执行（Parallel Streams）。
Stream 操作
Filter(过滤)：过滤通过一个 Predicate 接口来过滤并只保留符合条件的元素，该操作属于中间操作。
Sorted(排序)：如果你不指定一个自定义的 Comparator 则会使用默认排序，该操作属于中间操作。创建了一个排列好后的 Stream，而不会影响原有的数据源。
Map(映射)：中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。
Match(匹配)：Stream 提供了多种匹配操作，允许检测指定的 Predicate 是否匹配整个 Stream。所有的匹配操作都是最终操作 ，并返回一个 boolean 类型的值。
Count(计数)：计数是一个最终操作，返回 Stream 中元素的个数，返回值类型是 long。
Reduce(规约)：这是一个最终操作 ，允许通过指定的函数来讲 Stream 中的多个元素规约为一个元素，规约后的结果是通过 Optional 接口表示的。

新的日期和时间 API
接口的默认方法：使用 default 关键字向接口添加非抽象方法实现。接口也可以定义静态方法，可以直接用接口名调用。实现类是不可以调用接口的默认方法。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。   
多重注解

11.Java 与 C++ 的区别
Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
Java 支持自动垃圾回收，而 C++ 需要手动回收。
Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。
Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。

面向对象与面向过程的区别

12.容器
容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
容器不能持有基本类型，需要使用自动包装。

Collection
Set：不允许重复
TreeSet：基于红黑树实现，有序，支持范围查找，查找的时间复杂度为 O(logN)。

HashSet：基于 HashMap 实现，无序，查找的时间复杂度为 O(1)。
封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。如果向 HashSet 中添加一个已经存在的元素，新添加的集合元素不会覆盖已有的集合元素。
除了 clone() 、writeObject()、readObject() 是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。

LinkedHashSet：内部使用双向链表维护元素的插入顺序，具有 HashSet 的查找效率。

List
ArrayList：基于动态数组实现，支持快速随机访问。实现了 RandomAccess（只是标识）, Cloneable 和 Serializable 接口。默认大小为 10。
扩容：新容量的大小为旧容量的 1.5 倍，Arrays.copyOf() 把原数组整个复制到新数组中。
删除元素：System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)。
Fail-Fast：modCount 用来记录 ArrayList 结构发生变化的次数。在进行序列化或者迭代等操作时，若 modCount 发生变化，会抛出 ConcurrentModificationException。java.util 包下面的所有的集合类都是 fail-fast 的。java.util.concurrent 包下面的所有的类都是安全失败 fail-safe 的。
序列化：ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。
ArrayList 实现了 writeObject() 序列化和 readObject() 反序列化来控制只序列化数组中有元素填充那部分内容。writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。                  
可以使用 Collections.synchronizedList()，得到一个线程安全的 ArrayList。

Vector：和 ArrayList 类似，但它是线程安全的，使用了 synchronized 进行同步。
与 ArrayList 的比较：
Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制。
Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。

Array 与 ArrayList 比较：
Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。
Array 大小是固定的，ArrayList 的大小是动态变化的。

CopyOnWriteArrayList
读写分离：写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。
使用场景：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。实现的 fail-safe。
缺陷：在写操作时需要复制一个新的数组，内存占用为原来的两倍左右；部分写操作的数据还未同步到读数组中导致数据不一致。因此不适合内存敏感以及对实时性要求很高的场景。

LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。实现了 Deque 接口。不仅如此，LinkedList 还可以用作栈、队列和双向队列。LinkedList 为双向链表。JDK1.6 之前为循环链表，JDK1.7 取消了循环。
使 LinkedList 变成线程安全的：List list=Collections.synchronizedList(new LinkedList(...));或者 BlockingQueue 阻塞队列和 ConcurrentLinkedQueue 非阻塞队列（CAS）。
与 ArrayList 的比较：ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；ArrayList 支持随机访问，LinkedList 不支持；LinkedList 在任意位置添加删除元素更快。ArrayList 结尾会预留一定的容量空间花费空间，LinkedList 每一个元素都需要存放直接后继和直接前驱以及数据花费空间。

实现了 RandomAccess 接口的 list，优先选择普通 for 循环 ，其次 foreach。
未实现 RandomAccess 接口的 list，优先选择 foreach（底层通过 iterator 实现）。大 size 的数据，千万不要使用普通 for 循环。

Queue
双向队列 Deque：通过 LinkedList 实现。
PriorityQueue：基于堆结构实现。调用 remove 方法，总会获得当前优先级队列中的最小元素。PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。

Map
TreeMap：基于红黑树实现。由 Comparable 或 Comparator 排序。

HashMap：基于哈希表实现。Entry<K,V>[] table，数组中的每个位置被当成一个桶，一个桶存放一个链表 Entry（存储着键值对）。
拉链法解决冲突：put 操作头插法。要存入的元素与要存放位置上已有元素的 hash 值以及 key 相同的话直接覆盖。如果是红黑树节点则红黑树插入。
HashMap 只允许一个 key 为 null，允许多个 value 为 null。因为无法调用 null 的 hashCode()，也就无法确定该键值对的桶下标，HashMap 使用第 0 个桶存放键为 null 的键值对。
使用扰动函数（hash()）之后可以减少碰撞。

扩容 resize：为了让查找的成本降低，table 要尽可能大，HashMap 采用动态扩容来根据当前的键值对数量来调整 table 大小。
默认的 table 容量 capacity 是 16，默认的装载因子 loadFactor 是 0.75（loadFactor 太大导致查找元素效率低，太小导致数组的利用率低）。默认的键值对数量 size 的临界值 threshold = capacity * loadFactor=12。
当 Entry 的数量超过 threshold 且新建的 Entry 刚好落在一个非空的 table 上，触发扩容 capacity*2，并采用 transfer() 将原有的 Entry 对象插入到新数组中（会进行 rehash() 重新计算桶下标）。并发下的 Rehash 会造成元素之间会形成一个循环链表，jdk 1.8 后解决了这个问题。

从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。Entry 改为了 Node。

HashMap 的容量是 2 的幂次方：tableSizeFor()。好处：
通过限制 length 是一个 2 的幂数，indexFor()（求桶的位置）中 h & (length-1) 和 h % length 结果是一致的。取模转换成了&与操作更加高效。
通过右移可以使低位的数据尽量的不同，从而使 hash 值的均匀分布减少碰撞。

HashTable：和 HashMap 类似，但它是线程安全的，因此也效率低。
HashTable 与 HashMap 比较：
HashTable 使用 synchronized 来进行同步。
HashMap 可以插入键为 null 的 Entry。
HashMap 的迭代器是 fail-fast 迭代器。
HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
初始容量和扩容不同。
HashMap 链表长度大于 8 时，会转换为红黑树。

ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。HashEntry 代替 Entry。
JDK 1.7 分段锁：将数据分成一段一段的存储，然后给每一段数据配一把锁。当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。默认创建 16 个 Segment 锁（继承自 ReentrantLock），并发度与 Segment 数量相等。volatile 修饰数据。
ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。put 需要加锁。 
size 操作：每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。
ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

JDK 1.8 取消了分段锁，使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized（JDK1.6 以后 对 synchronized 锁做了很多优化）。synchronized 只锁定当前链表或红黑二叉树的首节点（只要 hash 不冲突，就不会产生并发）。也在链表过长时会转换为红黑树。

为什么 HashMap 支持 key 或者 value 为 null，而 HashTable 和 ConcurrentHashmap 不支持？
Hashtable 和 ConcurrentHashmap 都是支持并发的，这样会有一个问题，当你通过 get(k) 获取对应的 value 时，如果获取到的是 null 时，你无法判断，它是 put（k,v）的时候 value 为 null，还是这个 key 从来没有做过映射。
HashMap 是非并发的，可以通过 contains(key) 来做这个判断。而支持并发的 Map 在调用 m.contains（key）和 m.get(key),m 可能已经不同了。

LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。可以使用 LinkedHashMap 实现的一个 LRU 缓存。

WeakHashMap：Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。。
Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。
采取的是分代缓存：
经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收。
不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。
当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。
当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。

IdentityHashMap:使用==代替 equals 对键进行比较。

容器中的设计模式：
迭代器模式：Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。
JDK 1.5 之后使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。
不要在 foreach 循环里进行集合类的 remove/add 操作，可以调用迭代器的 remove/add 方法。并发操作需要对 Iterator 对象加锁。
Java 中的 Iterator 可用来遍历 Set 和 List 集合，并且只能单向移动。ListIterator 实现了 Iterator 接口，既可以前向也可以后向遍历，还可以添加对象和修改对象。
Enumeration 接口和 Iterator 接口的区别：Enumeration 速度是 Iterator 的 2 倍，同时占用更少的内存。但是，Iterator 远远比 Enumeration 安全，因为其他线程不能够修改正在被 iterator 遍历的集合里面的对象。同时，Iterator 允许调用者删除底层集合里面的元素，这对 Enumeration 来说是不可能的。

适配器模式

集合类没有实现 Cloneable 和 Serializable 接口：应该由集合类的具体实现来决定如何被克隆或者是序列化。

13.I/O
进程中的 IO 调用过程：
进程向操作系统请求数据;
操作系统把外部数据加载到内核的缓冲区中; 
操作系统把内核的缓冲区拷贝到进程的缓冲区;
进程获得数据完成自己的功能;

Java I/O 使用了装饰者模式来实现。

磁盘操作 File
File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。
从 Java7 开始，可以使用 Paths 和 Files 代替 File。

字节操作 InputStream 和 OutputStream
不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。

字符操作 Reader 和 Writer
编码就是把字符转换为字节，而解码是把字节重新组合成字符。
如果编码和解码过程使用不同的编码方式那么就出现了乱码。
GBK：中文字符占 2 个字节，英文字符占 1 个字节；
UTF-8：中文字符占 3 个字节，英文字符占 1 个字节；
UTF-16be：中文字符和英文字符都占 2 个字节。大端 Big Endian，大端序最高位字节存储在最低的内存地址处。
Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。
在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。

在程序中操作的通常是字符形式的数据。
InputStreamReader 实现从字节流解码成字符流；
OutputStreamWriter 实现字符流编码成为字节流。

获取键盘输入：通过 Scanner 或 BufferedReader。

既然有了字节流，为什么还要有字符流?
I/O 流操作分为字节流操作和字符流操作。
字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。
所以，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。
如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

对象操作 Serializable
序列化就是将一个对象转换成字节序列，方便存储和传输。
序列化：ObjectOutputStream.writeObject()
反序列化：ObjectInputStream.readObject()
不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。
序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。
transient 关键字可以使修饰的变量不被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。

网络操作 Socket
InetAddress：用于表示网络上的硬件资源，即 IP 地址。没有公有的构造函数，只能通过静态方法来创建实例。
URL：统一资源定位，可以直接从 URL 中读取字节流数据。

Sockets：使用 TCP 协议实现网络通信。
ServerSocket：服务器端类
Socket：客户端类
服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。

Datagram：使用 UDP 协议实现网络通信。
DatagramSocket：通信类
DatagramPacket：数据包类

*新的输入输出 NIO
JDK 1.4 中引入，高速、面向块，基于通道&缓冲&选择器，同步非阻塞。
NIO 与普通 I/O 的区别主要有以下两点：非阻塞和面向块。

流与块
I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。
面向流的 I/O 一次处理一个字节数据，为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。然而面向流的 I/O 通常相当慢。
面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。
I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了。
虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。

NIO 核心组件：Channel，Buffer 和 Selector
通道 Channel：是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。
通道与流的不同之处在于，流只能在一个方向上移动 (一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。
通道包括以下类型：
FileChannel：从文件中读写数据；
DatagramChannel：通过 UDP 读写网络中数据；
SocketChannel：通过 TCP 读写网络中数据；
ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。
无论读写，通道只能和 Buffer 交互。因为 Buffer，通道可以异步地读写。
NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。

缓冲区 Buffer：不会直接对通道进行读写数据，而是要先经过缓冲区。
缓冲区实质上是一个数组，提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。
缓冲区状态变量。

选择器 Selector：NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。
通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时（单线程中从通道读取数据到 buffer，同时可以继续做别的事情，当数据读取到 buffer 中后，线程再继续处理数据），就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。
因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。
应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。
只是有效请求（确实需要进行 I/O 处理）时，才会使用一个线程去处理，避免了 BIO 模型下大量线程处于阻塞等待状态的情景。IO 操作本身是同步的。

内存映射文件 I/O：一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。
向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。

BIO：同步阻塞 I/O，数据的读取写入必须阻塞在一个线程内等待其完成。做完一件事再去做另一件事。在活动连接数不是特别高时，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。
如果需要同时做很多事情，就需要系统创建很多线程来完成对应的工作，因为 BIO 模型下一个线程同时只能做一个工作。如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态。
在 BIO 模型下的线程阻塞就会导致系统线程的切换，从而对整个系统性能造成一定的影响。
可以通过线程池机制改善。采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，客户端个数可以远远大于线程池最大线程数。

AIO：NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 
在 Unix 系统下，采用了 epoll IO 模型，windows 下是使用了 IOCP 模型。

14.Servlet
在 Java Web 程序中，Servlet 主要负责接收用户请求 HttpServletRequest，在 doGet() 和 doPost() 中做相应的处理，并将回应 HttpServletResponse 反馈给用户。
Servlet 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有一个实例，在它初始化时调用 init() 方法，销毁时调用 destroy() 方法。
Servlet 需要在 web.xml 中配置（MyEclipse 中创建 Servlet 会自动配置）。

一个 Servlet 可以设置多个 URL 访问。Servlet 不是线程安全，多线程并发的读写会导致数据不同步的问题。 
Servlet 是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个 Servlet 类。Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递给 Servlet 程序，并将 Servlet 的响应回传给用户。通常一个 Servlet 会关联一个或多个 JSP 页面。
解决的办法是尽量不要定义 name 属性，而是要把 name 变量分别定义在 doGet() 和 doPost() 方法内。虽然使用 synchronized(name){} 语句块可以解决问题，但是会造成线程的等待。
如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此 Servlet 里的只读属性最好定义为 final 类型的。
可以让自定义的 Servlet 实现 SingleThreadModel 标识接口，实现单线程模式。
如果将 Servlet 设置成单线程工作模式，会导致每个请求创建一个 Servlet 实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。

优点：
只需要启动一个操作系统进程以及加载一个 JVM，大大降低了系统的开销。
如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销。
所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。
Servlet 能直接和 Web 服务器交互，还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。

生命周期： 
方法：init()，service()，destroy()。
Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init() 方法进行 Servlet 的初始化。
请求到达时调用 Servlet 的 service() 方法，service() 方法会根据需要调用与请求对应的 doGet 或 doPost 等方法。
当服务器关闭或项目被卸载时服务器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy() 方法。
init 方法和 destroy 方法只会执行一次，service 方法客户端每次请求 Servlet 都会执行。
Servlet 中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入 init 方法中，销毁资源的代码放入 destroy 方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。

转发和重定向的区别：
转发 Forward 是服务器行为，重定向 Redirect 是客户端行为。
转发通过 RequestDispatcher 对象的 forward（HttpServletRequest request，HttpServletResponse response）方法实现的。RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher() 方法获得。
重定向是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。
地址栏显示：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。
数据共享：forward 转发页面和转发到的页面可以共享 request 里面的数据，redirect 不能共享数据。
运用地方：forward 一般用于用户登陆的时候，根据角色转发到相应的模块。redirect 一般用于用户注销登陆时返回主页面和跳转到其它的网站等。
效率：forward 高，redirect 低。

自动刷新 Refresh：自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet 中通过 HttpServletResponse 对象设置 Header 属性实现自动刷新。

JSP 和 Servlet：
Servlet 是一个特殊的 Java 程序，它运行于服务器的 JVM 中，能够依靠服务器的支持向浏览器提供显示内容。
JSP 本质上是 Servlet 的一种简易形式，JSP 会被服务器处理成一个类似于 Servlet 的 Java 程序，可以简化页面内容的生成。
Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为 .jsp 的文件。
JSP 侧重于视图，Servlet 更侧重于控制逻辑，在 MVC 架构模式中，JSP 适合充当 view 而 Servlet 适合充当控制器 controller。

15.补充
JRE 和 JDK：
JRE 是 java 运行时环境，包含了 java 虚拟机，java 基础类库。是使用 java 语言编写的程序运行所需要的软件环境，是提供给想运行 java 程序的用户使用的。
JDK 是 java 开发工具包，是程序员使用 java 语言编写 java 程序所需的开发工具包，是提供给程序员使用的。JDK 包含了 JRE，同时还包含了编译 java 源码的编译器 javac 和调试器等。
如果你需要运行 java 程序，只需安装 JRE 就可以了。如果你需要编写 java 程序，需要安装 JDK。

Oracle JDK 和 OpenJDK：
OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；
Oracle JDK 比 OpenJDK 更稳定。
Oracle JDK 与 OpenJDK 相比提供了更好的性能；

javax 包是标准 API 的一部分。

SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类，它允许进行格式化（日期→文本）、解析（文本→日期）和规范化。

SimpleDateFormat 为什么不是线程安全的？
在 SimpleDateFormat 转换日期是通过 Calendar 对象来操作的，SimpleDateFormat 继承 DateFormat 类，DateFormat 类中维护一个 Calendar 对象，Calendar 实例被用来进行日期-时间计算，既被用于 format 方法也被用于 parse 方法。
在 parse 方法的最后，会调用 CalendarBuilder 的 establish 方法，入参就是 SimpleDateFormat 维护的 Calendar 实例，在 establish 方法中会调用 calendar 的 clear 方法。
SimpleDateFormat 维护的用于 format 和 parse 方法计算日期-时间的 calendar 被清空了，如果此时线程 A 将 calendar 清空且没有设置新值，线程 B 也进入 parse 方法用到了 SimpleDateFormat 对象中的 calendar 对象，此时就会产生线程安全问题。

解决方法：每一个使用 SimpleDateFormat 对象进行日期-时间进行 format 和 parse 方法的时候就创建一个新的 SimpleDateFormat 对象，用完就销毁。此时就可以使用 ThreadLocal 将 SimpleDateFormat 绑定到线程上。
