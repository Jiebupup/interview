1.数据类型
byte（8）
char（16），short（16）
int（32），float（32）
long（64），double（64）
boolean（true or false）所占大小为 1B 或者 4B，取决于虚拟机。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。
基本数据类型储存在栈中，更加高效。所有数值类型都有正负号。 

空常量 null 不能拿来打印输出。
浮点数只是一个近似值，默认类型是 double。整数默认类型是 int。
float 表示的范围要大于 long。
编译器的常量优化：javac 会将常量表达式计算后赋值给变量。
double 值也可以 ++。

包装类型：基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。包装类不能被继承。包装类大部分实现了常量池技术。重写了 toString()。
装箱：构造方法 Integer（int 和基本类型的 String），静态方法 valueOf（int 和 String）。
拆箱：intValue()。
JDK1.5 之后自动装箱和拆箱。
除了 Character 类之外，其他包装类都有静态方法 parseXxx() 将字符串转换为对应的基本类型。
将基本类型转换为字符串：基本类型 + "" 最简单的方式，静态方法 toString(int i) 和 valueOf(int i)。

《阿里巴巴 Java 开发手册》：所有的 POJO 类属性必须使用包装数据类型。RPC 方法的返回值和参数必须使用包装数据类型。推荐所有的局部变量使用基本数据类型。
POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。

缓存池
new Integer() 与 Integer.valueOf() 的区别：new Integer() 每次都会新建一个对象，Integer.valueOf() 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
在 Java 8 中，Integer 缓存池的大小默认为 -128~127。这个区间是性能和资源之间的权衡。
编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。
基本类型对应的缓冲池：boolean values true and false，all byte values，short values between -128 and 127，int values between -128 and 127，char in the range \u0000 to \u007F。
JDK1.8 Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127，但是这个上界是可调的。

Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
i4==i5+i6   true
语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

强制类型转换 cast：(范围小的类型)范围大的类型，有可能发生精度损失、数据溢出。
char byte short 在进行数学运算时会先提升为 int。boolean 不能发生数据类型转换。
+=、-=、*=、/=、%= 复合赋值运算符会执行隐式的强制类型转换。a=a+b 和 a+=b 有区别。
javac 会在 char、byte、short 赋值时右侧数值没有超过范围时隐式强转，超过范围则会报错。

从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。switch 还可以 byte short char int 和枚举 enum。
不是 void 返回值的方法可以进行单独调用，打印调用和赋值调用，void 返回值的方法只能进行单独调用。
Java 的参数是按值传递，方法得到的是所有参数值的一个拷贝。不能修改一个基本数据类型的参数（数值型或布尔型），可以改变引用类型的参数所指向对象的值，但不能让该参数引用一个新的对象。

大数据类型 BigInteger 和 BigDecimal 实现任意精度。但是运算速度变慢。BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念。
在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。

成员变量和局部变量的区别：
成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数。局部变量不能被访问控制修饰符及 static 所修饰，但能被 final 所修饰。成员变量可以被 public，private，static，final 等修饰符所修饰。
成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。对象存在于堆内存，速度较慢。局部变量则存在于栈内存，速度较快。
成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
成员变量如果没有被赋初值：如果是基本数据类型则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），如果是引用类型则为 null；而局部变量则不会自动赋值。
当方法中的局部变量和成员变量重名时，会就近使用局部变量。所以要用 this. 区分。

2.String 和数组
+ 表示字符连接，任何数据类型和字符串连接时都会得到字符串，如 "Java"+20+30 -> Java2030。
字符串是常量，可以共享使用。
StringBuilder 底层也是 byte[] value，但是没有被 final 修饰，超出了容量会自动扩容。
链式编程：方法的返回值是一个对象，可以继续调用方法。
把一个基本数据类型转为字符串，toString() 是最快的方式、String.valueOf() 次之、数据 + "" 最慢。String.valueOf() 底层调用了 toString() 方法，但是会在调用前做空判断。数据 + "" 底层使用了 StringBuilder 实现，先用 append 方法拼接，再用 toString() 方法获取字符串。

String 被声明为 final，因此它不可被继承。
在 Java 8 中，String 内部使用 char 数组存储数据。
在 Java 9 之后，String 类的实现改用 byte 数组 value 存储字符串，同时使用 coder 来标识使用了哪种编码。
value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

不可变的好处：
可以缓存 hash 值：因为 String 的 hash 值经常被使用，不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
安全性：String 经常作为参数，String 不可变性可以保证参数不可变。
线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

自己实现一个不可变的类：
将类声明为 final，所以它不能被继承
将所有的成员声明为私有的，这样就不允许直接访问这些成员
对变量不要提供 setter 方法
将所有可变的成员声明为 final，这样只能对它们赋值一次
通过构造器初始化所有成员，进行深拷贝 (deep copy)
在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝

String，StringBuffer and StringBuilder：
String 不可变，StringBuffer 和 StringBuilder 可变。
String 是线程安全的，StringBuffer 是线程安全的（内部使用 synchronized 进行同步），StringBuilder 不是线程安全的。
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer（StringBuilder）每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。
StringBuilder 占用空间少，性能好。

字符串常量池 String Pool：保存着所有字符串字面量，这些字面量在编译时期就确定，直接使用双引号声明出来的 String 对象会直接存储在常量池中。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。
当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。
JDK1.7 之前，String Pool 被放在运行时常量池中，它属于永久代。JDK1.7 及以后，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。
JDK1.7 之前，是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。JDK1.7 及以后的处理方式是在常量池中记录此字符串的引用，并返回该引用。

String 类和常量池
String 对象的两种创建方式：
String str1 = "abcd";  //先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");  //堆中创建一个新的对象
只要使用 new 方法，便需要创建新的对象。

问：String s1 = new String("abc"); 这句话创建了几个字符串对象？
将创建 1 或 2 个字符串。如果池中已存在字符串文字 “abc”，则池中只会创建一个字符串 “s1”。如果池中没有字符串文字 “abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

数组：
初始化默认值：大括号初始化数组必须出现在创建数组的地方。
范围检查：不能在数组范围之外被访问。
大小不能改变
数组是一种效率最高的存储和随机访问对象引用序列的方式。
实现了 Iterable 接口，可以用 foreach 方法来遍历。
拷贝：多余赋默认值，不够只拷贝最前面的元素

查询快，增删慢。增删时需要新建数组，复制原数组的元素，销毁原数组，效率低下
二维数组本质上也是一维数组，只是数组中的每一个元素都指向了另一个一维数组而已。

3.面向对象思想
封装：
利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
隐藏内部的细节，用户无需关心对象内部的细节，并可以通过对象对外提供的接口来访问该对象。
好处：减少耦合，减轻维护的负担。

方法是一种封装，private 也是一种封装。

继承：
实现 IS-A 关系，遵循里式替换原则。
父类引用指向子类对象称为向上转型。

访问子类成员变量的两种方法
直接通过子类对象访问：优先用 new 等式左边。
间接通过成员方法访问：优先用方法属于的类。
没有则向上找父类。

访问权限修饰符：可以对类或类中的成员（字段和方法）加上访问修饰符。类可见表示其它类可以用这个类创建实例对象。成员可见表示其它类可以用这个类的实例对象访问到该成员；
private：属性和方法可以通过反射访问。
默认包可见
protected：修饰成员，在继承体系中成员对于子类可见，修饰类没有意义。不同包下，在子类中通过父类引用不可以访问其 protected 方法，通过该子类引用可以访问其 protected 方法，不能通过另一个子类引用访问共同基类的 protected 方法。protected 的静态变量，无论是否同一个包，在子类中均可直接访问。
public

如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。确保满足里氏替换原则。
字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。
如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

重写与重载
重写 Override：存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。
@Override 注解让编译器帮忙检查重写的三个限制：子类方法的访问权限必须大于等于父类方法；子类方法的返回类型必须是父类方法返回类型或为其子类型。子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型（或者不抛出异常）。
方法调用的优先级：this.func(this)、super.func(this)、this.func(super)、super.func(super) 转型。
final，private，static 方法不能被重写，其他方法都是运行时绑定。

重载 Overload：存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、多类型顺序至少有一个不同。返回类型（参数名称）不同，其它都相同不算是重载。

父类的构造方法并不能被继承，所以构造器不能被重写，但是可以被重载。
类的构造方法主要作用是完成对类对象的初始化工作。一个类即使没有声明构造方法也会有默认的不带参数的构造方法。
构造方法的特性：名字与类名相同。没有返回值，但不能用 void 声明构造方法。生成类的对象时自动执行，无需调用。
如果自己编写了带参数的构造方法，则不会赠送默认无参数的构造方法了。
构造函数不能有递归。

多态：
相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。
编译时多态：方法的重载。
运行时多态：引用变量的具体类型在运行期才知道，即动态绑定。
运行时多态需要满足继承，重写，向上转型。
例子：乐器类有两个子类：吉他和钢琴，它们都覆盖了父类的 play()，使用父类乐器类来引用子类吉他和钢琴对象，使用乐器类调用 play() 时，会执行吉他类和钢琴类的 play()。

向下转型前需要 instanceof 判断，否则会出现 ClassCastException。

SOLID 设计原则
S（单一责任原则）：一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
O（开放封闭原则）：类应该对扩展开放，对修改关闭。在添加新功能时不需要修改代码。符合该原则最典型的是装饰者模式，可以动态地将责任附加到对象上，而不用去修改类的代码。
L（里氏替换原则）：子类对象必须能够替换掉所有父类对象。
I（接口分离原则）：客户不依赖于他不使用的方法，使用多个专门的接口比使用单一的总接口要好。
D（依赖倒置原则）：高层级的模块不应该依赖于低层级的模块，他们应该都依赖于抽象。细节依赖于抽象，而不是抽象依赖于细节。高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
依赖于抽象意味着：任何变量都不应该持有一个指向具体类的指针或者引用。任何类都不应该从具体类派生。任何方法都不应该覆写它的任何基类中的已经实现的方法。

4.类和接口
接口和抽象类
abstract 抽象类和抽象方法，包含抽象方法的类必须是抽象类（抽象类也可以没有抽象方法）。抽象类不能被实例化，需要继承抽象类并实现所有抽象方法才能实例化其子类。
interface 接口没有任何的方法实现（Java8 开始也可以拥有默认的方法实现，修改接口的成本变低，子类可以直接调用接口的方法），接口的成员（字段 + 方法）默认都是 public（Java9 可以有私有方法，解决方法之间重复代码问题），接口的字段默认都是 static 和 final 的。接口的常量必须赋值。
接口可以有 public 和包访问权限。将接口从具体实现中解耦。创建一个类，可以代替为创建一个接口和一个工厂。优先选择类而不是接口，如果必须用接口，则必须进行重构。

在很多情况下，接口优先于抽象类（接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为），比较：
抽象类是 IS-A 关系，接口是 LIKE-A 关系
一个类可以实现多个接口，但只能继承一个抽象类。
接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限（抽象方法不能 private）。
接口中所有的方法隐含的都是抽象的（Java 8 开始接口方法可以有默认实现）。而抽象类则可以同时包含抽象和非抽象的方法。

选择接口：需要让不相关的类都实现一个方法（例如不相关的类都可以实现 Compareable 接口中的 compareTo()）。需要使用多重继承。
选择抽象类：需要在几个相关的类中共享代码。需要能控制继承来的成员的访问权限，而不是都为 public。需要继承非静态和非常量字段。
不管是抽象类还是接口，都不能通过抽象类或者接口直接创建对象，但可以通过匿名内部类的方式访问（让接口的引用来指向内部类对象，该内部类实现了接口）。

Comparator 接口：外部排序，定制比较器。出自 java.util 包。compare(Object obj1, Object obj2)，升序：obj1 - obj2。new Comparator<E>(){@Override public int compare(){}}。
Comparable 接口：在集合内部定义的方法实现的排序。出自 java.lang 包。compareTo(Object obj)，升序：this - obj。compareTo 和 Integer.compare 可以比较 Integer.MAX_VALUE 和 MIN。

枚举类 enum：
Java5 中引入，以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。
枚举类型确保 JVM 中仅存在一个常量实例，因此我们可以安全地使用 == 运算符比较两个变量。== 运算符可提供编译时和运行时的安全性。两个不同枚举类型进行比较，编译器会表示类型不兼容错误。如果两个值均为 null，都不会引发 NullPointerException。相反，如果使用 equals 方法，将抛出 NullPointerException。
可以有属性，方法和构造函数。
EnumSet 和 EnumMap
枚举可以用在单例模式和策略模式。

内部类：
嵌套的接口或类可以被实现为 private，从而不允许向上转型。
在外部类的非静态方法中生成指向内部类的引用，在创建内部类对象时需要 Outer.inner。
内部类对象能访问外部类的所有成员。内部类对象会捕获指向外部类对象的引用，如果是嵌套类（静态内部类），就不需要这个引用。
匿名内部类：通过实例初始化，达到为匿名内部类创建一个构造器的效果。继承受限，只能继承一个类或接口。格式：接口 对象=new 接口(){//重写所有抽象方法}。
嵌套类可以有 static 数据、字段和嵌套类，而普通内部类不行。
闭包和回调：闭包是可调用的对象，回调可以在运行时动态地决定需要调用的方法。

内部类最大的优点：每个内部类都能独立地继承一个接口的实现，无论外围类是否已经继承了某个接口的实现，对内部类都没有影响。
利用内部类，可以实现对类的多重继承。其他特性：内部类的多个实例与外部类独立；由多个内部类用不同方式实现同一个接口或类；创建内部类时不需要依赖外部类的创建；内部类是独立的实体。

.class 文件：外部类$内部类。
使用成员内部类的方式：
间接：在外部类的方法中使用内部类，然后调用这个外部类方法；
直接：外部类.内部类 对象=new 外部类().内部类();
外部类.this 表示外部类的对象。
需要重复使用对象或者类，就不要匿名。

局部内部类：定义在方法里面，只有在方法内可以使用这个内部类，不能有修饰符修饰 class。
希望访问方法的局部变量，则这个变量必须是（事实上）final 的。因为内部类的对象在堆内存中，存活得久，局部变量在栈内存中，希望能够使用这个局部变量，就要求局部变量不变，然后复制过来用。
匿名内部类 @Override。

this：表示对当前对象的引用。在构造方法中引用满足指定参数类型的构造器。除构造器外，禁止在其它方法中调用构造器。
super
访问父类的构造函数：委托父类完成一些初始化的工作。子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。
访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

this 和 super 必须是构造方法的第一个语句，不能同时使用，且不能用在 static 方法中。

Object 类方法：
equals()：equals() 判断引用的对象是否等价。equals 方法不能作用于基本数据类型的变量。类没有覆盖 equals() 方法，则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等。
==：基本数据类型 == 比较的是值，引用数据类型 == 判断两个变量是否引用同一个对象。
equals() 实现（重写）：检查是否为同一个对象的引用，如果是直接返回 true；检查是否是同一个类型，如果不是，直接返回 false；将 Object 对象进行转型；判断每个关键域是否相等。
String 中的 equals 方法是被重写过的（hashCode() 也被重写过），因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。推荐 "abc".equals(str)，因为当 str=null 时也不会报空指针异常。
Objects.equals(Object a,Object b) 是空指针安全的，Objects 工具类。Objects.requireNonNull。

hashCode()：native 本地操作系统给的地址值，十进制。当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。
但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。
Set 没有重复元素的前提（保证 key 唯一）：元素要重写 hashCode 和 equals 方法。
大大减少了 equals 的次数，提高了执行速度。

重写 equals 为什么要重写 hashCode？
相等的两个对象哈希值一定相同，哈希值相同的两个对象不一定相等。
默认的 hashCode() 是根据对象的内存地址经哈希算法得到哈希值。
如果没有重写 hashCode()，hashCode() 得出来的值不同，两个对象无法 equals()。
因此为了能 equals()，必须重写 hashCode()，使相等的对象有相同的哈希值。

主要是针对 HashSet 和 HashMap
如果不重写 hashcode 会出现什么问题？hashCode() 确定对象在 HashSet 中存放的位置，如果不重写 hashCode()，添加了两个等价对象但是存放的位置不同就会破坏 HashSet 的特性。

不能使用一个值为 null 的引用类型变量来调用非静态方法 equals()，否则会抛出空指针异常。
推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。
所有整形包装类对象值得比较必须使用 equals()。
浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。

clone()：protected 方法，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。
如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。
浅拷贝：对于复制对象进行引用传递，拷贝对象和原始对象引用同一个对象。对基本数据类型进行值传递。
深拷贝：创建了一个新的对象，并且复制原对象内的成员变量到新对象中，拷贝对象和原始对象的引用类型引用不同对象。对基本数据类型进行值传递。每一层的每个对象都进行浅拷贝=深拷贝。
使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。
反序列化 readObject() 从文件中还原类的对象，不通过构造函数创建对象。

toString()：默认打印对象的地址值，重写后打印的是对象中的成员变量。Scanner 和 Collection 重写了 toString()。
wait(), notify()，notifyAll()，getClass()
finalize()：使用了本地方法，调用非 java 代码的方式，需要用 finalize()。

5.关键字
final：
数据：声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。
对于基本类型，final 使数值不变。
对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

方法：声明方法不能被子类重写。在早期的 Java 版本中，Java 编译器会寻找机会内联所有的 final 方法，内联对于提升 Java 运行效率作用重大。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。现在的 Java 版本已经不需要使用 final 方法进行这些优化了。
private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

类：声明类不允许被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。

abstract 和 final 矛盾，不能同时使用。
final 第一次赋值后就不能再赋值了。
final 修饰成员变量，必须手动赋值而不会有默认值，赋值时只能用直接赋值或者构造方法赋值（二者选其一）（且所有的重载构造方法都对 final 赋值）。

static：
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。当类被 Java 虚拟机加载的时候，会对 static 变量进行初始化。静态变量存放在 Java 内存区域的方法区。而实例变量每创建一个实例就会产生一个，它与该实例同生共死。
静态方法：在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法（初始化顺序），方法中不能有 this 和 super 关键字（静态不需要对象）。调用静态方法可以无需创建对象（如果使用对象.静态方法会在编译后翻译为类.静态方法）。如果方法执行的操作不依赖于其类的各个变量和方法，设置为静态使程序的占用空间更小。
静态语句块：静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，在类初始化时运行一次。
静态内部类：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。
静态导包 JDK1.5
初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序，最后才是构造函数的初始化。
存在继承时的初始化顺序：父类（静态变量、静态语句块），子类（静态变量、静态语句块），父类（实例变量、普通语句块），父类（构造函数），子类（实例变量、普通语句块），子类（构造函数）。

6.反射
每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。
类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName() 这种方式来控制类的加载，该方法会返回一个 Class 对象。
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。
Class 和 java.lang.reflect 一起对反射提供了支持，后者主要包括 Field、Method 和 Constructor 三个类。

优点：可扩展性、用作类浏览器和可视化开发环境、用作调试器和测试工具。
缺点（如果一个功能可以不用反射完成，那么最好就不用）：性能开销、安全限制、内部暴露。

在运行时识别对象和类的信息。
三个动态特性：运行时生成对象实例。运行时调用方法。运行时更改属性。
方法：获取 Class 对象，newInstance() 获取对象实例，invoke() 调用方法。
反射用异常来报告检查结果。

反射：将类的各个组成部分封装为其他对象。IDEA 在运行中获取到一个对象的方法靠的是反射。
获取 Class 对象的方式：
Class.forName("全类名")：.class 阶段，将字节码文件加载进内存，返回 Class 对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类。
类名.class：Class 类对象阶段，通过类名的属性 class 获取。多用于参数的传递。
对象.getClass()：Runtime 运行时阶段，getClass() 方法在 Object 类中定义着。多用于对象的获取字节码的方式。

同一个字节码文件 (*.class) 在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个。
可以通过 Class 对象 get.getDeclaredFields() 获取所有的成员变量，不考虑修饰符，不加 Declared 则获取所有 public 修饰的成员变量。获取到之后可以用 Field 的 get/set 方法。
setAccessible(true)：暴力反射，忽略访问权限修饰符的安全检查。访问到 private。
空参构造方法的对象直接用 Class.newInstance() 获取而不需要 Constructor.newInstance()。

设计一个反射框架：不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。通过配置文件的形式。
将需要创建的对象的全类名和需要执行的方法定义在配置文件中
在程序中加载读取配置文件
使用反射技术来加载类文件进内存
创建对象
执行方法

RTTI：在编译时已经知道了所有的类型。使用 Class 对象。通过匿名基类的引用来发现类型信息。尽量使用多台，只在必须时使用 RTTI。
RTTI 和反射的区别：RTTI 编译器在编译时打开和检查.class 文件；对于反射，.class 文件在编译时不可获取，在运行时打开和检查.class 文件。

RMI 远程方法调用：用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上，也可以在同一个主机上。允许被远程调用的对象要通过一些标志加以标识。需要在运行时获取类的信息。

动态代理使用到了反射。

7.异常
Throwable 可以用来表示任何可以作为异常抛出的类，分为 Error 和 Exception。
Error 用来表示 JVM 无法处理的错误。它们在应用程序的控制和处理能力之外，这些错误发生时，JVM 一般会选择线程终止。
Exception 分为受检异常（需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复）和非受检异常（是程序运行时错误）。

常见运行时异常：空指针异常 NullPointerException，类型强制转换异常 ClassCastException，下标越界异常 IndexOutOfBoundsException，非法参数异常 IllegalArgumentException，无所需元素异常 NoSuchElementException。

异常处理：
try 块：可能产生异常的代码。其后可接零个或多个 catch 块（异常有父子关系则子类必须写在上面），如果没有 catch 块，则必须跟一个 finally 块。
catch 块：处理捕获到的异常。可以重新抛出异常。一般会把异常的信息记录到日志中。只有产生了异常才会执行 catch 里的代码。
finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。
当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。

在以下 4 种特殊情况下，finally 块不会被执行：
在 finally 语句块第一行发生了异常。因为在其他行，finally 块还是会得到执行。
在前面的代码中用了 System.exit(int) 已退出程序。若该语句在异常语句之后，finally 会执行。
程序所在的线程死亡。
关闭 CPU。

throw 和 throws 的区别：
Throw 用于方法内部，Throws 用于方法声明上。
Throw 后跟异常对象，Throws 后跟异常类型。
Throw 后只能跟一个异常对象，Throws 后可以一次声明多种异常类型。

Throw 抛出指定类型的异常对象，就必须处理这个对象。用 try...catch 或者 throws（没有处理就会和运行异常一样）。
调用声明了异常的方法，就必须处理这个声明的异常。

断言和日志

运行异常 RuntimeException：可以把异常对象（内容，原因，位置）交给虚拟机来处理，中断程序，并在控制台打印错误信息。
异常的方法（打印内容由少变多）：getMessage()、toString()、printStackTrace()。
父类方法没有抛出异常，子类重写该方法也不可以抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。
所有异常类都会有一个带异常信息的构造方法，方法内部 super() 让父类处理这个异常信息。
异常对性能不利。抛出异常首先要创建一个新的对象，Throwable 接口的构造函数调用名为 fillInStackTrace() 的本地同步方法，fillInStackTrace() 方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。
异常只能用于错误处理，不应该用来控制程序流程。
不要在循环中使用 try...catch...，应该把其放在最外层。

8.泛型
使用参数化类型，使代码可以应用于多种类型。不能使用基本类型用作类型参数。
使用泛型，可以在编译期防止将错误类型的对象放置到容器中。但是只能存储泛型类型的元素。
JDK1.7 开始 =new ArrayList<E>() 的 E 可以省略。

类型擦除：在泛型代码的内部，无法获得任何有关泛型参数类型的信息。

元组：仅一次方法调用就能返回多个对象。通过创建一个对象，来持有想要返回的多个对象。
通配符：被限制为单一边界。<?>，只能接受数据，不能往集合中存储数据。只能用在方法的参数。

未知的数据类型 E，在创建集合对象的时候，会确定泛型的数据类型。Class<E>。
泛型方法
含有泛型的接口可以指定接口的类型，public final class Scanner implements Iterator<String>{public String next(){}}。
泛型上限：<? extends E>，使用泛型只能是 E 类型或其子类。
泛型下限：<? super E>

9.注解 Annontation
Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。
Annontation 是 Java5 开始引入的新特征，包含在 java.lang.annotation 包中。

注解的用处：
这是最常见的生成文档。
跟踪代码依赖性，实现替代配置文件功能。
在编译时进行格式检查。

注解的原理：注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。
而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 $Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 Map 中索引出对应的值。而 memberValues 的来源是 Java 常量池。

元注解（专门注解其他的注解）：
@Documented：注解是否将包含在 JavaDoc 中。
@Retention：什么时候使用该注解。
@Target：注解用于什么地方。
@Inherited：是否允许子类继承该注解。

常见注解：@Override 重载、@Deprecated 不被推荐使用、@SuppressWarnings 抑制警告。

自定义注解格式：
元注解
public @interface 注解名称{
    属性列表;
}
编写规则：
所有的 Annotation 会自动继承 java.lang.annotation.Annotation 这一接口，并且不能再去继承别的类或是接口。
参数成员只能用 public 或 default 这两个访问权修饰。
参数成员只能用基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这些类型的数组。
如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可。
数组赋值时，值使用 {} 包裹。如果数组中只有一个值，则 {} 可以省略。
要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法。获取注解属性值，注解替换配置文件。
注解也可以没有定义成员，不过这样注解就没啥用了。

10.Java SE 8 新特性
lambda 表达式和函数式接口（有且只有一个抽象方法），()->{}。特点是延迟加载，如果最后一步不进行，则前置的几步也不会进行。
省略规则：小括号里的参数类型可以省略；如果小括号里只有一个参数则小括号可以省略；如果大括号里只有一条语句则大括号可以省略。
方法引用对 lambda 表达式的简化，:: 引用运算符。
函数式编程更加强调程序执行的结果而非执行的过程。

Optional 是一个简单的容器，其值可能是 null 或者不是 null。在 Java 8 之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在 Java 8 中，你应该返回 Optional 而不是 null。用于防止 NullPointerException。

Stream：能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回 Stream 本身，这样你就可以将多个操作依次串起来（Pipelining，有延迟执行和短路的优化）。Stream 的创建需要指定一个数据源。Stream 的操作可以串行执行或者并行执行（Parallel Streams）。
Stream 操作
Filter(过滤)：过滤通过一个 Predicate 接口来过滤并只保留符合条件的元素，该操作属于中间操作。
Sorted(排序)：如果你不指定一个自定义的 Comparator 则会使用默认排序，该操作属于中间操作。创建了一个排列好后的 Stream，而不会影响原有的数据源。
Map(映射)：中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。
Match(匹配)：Stream 提供了多种匹配操作，允许检测指定的 Predicate 是否匹配整个 Stream。所有的匹配操作都是最终操作，并返回一个 boolean 类型的值。
Count(计数)：计数是一个最终操作，返回 Stream 中元素的个数，返回值类型是 long。
Reduce(规约)：这是一个最终操作，允许通过指定的函数来讲 Stream 中的多个元素规约为一个元素，规约后的结果是通过 Optional 接口表示的。

Stream 不会对数据进行存储，而是按需计算。Stream 属于管道流，只能被消费一次，流到下一个 Stream 时，上一个 Stream 将会关闭。
内部迭代 forEach()。
中间操作（延迟方法）。

新的日期和时间 API
接口的默认方法：使用 default 关键字向接口添加非抽象方法实现。可以在不影响子类的情况下在接口添加默认方法，子类会继承到这个默认方法。接口也可以定义静态方法（也是 Java 8 开始的），可以直接用接口名调用。实现类对象是不可以调用接口的默认方法。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错（和普通的抽象方法不一样）。如果父类的方法和接口的默认方法冲突，则会优先选择父类的方法。                       
多重注解

11.Java 与 C++ 的区别
Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
Java 支持自动垃圾回收，而 C++ 需要手动回收。
Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。
Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。

面向对象与面向过程的区别

12.容器
容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对的映射表。
容器不能持有基本类型，需要使用自动包装。
集合可以装不同类型的对象。集合不加泛型时默认为 Object 类的对象，但是不安全，会引发 ClassCastException。
有序：存和取元素的顺序一致。
单向链表不能保证元素顺序，双向链表是有序的。
索引越界异常 IndexOutOfBoundsException

Collection
Set
TreeSet：基于红黑树实现，有序，支持范围查找，查找的时间复杂度为 O(logN)。

HashSet：基于 HashMap 实现，无序，查找的时间复杂度为 O(1)。使用 Iterator 遍历 HashSet 得到的结果是不确定的。
封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。如果向 HashSet 中添加一个已经存在的元素，新添加的集合元素不会覆盖已有的集合元素。
除了 clone()、writeObject()、readObject() 是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。

LinkedHashSet：内部使用双向链表维护元素的插入顺序，有序，具有 HashSet 的查找效率。

List：有序，有索引（可以普通 for 循环），允许重复。
ArrayList：基于动态数组实现，支持快速随机访问。实现了 RandomAccess（只是标识），Cloneable 和 Serializable 接口。默认大小为 10。
扩容：新容量的大小为旧容量的 1.5 倍，Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。
删除元素：System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)。

序列化：动态数组，保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，该关键字声明数组默认不会被序列化。
ArrayList 实现了序列化 writeObject() 和反序列化 readObject() 来控制只序列化数组中有元素填充那部分内容。
序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法。                  

Fail-Fast：modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。
在进行序列化或者迭代等操作时，若操作前后 modCount 发生变化，会抛出 ConcurrentModificationException。
java.util 包下面的所有的集合类都是快速失败 fail-fast 的。java.util.concurrent 包下面的所有的类都是安全失败 fail-safe 的。

List<Integer> list=new ArrayList<>();  //JDK 1.7 开始，右侧的 <> 内部可以不写。
对于 ArrayList 来说，直接打印 list 得到的不是地址值（重写了 toString()）。

Array 与 ArrayList 比较：
Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。
Array 大小是固定的，ArrayList 的大小是动态变化的。
基于效率和类型检查的考虑，应该尽可能使用 Array，无法确定数组大小时才使用 ArrayList。  

Vector：JDK1.2 之前，和 ArrayList 类似，但它是线程安全的，使用了 synchronized 进行同步。
与 ArrayList 的比较：
Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制。
Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。

代替方案：可以使用 Collections.synchronizedList()，得到一个线程安全的 ArrayList。也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。

CopyOnWriteArrayList
读写分离：写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。
适用场景：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。

缺陷
内存占用：在写操作时需要复制一个新的数组，内存占用为原来的两倍左右。
数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。
因此 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。

LinkedList：基于双向链表实现，只能顺序访问。实现了 Deque 接口。不仅如此，LinkedList 还可以用作栈、队列和双向队列。JDK1.6 之前为循环链表，JDK1.7 取消了循环。包含大量操作首尾元素的方法。
使 LinkedList 变成线程安全的：List list=Collections.synchronizedList(new LinkedList(...))。或者 BlockingQueue 阻塞队列和 ConcurrentLinkedQueue 非阻塞队列（CAS）。

与 ArrayList 的比较：
ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。
ArrayList 支持随机访问，查询快增删慢。LinkedList 不支持随机访问，查询慢增删快。
ArrayList 结尾会预留一定的容量空间花费空间，LinkedList 每一个元素都需要存放直接后继和直接前驱以及数据花费空间。

实现了 RandomAccess 接口的 list，优先选择普通 for 循环，其次 foreach。允许更改 list 的行为，提供良好的性能。
未实现 RandomAccess 接口的 list，优先选择 foreach（底层通过 Iterator 实现）。大 size 的数据，千万不要使用普通 for 循环。

Queue
PriorityQueue：基于堆结构实现，默认最小堆。调用 remove 方法，总会获得当前优先级队列中的最小元素。PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(logN)。JDK1.5 开始。

Stack

Map：键不能重复，一个键只能映射一个值。
TreeMap：基于红黑树实现。由 Comparable 或 Comparator 排序。

HashMap：基于哈希表实现，查询快，无序。Entry<K,V>[] table，数组中的每个位置被当成一个桶，一个桶存放一个链表 Entry（存储着键值对）。根据哈希值确定桶下标，再在链表上顺序查找。
拉链法解决冲突：put 操作头插法。要存入的元素与要存放位置上已有元素的 hash 值以及 key 相同的话直接覆盖。
HashMap 只允许一个 key 为 null，允许多个 value 为 null。因为无法调用 null 的 hashCode()，也就无法确定该键值对的桶下标，HashMap 使用第 0 个桶存放键为 null 的键值对。

扩容 resize：为了让查找的成本降低，table 长度要尽可能大，HashMap 采用动态扩容来根据当前的键值对数量来调整 table 长度。
默认的 table 容量 capacity 是 16。默认的装载因子 loadFactor 是 0.75（loadFactor 太大导致查找元素效率低，太小导致数组的利用率低）。默认的键值对数量 size 的临界值 threshold = capacity * loadFactor = 12。
当 Entry 的数量超过 threshold 且新建的 Entry 刚好落在一个非空的 table 上，触发扩容 capacity * 2，并采用 transfer() 将原有的 Entry 对象插入到新数组中（会进行 rehash() 重新计算桶下标），这一步是很费时的。
并发下的 rehash() 会造成元素之间会形成一个循环链表，JDK1.8 后解决了这个问题。

从 JDK1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。Entry 改为了 Node。为了提高查询速度。
为什么要使用红黑树？

capacity 是 2 的幂次方：tableSizeFor()。好处：
通过限制 length 是一个 2 的幂数，确定桶下标 indexFor() 中 h & (length-1) 和 h % length 结果是一致的。将取模操作转换成了 & 位运算，更加高效。在 rehash() 中也很有作用。
通过右移可以使低位的数据尽量的不同，从而使 hash 值的均匀分布减少碰撞。

Hashtable：和 HashMap 类似，但它是线程安全的，因此也效率低。遗留类。Hashtable 与 HashMap 比较：
Hashtable 使用 synchronized 来进行同步。
HashMap 可以插入键为 null 的 Entry。
HashMap 的迭代器是 fail-fast 迭代器。
HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
初始容量和扩容不同。
HashMap 链表长度大于 8 时，会转换为红黑树。

ConcurrentHashMap 支持线程安全，效率更高，因为 ConcurrentHashMap 引入了分段锁。HashEntry 代替 Entry。
JDK 1.7 分段锁 Segment：将数据分成一段一段的存储，然后给每一段数据配一把锁，每个分段锁维护着几个桶。实现并发更新操作。
当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。默认创建 16 个 Segment 锁（继承自 ReentrantLock），并发度与 Segment 数量相等。volatile 修饰数据。
ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。put 需要加锁。 

size 操作：每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。
ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

JDK 1.8 取消了分段锁，使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized（只锁定当前链表或红黑二叉树的首节点，只要 hash 不冲突，就不会产生并发）。也在链表过长时会转换为红黑树。

为什么 HashMap 支持 key 或者 value 为 null，而 HashTable 和 ConcurrentHashmap 不支持？
Hashtable 和 ConcurrentHashmap 都是支持并发的，这样会有一个问题，当你通过 get(k) 获取对应的 value 时，如果获取到的是 null 时，你无法判断，它是 put（k,v）的时候 value 为 null，还是这个 key 从来没有做过映射。
HashMap 是非并发的，可以通过 contains(key) 来做这个判断。而支持并发的 Map 在调用 m.contains（key）和 m.get(key)，m 可能已经不同了。

LinkedHashMap：使用双向链表来维护元素的顺序，有序，顺序为插入顺序或者最近最少使用 LRU 顺序。可以使用 LinkedHashMap 实现的一个 LRU 缓存。

WeakHashMap：Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。
Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。

IdentityHashMap:使用 == 代替 equals 对键进行比较。

容器中的设计模式：
迭代器模式：JDK1.2 开始，Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。hasNext() 判断，next() 取出下个元素（Object 类）。
JDK1.5 之后使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。
不要在 foreach 循环里进行集合类的 remove/add 操作，可以调用迭代器的 remove/add 方法。并发操作需要对 Iterator 对象加锁。
Java 中的 Iterator 可用来遍历 Set 和 List 集合，并且只能单向移动。ListIterator 实现了 Iterator 接口，既可以前向也可以后向遍历，还可以添加对象和修改对象。
Enumeration 接口和 Iterator 接口的区别：Enumeration 速度是 Iterator 的 2 倍，同时占用更少的内存。但是，Iterator 远远比 Enumeration 安全，因为其他线程不能够修改正在被 Iterator 遍历的集合里面的对象。同时，Iterator 允许调用者删除底层集合里面的元素，这对 Enumeration 来说是不可能的。
迭代：获取集合元素。迭代器的泛型和集合泛型一致。NoSuchElementException。Iterator 指针一开始在 -1。

适配器模式：Arrays.asList() 把数组类型转换为 List 类型，底层其实还是数组，不能使用其修改集合相关的方法。
注意传递的数组必须是对象数组，而不是基本类型。
也可以使用 List list = Arrays.asList(1, 2, 3);

集合类没有实现 Cloneable 和 Serializable 接口：应该由集合类的具体实现来决定如何被克隆或者是序列化。

13.I/O
进程中的 IO 调用过程：
进程向操作系统请求数据；
操作系统把外部数据加载到内核的缓冲区中；
操作系统把内核的缓冲区拷贝到进程的缓冲区；
进程获得数据完成自己的功能。

Java I/O 使用了装饰者模式来实现。

磁盘操作 File
File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。
从 Java7 开始，可以使用 Paths 和 Files 代替 File。

字节操作 InputStream 和 OutputStream
不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。

字符操作 Reader 和 Writer
编码就是把字符转换为字节，而解码是把字节重新组合成字符。
如果编码和解码过程使用不同的编码方式那么就出现了乱码。
charset：
ASCII：1 个字节；
GBK：中文字符占 2 个字节，英文字符占 1 个字节；
UTF-8：中文字符占 3 个字节，英文字符占 1 个字节；
UTF-16be：中文字符和英文字符都占 2 个字节。大端 Big Endian，大端序最高位字节存储在最低的内存地址处。
Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。
在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。

在程序中操作的通常是字符形式的数据。
InputStreamReader 实现从字节流解码成字符流。可以指定编码表。
OutputStreamWriter 实现字符流编码成为字节流。

write() 先把数据写到内存缓冲区（字符转换为字节），flush() 再把内存缓冲区的数据刷新到文件中。释放资源 close() 前也会隐含执行 flush()。
缓冲流 BufferedXxx。
FileReader 只能使用默认的编码 UTF-8。
PrintStream 打印流，永远不会抛出 IOException，extends OutputStream。
System.setOut(new PrintStream()) 可以改变输出语句的目的地。

获取键盘输入：通过 Scanner 或 BufferedReader。
Scanner sc=new Scanner(System.in);  //System.in 从键盘输入
int num=sc.nextInt();  //String str=new next();
匿名对象：只使用一次。作为方法的参数或返回值。

Random r=new Random();
int num=r.nextInt(10);  //左闭右开

既然有了字节流，为什么还要有字符流?
I/O 流操作分为字节流操作和字符流操作。
字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。
所以，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。
如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

对象操作 Serializable
序列化就是将一个对象转换成字节序列（流），方便存储和传输。
序列化：ObjectOutputStream.writeObject()。
反序列化：ObjectInputStream.readObject()。还需要存在类对应的 .class 文件，否则会抛出 ClassNotFoundException。也不能修改源代码使生成 UID 不同的 .class 文件，否则会抛出 InvalidClassException。
不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。
序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。
transient 关键字可以使修饰的变量不被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。

网络操作 Socket
InetAddress：用于表示网络上的硬件资源，即 IP 地址。没有公有的构造函数，只能通过静态方法来创建实例。
URL：统一资源定位，可以直接从 URL 中读取字节流数据。

Sockets：使用 TCP 协议实现网络通信。
ServerSocket：服务器端类
Socket：客户端类
服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。

Datagram：使用 UDP 协议实现网络通信。
DatagramSocket：通信类
DatagramPacket：数据包类

*新的输入输出 NIO
JDK 1.4 中引入，高速、面向块，基于通道&缓冲&选择器，同步非阻塞。
NIO 与普通 I/O 的区别主要有以下两点：非阻塞和面向块。

流与块
I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。
面向流的 I/O 一次处理一个字节数据，为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。然而面向流的 I/O 通常相当慢。
面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。
I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了。
虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。

NIO 核心组件：Channel，Buffer 和 Selector
通道 Channel：是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。
通道与流的不同之处在于，流只能在一个方向上移动 (一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。
通道包括以下类型：
FileChannel：从文件中读写数据；
DatagramChannel：通过 UDP 读写网络中数据；
SocketChannel：通过 TCP 读写网络中数据；
ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。
无论读写，通道只能和 Buffer 交互。因为 Buffer，通道可以异步地读写。
NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。

缓冲区 Buffer：不会直接对通道进行读写数据，而是要先经过缓冲区。
缓冲区实质上是一个数组，提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。
缓冲区状态变量。

选择器 Selector：NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。
通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时（单线程中从通道读取数据到 buffer，同时可以继续做别的事情，当数据读取到 buffer 中后，线程再继续处理数据），就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。
因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。
应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。
只是有效请求（确实需要进行 I/O 处理）时，才会使用一个线程去处理，避免了 BIO 模型下大量线程处于阻塞等待状态的情景。IO 操作本身是同步的。

内存映射文件 I/O：一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。
向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。

BIO：同步阻塞 I/O，数据的读取写入必须阻塞在一个线程内等待其完成。做完一件事再去做另一件事。在活动连接数不是特别高时，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。
如果需要同时做很多事情，就需要系统创建很多线程来完成对应的工作，因为 BIO 模型下一个线程同时只能做一个工作。如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态。
在 BIO 模型下的线程阻塞就会导致系统线程的切换，从而对整个系统性能造成一定的影响。
可以通过线程池机制改善。采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，客户端个数可以远远大于线程池最大线程数。

AIO：NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 
在 Unix 系统下，采用了 epoll IO 模型，windows 下是使用了 IOCP 模型。

Netty：非阻塞 I/O 客户端-服务器框架，主要用于开发 Java 网络应用程序，如协议服务器和客户端。
异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如 TCP 和 UDP 套接字服务器。
Netty 包括了反应器编程模式的实现。
除了作为异步网络应用程序框架，Netty 还包括了对 HTTP、HTTP2、DNS 及其他协议的支持，涵盖了在 Servlet 容器内运行的能力、对 WebSockets 的支持、与 Google Protocol Buffers 的集成、对 SSL/TLS 的支持以及对用于 SPDY 协议和消息压缩的支持。
从版本 4.0.0 开始，Netty 在支持 NIO 和阻塞 Java 套接字的同时，还支持使用 NIO.2 作为后端。

14.Servlet
在 Java Web 程序中，Servlet 主要负责接收用户请求 HttpServletRequest，在 doGet() 和 doPost() 中做相应的处理，并将回应 HttpServletResponse 反馈给用户。
Servlet 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有一个实例。
Servlet 需要在 web.xml 中配置（MyEclipse 中创建 Servlet 会自动配置）。Servlet 3.0 支持注解配置（从 JDK1.6 开始），无需 web.xml。

一个 Servlet 可以设置多个 URL 访问。Servlet 不是线程安全，多线程并发的读写会导致数据不同步的问题。 
Servlet 是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个 Servlet 类。Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递给 Servlet 程序，并将 Servlet 的响应回传给用户。通常一个 Servlet 会关联一个或多个 JSP 页面。
解决的办法是尽量不要定义 name 属性，而是要把 name 变量分别定义在 doGet() 和 doPost() 方法内。虽然使用 synchronized(name){} 语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。
如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此 Servlet 里的只读属性最好定义为 final 类型的。
可以让自定义的 Servlet 实现 SingleThreadModel 标识接口，实现单线程模式。如果将 Servlet 设置成单线程工作模式，会导致每个请求创建一个 Servlet 实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。

Servlet 相比 CGI 的优点：
只需要启动一个操作系统进程以及加载一个 JVM，大大降低了系统的开销。
如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销。
所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。
Servlet 能直接和 Web 服务器交互，还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。

生命周期： 
init()，service()，destroy()。
Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init() 方法进行 Servlet 的初始化。
请求到达时调用 Servlet 的 service() 方法，service() 方法会根据需要调用与请求对应的 doGet 或 doPost 等方法。
当服务器正常关闭或项目被卸载时服务器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy() 方法。
init 方法和 destroy 方法只会执行一次，service 方法客户端每次请求 Servlet 都会执行。
Servlet 中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入 init 方法中，销毁资源的代码放入 destroy 方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。

转发和重定向的区别：
转发 Forward 通过 RequestDispatcher 对象的 forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher() 方法获得。
重定向 Redirect 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。
转发是服务器行为，重定向是客户端行为。
地址栏显示：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。
数据共享：forward 转发页面和转发到的页面可以共享 request 里面的数据。redirect 不能共享数据。
运用地方：forward 一般用于用户登陆的时候，根据角色转发到相应的模块。redirect 一般用于用户注销登陆时返回主页面和跳转到其它的网站等。
效率：forward 高。redirect 低。

转发只能访问当前服务器下的资源，重定向可以访问其他站点（服务器）的资源。
转发是一次请求，重定向是两次请求。
给浏览器使用需要加虚拟目录，给服务器使用不需要加虚拟目录。

自动刷新 Refresh：自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet 中通过 HttpServletResponse 对象设置 Header 属性实现自动刷新。

JSP 和 Servlet：
Servlet 是一个特殊的 Java 程序，它运行于服务器的 JVM 中，能够依靠服务器的支持向浏览器提供显示内容。
JSP 本质上是 Servlet 的一种简易形式，JSP 会被服务器处理成一个类似于 Servlet 的 Java 程序，可以简化页面内容的生成。
Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为 .jsp 的文件。
JSP 侧重于视图，Servlet 更侧重于控制逻辑，在 MVC 架构模式中，JSP 适合充当 view 而 Servlet 适合充当控制器 controller。

Filter：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能，如登录验证、统一编码处理、敏感字符过滤等。
默认直接请求才会过滤，转发不会过滤，可以设置 DispatcherTypes 属性改变。
过滤器链和执行顺序。
Filter->Servlet，Servlet 包含在 SpringMVC 中，称为 DispatcherServlet。SpringMVC 的 Interceptor 也能起过滤的作用，DispatcherServlet->Interceptor->Controller。

Listener

15.补充
JRE 和 JDK：
JRE 是 Java 运行时环境，包含了 Java 虚拟机，Java 基础类库。是使用 Java 语言编写的程序运行所需要的软件环境，是提供给想运行 Java 程序的用户使用的。
JDK 是 Java 开发工具包，是程序员使用 Java 语言编写 Java 程序所需的开发工具包，是提供给程序员使用的。JDK 包含了 JRE，同时还包含了编译 Java 源码的编译器 javac 和调试器等。
如果你需要运行 Java 程序，只需安装 JRE 就可以了。如果你需要编写 Java 程序，需要安装 JDK。

Oracle JDK 和 OpenJDK：
OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；
Oracle JDK 比 OpenJDK 更稳定。
Oracle JDK 与 OpenJDK 相比提供了更好的性能；

javax 包是标准 API 的一部分。
只有 java.lang 包不需要导。

SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类(DateFormat 类是一个抽象类)，它允许进行格式化 format（日期→文本）、解析 parse（文本→日期）和规范化。
new SimpleDateFormat(构造方法指定模式)，SimpleDateFormat.parse 当字符串和构造方法中的模式不一样时，会抛 ParseException。
Date 类过时，被 Calendar 代替。Calendar 是一个抽象类，其中静态方法 getInstance() 返回 Calendar 子类对象。 

SimpleDateFormat 为什么不是线程安全的？
在 SimpleDateFormat 转换日期是通过 Calendar 对象来操作的，SimpleDateFormat 继承 DateFormat 类，DateFormat 类中维护一个 Calendar 对象，Calendar 实例被用来进行日期-时间计算，既被用于 format 方法也被用于 parse 方法。
在 parse 方法的最后，会调用 CalendarBuilder 的 establish 方法，入参就是 SimpleDateFormat 维护的 Calendar 实例，在 establish 方法中会调用 calendar 的 clear 方法。
SimpleDateFormat 维护的用于 format 和 parse 方法计算日期-时间的 calendar 被清空了，如果此时线程 A 将 calendar 清空且没有设置新值，线程 B 也进入 parse 方法用到了 SimpleDateFormat 对象中的 calendar 对象，此时就会产生线程安全问题。

解决方法：每一个使用 SimpleDateFormat 对象进行日期-时间进行 format 和 parse 方法的时候就创建一个新的 SimpleDateFormat 对象，用完就销毁。此时就可以使用 ThreadLocal 将 SimpleDateFormat 绑定到线程上。

可变参数：JDK1.5 之后，参数列表的类型已经确定，但是参数的个数不确定。格式：方法名(数据类型...变量名)
底层就是数组（变量名），会根据传递参数个数的不同创建不同长度的数组来存储这些参数。传递参数个数可以是 0 个。  
参数列表只能有一个可变参数，且可变参数必须写在参数列表的末尾。

JDK1.9 的 List、Set、Map 接口（其实现类不可以）的静态方法 of：给集合一次性添加多个元素。

Properties 是唯一和 IO 流相结合的集合。Properties extends Hashtable，key 和 value 默认都是 String。

AJAX：是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 
通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。提升用户的体验。
传统的网页如果需要更新内容，必须重载整个网页页面。
AJAX 请求是否安全，由服务端（后台）决定。AJAX 出现后，请求方式变多了，以前的架构在新的请求中就可能出现更多漏洞。
AJAX 受到浏览器的同源策略限制。
AJAX 默认无法请求跨域的接口，当然后台可以配置 Access-Control-Allow-Origin:* 之类的允许所有的跨域请求。
AJAX 请求无法携带跨域 cookie，如果强行开启 withCredentials，必须服务端配合认证，无法用作攻击。

从本质上将：AJAX 就是浏览器发出的 HTTP 请求，只不过是浏览器加上了一个同源策略限制而已。AJAX 请求的 XMLHTTPRequest 对象就是浏览器开放给 JS 调用 HTTP 请求用的。
AJAX 和 HTTP 的区别：
AJAX 请求受到浏览器的同源策略限制，存在跨域问题。
AJAX 在进行复杂请求时，浏览器会预先发出 OPTIONS 预检，而 HTTP 是不会预检的。
从使用角度上说，AJAX 使用简单一点，少了些底层细节，多了些浏览器特性（如自动带上同域 cookie 等）。

和认证上的 HTTP 请求的区别就是多了一次浏览器的封装而已（浏览器会有自己的预处理，加上特定限制）。
但是，从最终发出的报文来看，内容都是一样的（HTTP 协议规范的内容），AJAX 是发送 HTTP 请求的一种方式。
AJAX 本质上安全性和 HTTP 请求一样。

JSON：JS 对象表示法，多用于存储和交换文本信息的语法，进行数据的传输，比 XML 更小、更快、更易解析。
Jackson 是 SpringMVC 内置的 JSON 解析器。

回调函数
