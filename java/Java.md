## 简介

**Java 语言的特点**

- 面向对象

- 平台无关性（JVM 实现）

- 可靠性

- 安全性

- 支持多线程

- 支持网络编程并且很方便（Java 语言诞生本身就是为简化网络编程设计的）

- 编译与解释并存

**Java 与 C++ 的区别**

- Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object。C++ 为了兼容 C 即支持面向对象也支持面向过程。

- Java 通过 JVM 实现跨平台特性。C++ 依赖于特定的平台。

- Java 没有指针，它的引用可以理解为安全指针。C++ 具有和 C 一样的指针。

- Java 支持自动垃圾回收。C++ 需要手动回收。

- Java 不支持多重继承，只能通过实现多个接口来达到相同目的。C++ 支持多重继承。

- Java 不支持操作符重载（对两个 String 对象执行加法运算属于语言内置支持的操作）。 C++ 支持操作符重载。

- Java 的 goto 是保留字，但是不可用。C++ 可以使用 goto。

- Java 不支持条件编译。C++ 通过预处理命令实现条件编译。



## 1.数据类型

#### 基本数据类型

byte（8）

char（16），short（16）

int（32），float（32）

long（64），double（64）

boolean（true/false）：单独存在时占 4B，在 boolean[] 中占 1B。因为 JVM 没有用于操作 boolean 的字节码指令，在编译后用 int 的数据类型代替 boolean，此时 boolean 占 4B。而 boolean[] 编译后会被 byte[] 代替，此时的 boolean 占 1B。

**特点**

基本数据类型储存在栈中更加高效。

所有数值类型都有正负号。

浮点数只是一个近似值，默认类型是 double。整数默认类型是 int。

float 表示的范围要大于 long。

double 值也可以 ++。

编译器的常量优化：javac 会将常量表达式计算后赋值给变量。

**精度大小**

**强制类型转换 cast**

(范围小的类型)范围大的类型。有可能发生精度损失、数据溢出。

Java 不能隐式执行向下转型，因为这会使得精度降低。但 ++、+=、-=、*=、/=、%= 复合赋值运算符会执行隐式的强制类型转换。a=a+b 和 a+=b 有区别。

char byte short 在进行数学运算时会先提升为 int。boolean 不能发生数据类型转换。

javac 会在 char、byte、short 赋值时右侧数值没有超过范围时隐式强转，超过范围则会报错。

#### 包装类型

基本类型都有对应的包装类型，为了让基本类型也具有对象的特征，并且为其添加了属性和方法，丰富了基本类型的操作。

包装类不能被继承。

包装类大部分实现了常量池技术。

通过包装类能把基本数据类型放入集合类中。

**自动装箱与拆箱**

基本类型与其对应的包装类型之间的转换通过自动装箱与拆箱（JDK1.5 之后）：

```java
Integer i = 10;  //装箱，调用了 Integer.valueOf(10)
int b = i;       //拆箱，调用了 i.intValue()
```

两个包装类型之间的运算，会被自动拆箱成基本类型进行：

```java
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
i4 == i5 + i6  //true
```

语句 i4 == i5 + i6，因为 + 这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

**字符串**

除了 Character 类之外，其他包装类都有静态方法 parseXxx() 将字符串转换为对应的基本类型。

将基本类型转换为字符串：基本类型 + "" 最简单的方式，静态方法 toString(int i) 和 valueOf(int i)。

由于自动拆箱，如果包装类对象为 null，那么自动拆箱时就有可能抛出 NPE。大量的拆装箱操作会浪费资源。

#### 缓存池

**new Integer() 与 Integer.valueOf() 的区别**

new Integer() 每次都会新建一个对象。

Integer.valueOf() 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

**Integer 缓存池**

在 Java 8 中，Integer 缓存池的大小默认为 -128-127。且这个上界是可调的，这个区间是性能和资源之间的权衡。

编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。

**基本类型对应的缓冲池**

在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。

boolean values true and false

all byte values

short values between -128 and 127

int values between -128 and 127

char in the range \u0000 to \u007F。

在程序中，第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存。范围内的时，将 p 包装成 a 和 b 两个对象时，可以直接使用 a==b 判断 a 和 b 的值是否相等。这个范围之外还是需要使用 equals 比较。

#### **值传递**

Java 的参数是以值传递的形式传入方法中，而不是引用传递。

在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。形参和实参是两个不同的对象。

在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。

```java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName("B");
    }
}
```

但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。

```java
public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
```

#### 变量

**成员变量和局部变量的区别**

- 如果成员变量使用 static 修饰，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而局部变量是在方法中定义的变量或是方法的参数。
- 成员变量可以被 public，private，static，final 等修饰符所修饰。局部变量不能被访问控制修饰符及 static 所修饰，但能被 final 所修饰。

- 对象存在于堆内存，速度较慢。局部变量则存在于栈内存，速度较快。成员变量是对象的一部分，它随着对象的创建而存在。而局部变量随着方法的调用而自动消失，不需要额外的垃圾回收。。

- 成员变量没有被赋初值时，如果是基本数据类型则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），如果是引用类型则为 null。局部变量则不会自动赋值。

- 当方法中的局部变量和成员变量重名时，会就近使用局部变量。所以要用 this. 区分。

**可变参数**

JDK1.5 之后，参数列表的类型已经确定，但是参数的个数不确定。格式：方法名(数据类型...变量名)

底层就是数组（变量名），会根据传递参数个数的不同创建不同长度的数组来存储这些参数。传递参数个数可以是 0 个。 

参数列表只能有一个可变参数，且可变参数必须写在参数列表的末尾。

**大数值**

BigInteger 和 BigDecimal 实现任意精度。但是运算速度变慢。BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念。

在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。

**构造函数**

完成对类对象的初始化工作，总与 new 运算符一起使用在创建对象的语句中。

与其它方法不同，构造器没有返回类型，但不能用 void 声明构造方法。不会被继承和重写，可以有访问权限修饰符，函数内不能有递归。构造函数称必须和它所属的类的名称相同。

一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。

一个类即使没有声明构造方法也会有默认的不带参数的构造方法。但如果自己编写了带参数的构造方法，则不会赠送默认无参数的构造方法了。



## 2.关键字

#### final

abstract 和 final 矛盾，不能同时使用。

Java 编译器会寻找机会内联所有的 final 方法，内联对于提升 Java 运行效率作用重大。

将常量声明为 static final，并以大写命名，这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。

**数据**

声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变。

- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

final 第一次赋值后就不能再赋值了。

final 修饰成员变量，必须手动赋值而不会有默认值，赋值时只能用直接赋值或者构造方法赋值（二者选其一）（且所有的重载构造方法都对 final 赋值）。

**方法**

声明方法不能被子类重写。在早期的 Java 版本中，Java 编译器会寻找机会内联所有的 final 方法，内联对于提升 Java 运行效率作用重大。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。现在的 Java 版本已经不需要使用 final 方法进行这些优化了。

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

**类**

声明类不允许被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。

#### static

**静态变量**

又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。

实例变量每创建一个实例就会产生一个，它与该实例同生共死。

当类被 JVM 加载的时候，会对静态变量进行初始化。静态变量存放在 Java 内存区域的方法区。

当某个对象被静态变量引用，那么 GC 通常是不会回收这个对象所占有的堆内存的。如果类不被卸载，那么引用指向的对象会常驻内存，直到程序终止。

**静态方法**

在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

只能访问所属类的静态字段和静态方法（初始化顺序），方法中不能有 this 和 super 关键字（静态不需要对象）。调用静态方法可以无需创建对象（如果使用对象.静态方法会在编译后翻译为类.静态方法）。如果方法执行的操作不依赖于其类的各个变量和方法，设置为静态使程序的占用空间更小。

**静态语句块**

静态代码块定义在类中方法外。该类不管创建多少对象，在类初始化时运行一次。

**静态内部类**

非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。

非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。

静态内部类不能访问外部类的非静态的变量和方法。

**静态导包**

JDK1.5。在使用静态变量和方法时不用再指明类名。简化代码，但可读性降低。

**初始化顺序**

静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序，最后才是构造函数的初始化。

**存在继承时的初始化顺序**

父类（静态变量、静态语句块）

子类（静态变量、静态语句块）

父类（实例变量、普通语句块）

父类（构造函数）

子类（实例变量、普通语句块）

子类（构造函数）

**switch**

从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。switch 还可以 byte short char int 和枚举 enum。

## 3.数组和字符串

#### 数组

查询快，增删慢。数组是一种效率最高的存储和随机访问对象引用序列的方式。大小不能改变。增删时需要新建数组，复制原数组的元素，销毁原数组，效率低下。

实现了 Iterable 接口，可以用 foreach 方法来遍历。

二维数组本质上也是一维数组，只是数组中的每一个元素都指向了另一个一维数组而已。

初始化默认值：大括号初始化数组必须出现在创建数组的地方。

范围检查：不能在数组范围之外被访问。

拷贝：多余赋默认值，不够只拷贝最前面的元素。

#### String

\+ 表示字符连接，任何数据类型和字符串连接时都会得到字符串。

字符串是常量，可以共享使用。

StringBuilder 底层也是 byte[] value，但是没有被 final 修饰，超出了容量会自动扩容。

**基本数据类型转为字符串**

toString() 是最快的方式。

String.valueOf() 次之。底层调用了 toString() 方法，但是会在调用前做空判断。

数据 + "" 最慢。底层使用了 StringBuilder 实现，先用 append 方法拼接，再用 toString() 方法获取字符串。

#### 不可变

在 Java 8 中，String 内部使用 char 数组存储数据。

在 Java 9 之后，String 类的实现改用 byte[] value 存储字符串，同时使用 coder 来标识使用了哪种编码。

**为什么不可变？**

String 类被声明为 final，因此它不可被继承。

内部实现 final byte[] value，这意味着 value 数组初始化之后就不能再引用其它数组。

并且 String 内部没有改变 value 数组的方法。

**不可变的好处**

- 可以缓存 hash 值：因为 String 的 hash 值经常被使用，不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
- String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
- 安全性：String 经常作为参数，String 不可变性可以保证参数不可变。
- 线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

**自己实现一个不可变的类**

将类声明为 final，所以它不能被继承

将所有的成员声明为私有的，这样就不允许直接访问这些成员

对变量不要提供 setter 方法

将所有可变的成员声明为 final，这样只能对它们赋值一次

通过构造器初始化所有成员，进行深拷贝 (deep copy)

在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝

#### String、StringBuffer 和 StringBuilder

- String 不可变，StringBuffer 和 StringBuilder 可变。

- String 是线程安全的，StringBuffer 是线程安全的（内部使用 synchronized 进行同步），StringBuilder 不是线程安全的。

- 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer（StringBuilder）每次都会对 StringBuffer（StringBuilder） 对象本身进行操作，而不是生成新的对象并改变对象引用。对本身操作能让 JVM 在生成对象和垃圾回收节约资源，提升性能。

- StringBuilder 占用空间少，性能好。

#### 字符串常量池 String Pool

保存着所有字符串字面量，这些字面量在编译时期就确定，直接使用双引号声明出来的 String 对象会直接存储在常量池中。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。

**字符串.intern()** 

如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。

**内存区域**

JDK1.7 之前，String Pool 被放在运行时常量池中，它属于永久代。JDK1.7 及以后，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

**String 对象的两种创建方式**

```java
String str1 = "abcd";                //先检查字符串常量池中有没有 abcd，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象；如果有，则直接将 str1 指向 abcd。JDK1.7 之前，是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。JDK1.7 及以后的处理方式是在常量池中记录此字符串的引用，并返回该引用。

String str2 = new String("abcd");    //堆中创建一个新的对象。只要使用 new 方法，便需要创建新的对象。
```

**String s = new String("abc"); 这句话创建了几个字符串对象？**

将创建 1 或 2 个字符串。

如果池中已存在字符串文字 abc，则堆中只会创建一个字符串 s。

如果池中没有字符串文字 abc，那么它将首先在池中创建，然后在堆中创建字符串 s，因此将创建总共 2 个字符串对象。



## 4.面向对象思想（封装、继承和多态）

**面向对象和面向过程**

**面向过程**

自顶而下的编程模式，把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。

**面向对象**

将事务高度抽象化的编程模式，把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。

**区别**

- 面向对象易维护、易复用、易扩展。

- 性能低。因为类调用时需要实例化，开销大，消耗资源。

#### 封装

利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。

数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。

用户和其他模块无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

方法是一种封装，private 也是一种封装。

**优点**

- 减少耦合：模块可以独立地开发、调试和修改。

- 有助于剖析哪些模块影响了系统的性能。
- 减轻维护的负担。
- 提高软件的可重用性。
- 降低了构建大型系统的风险，提高安全性。

#### 继承

可以使用现有类的功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

实现了 IS-A 关系，遵循里式替换原则。子类需要能够当成父类来使用，并且需要比父类更特殊。

Java 是单继承。

向上转型：父类引用指向子类对象。

**优点**

减少代码重复，提高代码可维护性。

**this 和 super**

**this**

表示对当前对象的引用。在构造方法中引用满足指定参数类型的构造器。除构造器外，禁止在其它方法中调用构造器。

**super**

- 访问父类的构造函数：委托父类完成一些初始化的工作。子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。

- 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

this 和 super 必须是构造方法的第一个语句，不能同时使用，且不能用在 static 方法中。

**组合**

HAS-A 关系，整体与部分、拥有的关系。

**组合与继承的区别和联系**

在继承结构中，父类的内部细节对于子类是可见的。如果基类的实现发生改变，那么派生类的实现也将随之改变。

继承在写代码的时候就要指名具体继承哪个类，所以在编译期就确定了关系。

子类能自动继承父类的接口。

创建子类的对象时，无须创建父类的对象。

组合是通过对现有的对象进行拼装产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的。因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法。

可以采用面向接口编程，在运行期动态改变，因此提高了应用的灵活性。

不破坏封装，松耦合，可扩展性高。

整体对象可以选择不同类型的局部对象。

整体类可以对局部类进行包装，封装局部类的接口，提供新的接口。

组合确实比继承更加灵活，也更有助于代码维护。

建议在同样可行的情况下，优先使用组合而不是继承。因为组合更安全，更简单，更灵活，更高效。

是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。只有当两者之间确实存在 is-a 关系的时候，类 B 才应该继承类 A。

访问子类成员变量的两种方法

直接通过子类对象访问：优先用 new 等式左边。

间接通过成员方法访问：优先用方法属于的类。

没有则向上找父类。

**访问权限修饰符**

可以对类或类中的成员（字段和方法）加上访问修饰符。类可见表示其它类可以用这个类创建实例对象。成员可见表示其它类可以用这个类的实例对象访问到该成员。

封装要求访问权限应当尽可能地使每个类或者成员不被外界访问。

**private**

属性和方法可以通过反射访问。

**package**

默认包可见。

**protected**

修饰成员，在继承体系中成员对于子类可见，修饰类没有意义。

不同包下，在子类中通过父类引用不可以访问其 protected 方法，通过该子类引用可以访问其 protected 方法，不能通过另一个子类引用访问共同基类的 protected 方法。protected 的静态变量，无论是否同一个包，在子类中均可直接访问。

**public**



如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。确保满足里氏替换原则。

字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。

如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

#### **重写与重载**

**重写 Override**

存在于继承体系中，指子类实现了一个与父类在方法声明（方法名称、参数列表和返回类型）上完全相同的一个方法。

运行期。final，private，static 方法不能被重写，其他方法都是运行时绑定。

**@Override 注解让编译器帮忙检查重写满足里式替换原则的三个限制条件**

- 子类方法的访问权限必须大于等于父类方法。

- 子类方法的返回类型必须是父类方法返回类型或为其子类型。
- 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型（或者不抛出异常）。

**方法调用的优先级**

在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。

this.func(this)

super.func(this)

this.func(super)

super.func(super) 

**重载 Overload**

存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、多类型顺序至少有一个不同。

返回类型（参数名称）不同，其它都相同不算是重载。

编译期。

重载的方法可以改变访问修饰符，可以声明新的或更广的检查异常。

子类可以重载父类的方法，先继承方法，再重载。

#### 多态

相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。

编译时多态：方法的重载。此处有争议。编译期。

运行时多态：引用变量的具体类型在运行期才知道，即动态绑定。

**运行时多态的三个条件**

继承，重写，向上转型。

**例子**

乐器类有两个子类吉他和钢琴，它们都重写了父类的 play()，使用父类乐器类来引用子类吉他和钢琴对象，使用乐器类调用 play() 时，会执行吉他类和钢琴类的 play()。

向下转型前需要 instanceof 判断，否则会出现 ClassCastException。

当想要调用父类中被重写的方法时，则需使用关键字 super。

**类图**

- 泛化关系 extends

- 实现关系 implements

- 聚合关系：表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。

- 组合关系：和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。

- 关联关系：表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。

- 依赖关系：和关联不同，在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：A 类是 B 类方法的局部变量。A 类是 B 类方法的参数。A 类向 B 类发送消息，从而影响 B 类发生变化。

#### SOLID 设计原则

- 单一责任原则 S：一个类只负责一件事。当这个类需要做过多事情的时候，就需要分解这个类。如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

- 开放封闭原则 O：类应该对扩展开放，对修改关闭。在添加新功能时不需要修改代码。

- 里氏替换原则 L：子类对象必须能够替换掉所有父类对象。如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

- 接口分离原则 I：客户不依赖于他不使用的方法。使用多个专门的接口比使用单一的总接口要好。

- 依赖倒置原则 D：高层级的模块不应该依赖于低层级的模块，他们应该都依赖于抽象。细节依赖于抽象，而不是抽象依赖于细节。高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。依赖于抽象意味着，任何变量都不应该持有一个指向具体类的指针或者引用。任何类都不应该从具体类派生。任何方法都不应该覆写它的任何基类中的已经实现的方法。



## 5.类和接口

#### 抽象类和接口

**抽象类**

abstract 抽象类和抽象方法，包含抽象方法的类必须是抽象类（抽象类也可以没有抽象方法）。抽象类不能被实例化，需要继承抽象类并实现所有抽象方法才能实例化其子类。

**接口**

interface 接口，可以看成是一个完全抽象的类，不能有任何的方法实现。Java 8 开始也可以拥有默认的方法实现，降低接口的维护成本，子类可以直接调用接口的方法。

接口的成员（字段+方法）默认都是 public，并且不允许定义为 private 或者 protected。Java9 可以有私有方法，解决方法之间重复代码问题。

接口的字段默认都是 static 和 final 的。接口的常量必须赋值。

接口可以有 public 和包访问权限。

**抽象类和接口的比较**

- 创建一个类，可以代替为创建一个接口和一个工厂。

- 接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

- 抽象类是 IS-A 关系，接口是 LIKE-A 关系。

- 一个类可以实现多个接口，但只能继承一个抽象类。

- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限（抽象方法不能 private）。

- 接口中所有的方法隐含的都是抽象的（Java 8 开始接口方法可以有默认实现）。而抽象类则可以同时包含抽象和非抽象的方法。
- 不管是抽象类还是接口，都不能通过抽象类或者接口直接创建对象，但可以通过匿名内部类的方式访问（让接口的引用来指向内部类对象，该内部类实现了接口）。

**抽象类和接口使用选择**

**选择接口**

需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo()。

需要使用多重继承。

**选择抽象类**

需要在几个相关的类中共享代码。

需要能控制继承来的成员的访问权限，而不是都为 public。

需要继承非静态和非常量字段。

#### **Comparator 和 Comparable**

Comparator 接口：外部排序，定制比较器。出自 java.util 包。compare(Object obj1, Object obj2)，升序：obj1 - obj2。new Comparator<E>(){@Override public int compare(){}}。

Comparable 接口：在集合内部定义的方法实现的排序。出自 java.lang 包。compareTo(Object obj)，升序：this - obj。compareTo 和 [Integer.compare](http://integer.compare/) 可以比较 Integer.MAX_VALUE 和 MIN。

#### 枚举类 enum

Java5 中引入，以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。

枚举类型确保 JVM 中仅存在一个常量实例，因此我们可以安全地使用 == 运算符比较两个变量。== 运算符可提供编译时和运行时的安全性。两个不同枚举类型进行比较，编译器会表示类型不兼容错误。如果两个值均为 null，都不会引发 NullPointerException。相反，如果使用 equals 方法，将抛出 NullPointerException。

可以有属性，方法和构造函数。

EnumSet 和 EnumMap

枚举可以用在单例模式和策略模式。

#### 内部类

嵌套的接口或类可以被实现为 private，从而不允许向上转型。

在外部类的非静态方法中生成指向内部类的引用，在创建内部类对象时需要 Outer.inner。

内部类对象能访问外部类的所有成员。内部类对象会捕获指向外部类对象的引用，如果是嵌套类（静态内部类），就不需要这个引用。

匿名内部类：通过实例初始化，达到为匿名内部类创建一个构造器的效果。继承受限，只能继承一个类或接口。格式：接口 对象=new 接口(){//重写所有抽象方法}。

嵌套类可以有 static 数据、字段和嵌套类，而普通内部类不行。

闭包和回调：闭包是可调用的对象，回调可以在运行时动态地决定需要调用的方法。

内部类最大的优点：每个内部类都能独立地继承一个接口的实现，无论外围类是否已经继承了某个接口的实现，对内部类都没有影响。

利用内部类，可以实现对类的多重继承。其他特性：内部类的多个实例与外部类独立；由多个内部类用不同方式实现同一个接口或类；创建内部类时不需要依赖外部类的创建；内部类是独立的实体。

.class 文件：外部类$内部类。

使用成员内部类的方式：

间接：在外部类的方法中使用内部类，然后调用这个外部类方法；

直接：外部类.内部类 对象=new 外部类().内部类();

外部类.this 表示外部类的对象。

需要重复使用对象或者类，就不要匿名。

局部内部类：定义在方法里面，只有在方法内可以使用这个内部类，不能有修饰符修饰 class。

希望访问方法的局部变量，则这个变量必须是（事实上）final 的。因为内部类的对象在堆内存中，存活得久，局部变量在栈内存中，希望能够使用这个局部变量，就要求局部变量不变，然后复制过来用。

匿名内部类 @Override。

#### Object 类方法

**equals()**

equals() 判断引用的对象是否等价。equals 方法不能作用于基本数据类型的变量。

类没有重写 equals() 方法，则通过 equals() 比较该类的两个对象时，等价于通过 == 比较这两个对象。一般，我们都重写 equals() 来比较两个对象的内容是否相等。

**==**

基本数据类型 == 比较的是值。

引用数据类型 == 判断两个变量是否引用同一个对象。

**equals() 的重写方法**

1. 检查是否为同一个对象的引用，如果是直接返回 true。

2. 检查是否是同一个类型，如果不是，直接返回 false。
3. 将 Object 对象进行转型。
4. 判断每个关键域是否相等。

String 中的 equals 方法是被重写过的（hashCode() 也被重写过），因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

推荐 "abc".equals(str)，因为当 str=null 时也不会报空指针异常。

Objects.equals(Object a,Object b) 是空指针安全的，Objects 工具类。Objects.requireNonNull。

不能使用一个值为 null 的引用类型变量来调用非静态方法 equals()，否则会抛出空指针异常。

所有整型包装类对象值的比较必须使用 equals()。

浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals() 来判断。

**hashCode()**

本地操作系统给的内存地址值（无符号十六进制）经哈希算法得到哈希值。

大大减少了 equals 的次数，提高了执行速度。

**重写 equals() 为什么要一定要重写 hashCode()？**

- 等价的两个对象哈希值一定相同，哈希值相同的两个对象不一定等价。因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。

- 如果没有重写 hashCode()，两个对象 hashCode() 得出来的值不同，等价对象无法 equals()。

- 因此为了能 equals()，必须重写 hashCode()，保证等价的两个对象哈希值也相等。

- 主要是针对 HashSet 和 HashMap 等集合类，如果没有重写 hashCode()，则会导致集合中有两个等价的对象。

**设计哈希函数**

理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。

R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出。一个数与 31 相乘可以转换成移位和减法，编译器会自动进行这个优化。

**clone()**

protected 方法，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。

如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。

**浅拷贝与深拷贝**

浅拷贝：对于复制对象进行引用传递，拷贝对象和原始对象引用同一个对象。对基本数据类型进行值传递。

深拷贝：创建了一个新的对象，并且复制原对象内的成员变量到新对象中，拷贝对象和原始对象的引用类型引用不同对象。对基本数据类型进行值传递。每一层的每个对象都进行浅拷贝=深拷贝。

**拷贝构造函数 or 拷贝工厂代替 clone()**

使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()。

**其他方法**

wait(), notify()，notifyAll()，getClass()

**toString()**

默认打印对象的地址值，重写后打印的是对象中的成员变量。Scanner 和 Collection 重写了 toString()。

**finalize()**

使用了本地方法，调用非 java 代码的方式，需要用 finalize()。



## 6.反射

反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。

反射用异常来报告检查结果。

动态代理使用到了反射。	

**优点**

- 程序运行时操作对象。

- 提高可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- 用作类浏览器和可视化开发环境，用作调试器，测试工具。

**缺点**

- 性能开销：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。
- 安全限制
- 内部暴露：导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

如果一个功能可以不用反射完成，那么最好就不用。

如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存。因为用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。

#### Class 对象

每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。

类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName() 这种方式来控制类的加载，该方法会返回一个 Class 对象。

**获取 Class 对象**

- Class.forName("全类名")：将字节码文件加载进内存，返回 Class 对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类。

- 类名.class：通过类名的属性 class 获取。多用于参数的传递。

- 对象.getClass()：getClass() 方法在 Object 类中定义着。多用于对象的获取字节码的方式。

同一个字节码文件 .class 在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个。

**使用 Class 对象**

Class 对象 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包括 Field、Method 和 Constructor 三个类。

可以通过 Class 对象.getXX() 获得 public 修饰的成员变量、成员方法、构造方法。getDeclaredXX() 获取所有。

**Field**

get() 和 set() 方法读取和修改值。

获取值时会存在访问权限修饰符的安全检查，可以通过 setAccessible(true) 暴力反射忽略，访问到 private。

**Method**

invoke(Object) 调用方法。

**Constructor**

newInstance() 创建新对象。

空参构造方法直接用 Class.newInstance()。

#### 框架

半成品软件，在框架上进行软件开发可以简化编码。

反射是框架设计的灵魂，将类的各个组成部分封装为其他对象。

IDEA 在运行中获取到一个对象的方法靠的是反射。

**设计一个反射框架**

不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。

1. 通过配置文件的形式，将需要创建的对象的全类名和需要执行的方法定义在配置文件中。

2. 在程序中加载读取配置文件。

3. 使用反射技术来加载类文件进内存。

4. 创建对象。

5. 执行方法。

**RTTI**

在编译时已经知道了所有的类型。使用 Class 对象。通过匿名基类的引用来发现类型信息。尽量使用多台，只在必须时使用 RTTI。

RTTI 和反射的区别：RTTI 编译器在编译时打开和检查.class 文件；对于反射，.class 文件在编译时不可获取，在运行时打开和检查.class 文件。

**RMI** 

远程方法调用，Java 序列化机制，用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上，也可以在同一个主机上。允许被远程调用的对象要通过一些标志加以标识。需要在运行时获取类的信息。

**缺点**

- 无法跨语言使用。

- Java 序列化后的码流太大，无论是网络传输还是持久化到磁盘，都会导致额外的资源占用。

- 序列化性能差，资源占用率高（主要是 CPU 资源占用高）。



## 7.异常

Throwable 可以用来表示任何可以作为异常抛出的类，分为 Error 和 Exception。

异常只能用于错误处理，不应该用来控制程序流程。

#### Error 

用来表示 JVM 无法处理的错误。

这些错误是不可查的，在应用程序的控制和处理能力之外，这些错误发生时，JVM 一般会选择线程终止。

#### Exception 

分为非运行时异常（需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复）和运行时异常。

**运行时异常 RuntimeException**

可以把异常对象（内容，原因，位置）交给虚拟机来处理，中断程序，并在控制台打印错误信息。

**常见 RuntimeException**

空指针异常 NullPointerException，类型强制转换异常 ClassCastException，非法参数异常 IllegalArgumentException，算术运算异常 Arithmetic Exception，索引越界异常 IndexOutOfBoundsException，迭代器无元素异常 NoSuchElementException。

#### 异常处理

**try 块**

可能产生异常的代码。其后可接零个或多个 catch 块（异常有父子关系则子类必须写在上面），如果没有 catch 块，则必须跟一个 finally 块。

**catch 块**

处理捕获到的异常。可以重新抛出异常。一般会把异常的信息记录到日志中。只有产生了异常才会执行 catch 里的代码。

不要在循环中使用 try...catch...，应该把其放在最外层。

**finally 块**

无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。

当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。

**try-with-resources**

面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是 try-catch-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用，适合多个资源需要关闭的场景。

Java7 之后。

**在以下 4 种特殊情况下，finally 块不会被执行**

- 在 finally 语句块第一行发生了异常。因为在其他行，finally 块还是会得到执行。

- 在前面的代码中用了 System.exit(int) 已退出程序。若该语句在异常语句之后，finally 会执行。

- 程序所在的线程死亡。

- 关闭 CPU。

**throw 和 throws 的区别**

- throw 用于方法内部，throws 用于方法声明上。

- throw 后跟异常对象，throws 后跟异常类型。

- throw 后只能跟一个异常对象，throws 后可以一次声明多种异常类型。

- throw 抛出指定类型的异常对象，就必须处理这个对象。用 try...catch 或者 throws（没有处理就会和运行异常一样）。

**打印异常的方法**

内容由少变多：getMessage()、toString()、printStackTrace()。

**父类异常**

父类方法没有抛出异常，子类重写该方法也不可以抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。

所有异常类都会有一个带异常信息的构造方法，方法内部 super() 让父类处理这个异常信息。

调用声明了异常的方法，就必须处理这个声明的异常。

**异常对性能不利**

抛出异常首先要创建一个新的对象，Throwable 接口的构造函数调用名为 fillInStackTrace() 的本地同步方法，fillInStackTrace() 方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，JVM 就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。



## 8.泛型

使用参数化类型，使代码可以应用于多种类型。不能使用基本类型用作类型参数。

使用泛型，可以在编译期防止将错误类型的对象放置到容器中。但是只能存储泛型类型的元素。

JDK1.7 开始 =new ArrayList<E>() 的 E 可以省略。

类型擦除：在泛型代码的内部，无法获得任何有关泛型参数类型的信息。

元组：仅一次方法调用就能返回多个对象。通过创建一个对象，来持有想要返回的多个对象。

通配符：被限制为单一边界。<?>，只能接受数据，不能往集合中存储数据。只能用在方法的参数。

未知的数据类型 E，在创建集合对象的时候，会确定泛型的数据类型。Class<E>。

泛型方法

含有泛型的接口可以指定接口的类型，public final class Scanner implements Iterator<String>{public String next(){}}。

泛型上限：<? extends E>，使用泛型只能是 E 类型或其子类。

泛型下限：<? super E>

isEmpty() 和 size() 针对泛型集合。



## 9.注解

Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。

注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

Annontation 是 Java5 开始引入的新特征，包含在 java.lang.annotation 包中。

注解也可以没有定义成员，不过这样注解就没啥用了。

注解是不能继承的。

#### 注解的用处

- 最常见的生成文档 javadoc。

- 对代码进行分析，跟踪代码依赖性，实现替代配置文件功能。使用反射。

- 在编译时进行格式检查。

**常见注解**

@Override：重载。

@Deprecated：过时，不被推荐使用。

@SuppressWarnings：抑制警告。

#### 元注解

专门注解其他的注解。

@Documented：注解是否将包含在 javadoc 中。

@Retention：注解保留到的阶段。一般为 RetentionPolicy.RUNTIME。

@Target：注解作用的位置。

@Inherited：是否允许子类继承该注解。

#### 自定义注解格式

元注解

public @interface 注解名称{

​		属性列表;

}

编译后反编译变成 public interface 注解名称 extends java.lang.annotation.Annotation{}

**编写规则**

所有注解自动继承 Annotation 接口，并且不能再去继承别的类或是接口。

参数成员只能用 public 或 default 这两个访问权修饰。

参数成员只能用基本数据类型、String、Enum、Class、annotations 等数据类型，以及这些类型的数组。

如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。

如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可。

数组赋值时，值使用 {} 包裹。如果数组中只有一个值，则 {} 可以省略。

#### 注解的原理

注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。

而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 $Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 invoke()，该方法会从 memberValues 这个 Map 中索引出对应的值，而 memberValues 的来源是 Java 常量池。

要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法。

获取注解属性值，注解替换配置文件。



## 10.Java SE 8 新特性

#### lambda 表达式和函数式接口

()->{}。

**省略规则**

小括号里的参数类型可以省略。

如果小括号里只有一个参数则小括号可以省略。

如果大括号里只有一条语句则大括号可以省略。



有且只有一个抽象方法。

特点是延迟加载，如果最后一步不进行，则前置的几步也不会进行。

**方法引用**

对 lambda 表达式的简化，:: 引用运算符。

函数式编程更加强调程序执行的结果而非执行的过程。

**Optional**

Optional 是一个简单的容器，其值可能是 null 或者不是 null。在 Java 8 之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在 Java 8 中，你应该返回 Optional 而不是 null。用于防止 NullPointerException。

#### Stream

能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回 Stream 本身，这样你就可以将多个操作依次串起来（Pipelining，有延迟执行和短路的优化）。Stream 的创建需要指定一个数据源。Stream 的操作可以串行执行或者并行执行（Parallel Streams）。

Stream 操作

Filter(过滤)：过滤通过一个 Predicate 接口来过滤并只保留符合条件的元素，该操作属于中间操作。

Sorted(排序)：如果你不指定一个自定义的 Comparator 则会使用默认排序，该操作属于中间操作。创建了一个排列好后的 Stream，而不会影响原有的数据源。

Map(映射)：中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。

Match(匹配)：Stream 提供了多种匹配操作，允许检测指定的 Predicate 是否匹配整个 Stream。所有的匹配操作都是最终操作，并返回一个 boolean 类型的值。

Count(计数)：计数是一个最终操作，返回 Stream 中元素的个数，返回值类型是 long。

Reduce(规约)：这是一个最终操作，允许通过指定的函数来讲 Stream 中的多个元素规约为一个元素，规约后的结果是通过 Optional 接口表示的。

Stream 不会对数据进行存储，而是按需计算。Stream 属于管道流，只能被消费一次，流到下一个 Stream 时，上一个 Stream 将会关闭。

内部迭代 forEach()。

中间操作（延迟方法）。

#### 接口的默认方法

使用 default 关键字向接口添加非抽象方法实现。可以在不影响子类的情况下在接口添加默认方法，子类会继承到这个默认方法。接口也可以定义静态方法（也是 Java 8 开始的），可以直接用接口名调用。实现类对象是不可以调用接口的默认方法。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错（和普通的抽象方法不一样）。如果父类的方法和接口的默认方法冲突，则会优先选择父类的方法。            

**Java SE 7**

1. Strings in Switch Statement
2. Type Inference for Generic Instance Creation。List< Integer> list=new ArrayList<>();  //右侧的 <> 内部可以不写。
3. Multiple Exception Handling
4. Support for Dynamic Languages
5. Try with Resources
6. Java nio Package



## 11.容器

容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对的映射表。

容器不能持有基本类型，需要使用自动包装。

集合可以装不同类型的对象。集合不加泛型时默认为 Object 类的对象，但是不安全，会引发 ClassCastException。

集合类没有实现 Cloneable 和 Serializable 接口，应该由集合类的具体实现来决定如何被克隆或者是序列化。

有序：存和取元素的顺序一致。

#### TreeSet

基于红黑树实现，有序，支持范围查找，查找的时间复杂度为 O(logN)。

#### HashSet

基于 HashMap 实现，无序，支持快速查找，查找的时间复杂度为 O(1)。

封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。如果向 HashSet 中添加一个已经存在的元素，新添加的集合元素不会覆盖已有的集合元素。

除了 clone()、writeObject()、readObject() 是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。

**LinkedHashSet**

内部使用双向链表维护元素的插入顺序，有序，且具有 HashSet 的查找效率。

**List**

有序，有索引（可以普通 for 循环），允许重复。

实现了 RandomAccess 接口的 list，优先选择普通 for 循环，其次 foreach。允许更改 list 的行为，提供良好的性能。

未实现 RandomAccess 接口的 list，优先选择 foreach（底层通过 Iterator 实现）。大 size 的数据，千万不要使用普通 for 循环。

#### ArrayList

基于动态数组实现，支持快速随机访问。实现了 RandomAccess、Cloneable 和 Serializable 接口。默认大小为 10。

以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。

对于 ArrayList 来说，直接打印 list 得到的不是地址值，因为重写了 toString()。

ArrayList 的内部类 Iterator 和 ListIterator，区别：ListIterator 在 Iterator 的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是 Iterator 不能实现的。

**扩容（源码分析）**

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容。

newCapacity = oldCapacity + (oldCapacity >> 1);  //新容量的大小为旧容量的 1.5 倍

扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

多线程扩容

**删除元素**

需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。

**序列化**

ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。

ArrayList 实现了序列化 writeObject() 和反序列化 readObject() 来控制只序列化数组中有元素填充那部分内容。

序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。

反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。         

**Fail-Fast**

modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。

在进行序列化或者迭代等操作时，若操作前后 modCount 发生变化，会抛出 ConcurrentModificationException。

java.util 包下面的所有的集合类都是快速失败 fail-fast 的。java.util.concurrent 包下面的所有的类都是安全失败 fail-safe 的。

**Array 与 ArrayList 的比较**

- Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。

- Array 大小是固定的，ArrayList 的大小是动态变化的。

- 基于效率和类型检查的考虑，应该尽可能使用 Array，无法确定数组大小时才使用 ArrayList。 

**Vector 与 ArrayList 的比较**

- Vector 在 JDK1.2 之前，和 ArrayList 类似，但它是线程安全的，使用了 synchronized 进行同步，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制。

- Vector 每次扩容默认请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。

**代替方案**

- 可以使用 Collections.synchronizedList()，得到一个线程安全的 ArrayList。

- 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。

**CopyOnWriteArrayList**

**读写分离**

写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。

写操作需要加锁，防止并发写入时导致写入数据丢失。

写操作结束之后需要把原始数组指向新的复制数组。

**适用场景**

CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。

**缺陷**

- 内存占用：在写操作时需要复制一个新的数组，内存占用为原来的两倍左右。

- 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。

因此 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。

#### LinkedList

基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。实现了 Deque 接口。还可以用作栈、队列和双向队列。

JDK1.6 之前为循环链表，JDK1.7 取消了循环。

包含大量操作首尾元素的方法。

**使 LinkedList 变成线程安全的**

List list=Collections.synchronizedList(new LinkedList(...));

或者 BlockingQueue 阻塞队列和 ConcurrentLinkedQueue 非阻塞队列。

**LinkedList 与 ArrayList 的比较**

- ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。

- ArrayList 支持随机访问，插入删除需要移动大量元素，查询快增删慢。LinkedList 不支持随机访问，插入删除只需要改变指针，查询慢增删快。

- ArrayList 结尾会预留一定的容量空间花费空间，LinkedList 每一个元素都需要存放直接后继和直接前驱以及数据花费空间。

**Queue**

**PriorityQueue**

基于堆结构实现，默认最小堆。

调用 remove 方法，总会获得当前优先级队列中的最小元素。

PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(logN)。

JDK 1.5 开始。

**Stack**

**Map**

键不能重复，一个键只能映射一个值。

#### TreeMap

基于红黑树实现。由 Comparable 或 Comparator 排序。

#### 红黑树

**特征**

- 每个节点或者是黑色，或者是红色。
- 根节点是黑色。
- 每个叶子节点 NIL 是黑色。 
- 如果一个节点是红色的，则它的子节点必须是黑色的。从每个叶子到根的所有路径上不能有两个连续的红色节点。
- 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
- 根节点到叶节点的最长路径的长度不超过最短路径的两倍。

查找、插入和删除时间复杂度 O(logn)。

插入和删除时自平衡，变色和旋转。

红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

#### HashMap

基于哈希表实现，查询快，无序。

查找、插入和删除时间复杂度 O(1)。

Entry<K,V>[] table，数组中的每个位置被当成一个桶，一个桶存放一个链表 Entry（存储着键值对）。

**put 操作**

1. 根据 key 的值 hash()。
2. 确定桶下标 indexFor()。
3. 存在键为 key 的键值对，更新这个键值对的值为 value。
4. 不存在，则插入新键值对。链表的插入为头插法。

同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。

**键为 null**

HashMap 只允许一个 key 为 null，允许多个 value 为 null。

因为无法调用 null 的 hashCode()，也就无法确定该键值对的桶下标，HashMap 强制指定使用第 0 个桶存放键为 null 的键值对。

**扩容 resize**

为了让查找的成本降低，table 长度要尽可能大。

HashMap 采用动态扩容来根据当前的键值对数量来调整 table 长度，使得空间效率和时间效率都能得到保证。

**参数**

默认的 table 容量 capacity 是 16。

默认的装载因子 loadFactor 是 0.75，loadFactor 太大导致查找元素效率低，太小导致数组的利用率低。

默认的键值对数量 size 的临界值 threshold = capacity * loadFactor = 12。

**扩容的触发**

当 Entry 的数量超过 threshold 且新建的 Entry 刚好落在一个非空的 table 上，触发扩容 capacity * 2，并采用 transfer() 将原有的 Entry 对象插入到新数组中（会进行 rehash() 重新计算桶下标），这一步是很费时的。

并发下的 rehash() 会造成元素之间会形成一个循环链表，JDK1.8 后解决了这个问题。

**为什么 capacity 是 2 的幂次方？**

- 通过限制 length 是 2 的幂次方，确定桶下标中 h&(length-1) 和 h%length 结果是一致的。将取模操作转换成了位运算，更加高效，极大降低操作复杂度。在 rehash() 中也很有作用。

- 通过右移可以使低位的数据尽量的不同，从而使 hash 值的均匀分布减少碰撞。

**红黑树**

从 JDK1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树，为了提高查询速度。

**原因**

hashCode、概率

4 以后都是 logn 小于 n/2，但是到了 8 之后这两者才相差 1，才有链表转换为红黑树的必要。

**到 6 红黑树转换为链表**

中间有个差值 7 可以防止链表和树之间频繁的转换。

**Hashtable**

和 HashMap 类似，线程安全，因此也效率低。

**Hashtable 与 HashMap 的区别**

- Hashtable 使用 synchronized 来进行同步。
- HashMap 可以插入键为 null 的 Entry。
- HashMap 的迭代器是 fail-fast 迭代器。
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
- 初始容量和扩容不同。

Hashtable 是遗留类，不应该使用，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高。

#### ConcurrentHashMap

ConcurrentHashMap 引入了分段锁，线程安全，效率更高。

**JDK 1.7 分段锁 Segment**

继承自 ReentrantLock。将数据分成一段一段的存储，然后给每一段数据配一把锁，每个分段锁维护着几个桶 HashEntry（volatile 修饰）。实现并发更新操作。

多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高，并发度与 Segment 数量相等。默认创建 16 个 Segment。

ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。put 需要加锁。

**size 操作**

每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。

在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。

ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

**JDK 1.8 取消了分段锁**

使用了 CAS 操作来支持更高的并发度。

在 CAS 操作失败时使用内置锁 synchronized，只锁定当前链表或红黑二叉树的首节点，只要 hash 不冲突，就不会产生并发。

也在链表过长时会转换为红黑树。

**为什么 HashMap 支持 key 或者 value 为 null，而 HashTable 和 ConcurrentHashmap 不支持？**

Hashtable 和 ConcurrentHashmap 都是支持并发的，这样会有一个问题，当你通过 get(k) 获取对应的 value 时，如果获取到的是 null 时，你无法判断，它是 put(k,v) 的时候 value 为 null，还是这个 key 从来没有做过映射。

HashMap 是非并发的，可以通过 contains(key) 来做这个判断。而支持并发的 Map 在调用 m.contains（key）和 m.get(key)，m 可能已经不同了。

**ConcurrentSkipListMap**

这是一个 Map，使用跳表的数据结构进行快速查找。

**LinkedHashMap**

有序，使用双向链表维护插入顺序或者 LRU 顺序（boolean accessOrder 决定）。

**实现的一个 LRU 缓存**

- 设定最大缓存空间 MAX_ENTRIES 为 3。
- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序。
- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。

**WeakHashMap**

Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。

**缓存**

主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。

Tomcat 中的 ConcurrentCache 采取的是分代缓存。

**IdentityHashMap**

使用 == 代替 equals 对键进行比较。

#### 容器中的设计模式

**迭代器模式**

获取集合元素。

JDK1.2 开始，Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。

hasNext() 判断，next() 取出下个元素（Object 类）。

JDK1.5 之后使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。

不要在 foreach 循环里进行集合类的 remove/add 操作，可以调用迭代器的 remove/add 方法。并发操作需要对 Iterator 对象加锁。

Java 中的 Iterator 可用来遍历 Set 和 List 集合，并且只能单向移动。ListIterator 实现了 Iterator 接口，既可以前向也可以后向遍历，还可以添加对象和修改对象。

迭代器的泛型和集合泛型一致。

Iterator 指针一开始在 -1。

**Enumeration 接口和 Iterator 接口的区别**

- Enumeration 速度是 Iterator 的 2 倍，同时占用更少的内存。

- 但是，Iterator 远远比 Enumeration 安全，因为其他线程不能够修改正在被 Iterator 遍历的集合里面的对象。

- 同时，Iterator 允许调用者删除底层集合里面的元素，这对 Enumeration 来说是不可能的。

**适配器模式**

Arrays.asList() 把数组类型转换为 List 类型，底层其实还是数组，不能使用其修改集合相关的方法。

asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。

```java
Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
或者
List list = Arrays.asList(1, 2, 3);
```



## 12.I/O

装饰者模式。

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```

也可以使用匿名对象，只使用一次，作为方法的参数或返回值：

```java
BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(filePath));
```

使用带缓冲 Buffered 的输入输出流进行 I/O 操作，可以极大地提升 I/O 效率。

Properties 是唯一和 IO 流相结合的集合。Properties extends Hashtable，key 和 value 默认都是 String。

**进程中的 IO 调用过程**

1. 进程向操作系统请求数据。

2. 操作系统把外部数据加载到内核的缓冲区中。

3. 操作系统把内核的缓冲区拷贝到进程的缓冲区。

4. 进程获得数据完成自己的功能。

#### 磁盘操作 File

File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。

从 Java7 开始，可以使用 Paths 和 Files 代替 File。

#### **字节操作**

InputStream 和 OutputStream。

不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。

PrintStream 打印流，继承自 OutputStream，永远不会抛出 IOException。

System.setOut(new PrintStream()) 可以改变输出语句的目的地。

#### **字符操作**

Reader 和 Writer。

在程序中操作的通常是字符形式的数据。

**字节流与字符流的转化**

InputStreamReader 实现从字节流解码成字符流。可以指定编码表。

OutputStreamWriter 实现字符流编码成为字节流。

write() 先把数据写到内存缓冲区（字符转换为字节），flush() 再把内存缓冲区的数据刷新到文件中。释放资源 close() 前也会隐含执行 flush()。

**既然有了字节流，为什么还要有字符流?**

I/O 流操作分为字节流操作和字符流操作。

字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。

所以，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。

如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

**编码与解码**

编码就是把字符转换为字节，而解码是把字节重新组合成字符。

如果编码和解码过程使用不同的编码方式那么就出现了乱码。

**编码方式 charset**

ASCII：1 个字节。

GBK：中文字符占 2 个字节，英文字符占 1 个字节。

UTF-8：中文字符占 3 个字节，英文字符占 1 个字节。FileReader 只能使用默认的编码 UTF-8。

UTF-16be：中文字符和英文字符都占 2 个字节。大端 Big Endian，大端序最高位字节存储在最低的内存地址处。

**char 与 String 的编码**

Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。

String 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be，与平台有关，一般为 UTF-8。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。

**获取键盘输入**

通过 Scanner 或 BufferedReader。

#### 对象操作 Serializable

序列化就是将一个对象转换成字节序列（流），方便存储和传输。

- 序列化：ObjectOutputStream.writeObject()。不能对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。

- 反序列化：ObjectInputStream.readObject()。还需要存在类对应的 .class 文件，否则会抛出 ClassNotFoundException。也不能修改源代码使生成 UID 不同的 .class 文件，否则会抛出 InvalidClassException。不通过构造函数创建对象。

序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。

transient 关键字可以使修饰的变量不被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。

#### *网络操作 Socket

基于 BIO。

- InetAddress：用于表示网络上的硬件资源，即 IP 地址。

- URL：可以直接从 URL 中读取字节流数据。

- Sockets：使用 TCP 协议实现网络通信。服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。
  - Socket：客户端类
  - ServerSocket：服务器类

- Datagram：使用 UDP 协议实现网络通信。

  - DatagramSocket：通信类

  - DatagramPacket：数据包类

***<u>Socket 实现网络数据的接受</u>***

#### NIO

新的输入输出。

JDK 1.4 中引入 java.nio 包，面向块，基于通道&缓冲区&选择器，高速，同步非阻塞。

I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了。

JDK 1.5 使用 epoll 替代了传统的 select/poll，极大地提升了 NIO 通信的性能。

**NIO 对 BIO 的改进**

非阻塞：只是有效请求（确实需要进行 I/O 处理）时，才会使用一个线程去处理，避免了 BIO 模型下大量线程处于阻塞等待状态的情景。

**流与块**

I/O 与 NIO <u>最重要</u>的区别是数据打包和传输的方式：I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。

- 面向流的 I/O 一次处理一个字节数据，为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。然而面向流的 I/O 通常相当慢。可以将数据直接读写到 Stream 对象中。

- 面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。



NIO 核心组件：Channel，Buffer 和 Selector。

**通道 Channel**

是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。

通道与流的不同之处在于，流只能在一个方向上移动（一个流必须是 InputStream 或者 OutputStream 的子类）。而通道是双向的，可以用于读、写或者同时用于读写。

**通道类型**

- FileChannel：从文件中读写数据。

- DatagramChannel：通过 UDP 读写网络中数据。

- SocketChannel：通过 TCP 读写网络中数据。与传统 BIO 模型中的 Socket 相对应。

- ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。

  **阻塞和非阻塞模式**

  SocketChannel 和 ServerSocketChannel 这两种通道都支持阻塞和非阻塞两种模式。

  阻塞模式使用非常简单，但是性能和可靠性都不好。低负载、低并发的应用程序可以选择同步阻塞 I/O 以降低编程复杂度。但是对于高负载、高并发的网络应用，需要使用 NIO 的非阻塞模式进行开发。

**缓冲区 Buffer**

发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。

因为 Buffer，通道可以异步地读写。

缓冲区实质上是一个数组，提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

缓冲区类型和状态变量。

**选择器 Selector**

NIO 实现了 IO 多路复用中的 Reactor 模型：一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时（单线程中从通道读取数据到 buffer，同时可以继续做别的事情，当数据读取到 buffer 中后，线程再继续处理数据），就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行，让线程资源得到充分利用。

因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，提高了并发量并且减少资源消耗在线程的上下文切换中，对于 IO 密集型的应用具有很好地性能。

应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。

**Selection Key**

当我们将 Channel 注册到 Selector 中的时候，会返回一个 Selection Key 对象，Selection Key 则表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。通过 Selection Key 我们可以获取哪些 IO 事件已经就绪了，并且可以通过其获取 Channel 并对其进行操作。

**过程**

1. 将 Channel 注册到 Selector 中。
2. 调用 Selector 的 select()，这个方法会阻塞。
3. 到注册在 Selector 中的某个 Channel 有新的 TCP 连接或者可读写事件的话，这个 Channel 就会处于就绪状态，会被 Selector 轮询出来。
4. 然后通过 Selection Key 可以获取就绪 Channel 的集合，进行后续的 I/O 操作。

**内存映射文件 I/O**

一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。

向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。

**BIO **

同步阻塞 I/O。

数据的读取写入必须阻塞在一个线程内等待其完成。做完一件事再去做另一件事。

接收到客户端连接之后，为其创建一个新的线程处理请求消息。处理完成之后，返回应答消息给客户端，线程销毁。

**线程池改善**

采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，客户端个数可以远远大于线程池最大线程数。

在活动连接数不是特别高时，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。

**缺点**

服务端的线程个数和并发访问数成线性正比，并发访问量增加后，会创建大量线程。线程是 JVM 非常宝贵的系统资源，当线程数膨胀之后，系统的性能急剧下降，可能会发生句柄溢出、线程堆栈溢出等问题，并导致服务器最终宕机。

并且如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态而无法及时释放，会导致系统性能急剧下降，严重的甚至会导致虚拟机无法创建新的线程。

**AIO**

异步非阻塞 IO。NIO 2，在 Java 7 中引入了 NIO 的改进版。

AIO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

在 Unix 系统下，采用了 epoll IO 模型。Windows 下是使用了 IOCP 模型。



## 13.Servlet

运行在服务器端的 Java 程序。在 Java web 中，Servlet 主要负责接收用户请求 HttpServletRequest，在 doGet() 和 doPost() 中做相应的处理，并将回应 HttpServletResponse 反馈给用户。可以通过 HttpServletRequest 和 HttpServletResponse 获得请求响应的数据。

Servlet 不能够自行创建并执行，它是在 web 容器中运行的。通常一个 Servlet 会关联一个或多个 JSP 页面。

Servlet 可以设置初始化参数，供 Servlet 内部使用。

Servlet 需要在 web.xml 中配置，MyEclipse 中创建 Servlet 会自动配置。Servlet 3.0 支持注解配置，配合 JDK1.6 开始，无需 web.xml。

**Tomcat 乱码**

Tomcat8 解决了 get 方式乱码的问题，post 方式乱码需要设置 request.setCharacterEncoding("utf-8")。

**相对路径与绝对路径**

相对路径 ../ 不能确定唯一资源，绝对路径 / 可以确定唯一资源。

给浏览器使用需要加虚拟目录 request.getContextPath()，给服务器使用不需要加虚拟目录。

**自动刷新 Refresh**

自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet 中通过 HttpServletResponse 对象设置 Header 属性实现自动刷新。

#### 生命周期

**init()**

Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init() 方法进行 Servlet 的初始化。

指定 Servlet 的创建时机：< load-on-startup>。

**service()**

请求到达时调用 Servlet 的 service() 方法，service() 方法会根据需要调用与请求对应的 doGet 或 doPost 等方法。

**destroy()**

当服务器正常关闭或项目被卸载时服务器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy() 方法。



init 方法和 destroy 方法只会执行一次。一个 Servlet 类只会有一个实例，单例。

service 方法客户端每次请求 Servlet 都会执行。

Servlet 中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入 init 方法中，销毁资源的代码放入 destroy 方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。

#### 线程安全问题

一个 Servlet 可以设置多个 URL 访问，多个用户可以同时访问。Servlet 不是线程安全，多线程并发的读写会导致数据不同步的问题。

**解决办法**

尽量不要定义成员变量，而是要把变量分别定义在 doGet() 和 doPost() 方法内。

如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此 Servlet 里的只读属性最好定义为 final 类型的。

可以让自定义的 Servlet 实现 SingleThreadModel 标识接口，实现单线程模式。如果将 Servlet 设置成单线程工作模式，会导致每个请求创建一个 Servlet 实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。

虽然使用 synchronized(name){} 语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。

#### 执行原理

1. 当服务器接受到浏览器的请求后，会解析请求 URL 路径，获取访问的 Servlet 的资源路径。
2. 查找 web.xml 文件，是否有对应的 < url-pattern> 标签体内容。
3. 如果有，则在找到对应的 < servlet-class> 全类名。
4. Tomcat 会将字节码文件加载进内存，并且创建其对象。
5. 调用其方法。

#### JSP

JSP 本质上是 Servlet 的一种简易形式，JSP 会被服务器处理成一个类似于 Servlet 的 Java 程序，可以简化页面内容的生成。

**JSP 和 Servlet 的不同点**

- JSP 是 Java 和 HTML 可以组合成一个扩展名为 .jsp 的文件。而 Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 分离开来。

- JSP 侧重于视图，Servlet 更侧重于控制逻辑。在 MVC 架构模式中，JSP 适合充当 view 而 Servlet 适合充当控制器 controller。

#### Servlet 相比 CGI 的优点

- 只需要启动一个操作系统进程以及加载一个 JVM，大大降低了系统的开销。

- 如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销。

- 所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。

- Servlet 能直接和 Web 服务器交互，还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。

#### 转发和重定向的区别

- 转发 forward 通过 RequestDispatcher 对象的 forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher() 方法获得。

- 重定向 redirect 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。

- 转发是服务器行为，重定向是客户端行为。

- 地址栏显示：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。

- 数据共享：forward 转发页面和转发到的页面可以共享 request 里面的数据。redirect 不能共享数据。

- 运用地方：forward 一般用于用户登陆的时候，根据角色转发到相应的模块。redirect 一般用于用户注销登陆时返回主页面和跳转到其它的网站等。

- 效率：forward 高，redirect 低。

- 转发只能访问当前服务器下的资源，重定向可以访问其他站点（服务器）的资源。

- 转发是一次请求，重定向是两次请求。

#### Filter

当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能，如登录验证、统一编码处理、敏感字符过滤等。

默认直接请求才会过滤，转发不会过滤，可以设置 DispatcherTypes 属性改变。

实现了责任链模式。执行顺序。

Filter->Servlet，Servlet 包含在 SpringMVC 中，称为 DispatcherServlet。SpringMVC 的 Interceptor 也能起过滤的作用，DispatcherServlet->Interceptor->Controller。

#### Listener



## 14.其他

**JRE 和 JDK**

JRE 是 Java 运行时环境，包含了 JVM 和 Java 基础类库。

JDK 是 Java 开发工具包，包含了 JRE，同时还包含了编译器 javac 和调试器等工具。

**Oracle JDK 和 OpenJDK**

Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的。而 OpenJDK 是一个参考模型并且是完全开源的。

Oracle JDK 比 OpenJDK 更稳定。

Oracle JDK 与 OpenJDK 相比提供了更好的性能。

**SimpleDateFormat** 

一个以与语言环境有关的方式来格式化和解析日期的具体类（DateFormat 类是一个抽象类），它允许进行格式化 format（日期→文本）、解析 parse（文本→日期）和规范化。

new SimpleDateFormat（构造方法指定模式），SimpleDateFormat.parse 当字符串和构造方法中的模式不一样时，会抛 ParseException。

Date 类过时，被 Calendar 代替。Calendar 是一个抽象类，其中静态方法 getInstance() 返回 Calendar 子类对象。

**SimpleDateFormat 为什么不是线程安全的？**

在 SimpleDateFormat 转换日期是通过 Calendar 对象来操作的，SimpleDateFormat 继承 DateFormat 类，DateFormat 类中维护一个 Calendar 对象，Calendar 实例被用来进行日期-时间计算，既被用于 format 方法也被用于 parse 方法。

在 parse 方法的最后，会调用 CalendarBuilder 的 establish 方法，入参就是 SimpleDateFormat 维护的 Calendar 实例，在 establish 方法中会调用 calendar 的 clear 方法。

SimpleDateFormat 维护的用于 format 和 parse 方法计算日期-时间的 calendar 被清空了，如果此时线程 A 将 calendar 清空且没有设置新值，线程 B 也进入 parse 方法用到了 SimpleDateFormat 对象中的 calendar 对象，此时就会产生线程安全问题。

**解决方法**

每一个使用 SimpleDateFormat 对象进行日期-时间进行 format 和 parse 方法的时候就创建一个新的 SimpleDateFormat 对象，用完就销毁。此时就可以使用 ThreadLocal 将 SimpleDateFormat 绑定到线程上。

#### 递归优化

递归调用需要后调用的方法先返回，因此使用栈来存储递归调用的信息。

递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分。

**StackOverflowError**

每个线程拥有的栈空间是有限的，如果递归调用太深的话，就会导致栈空间不足，从而触发 StackOverflowError。

**递归转为非递归**

用语言内置的栈来模拟线程栈，它位于堆中，不会出现 StackOverflowError。

也可以转换为迭代，采用循环。此时不再需要入栈出栈操作，这将极大地提高运行效率。

**尾递归**

递归在最后一步调用自身，且这一步没有其他操作。

在进入新的递归函数时，尾递归不再需要使用栈帧保存数据，允许抛弃旧的栈帧，那么只需要保存一个栈帧即可，能够有效解决 StackOverflowError。

Java 无法对尾递归进行优化，也就是说不会抛弃不需要的栈帧，还是会出现 StackOverflowError。

**为什么用递归比用栈差？**

- 递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。

- 递归会产生 StackOverflowError。