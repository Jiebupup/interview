1.简介
HTTP 超文本传输协议，是一个客户端和服务端之间请求和应答的标准，通常使用 TCP 协议，服务器上默认端口为 80。
HTTPS 通过计算机网络进行安全通信的传输协议。
RFC 规范是记录互联网规范、协议、过程等的标准文件。
URI(Uniform Resource Identifier) 是统一资源标志符，URL(Uniform Resource Location) 是统一资源定位符。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

2.HTTP 方法
GET：获取资源
POST：传输数据
PUT：上传文件。不带验证机制，任何人都可以上传文件，因此存在安全性问题。
DELETE：与 PUT 对应
HEAD：获取报文首部，主要用于确认 URL 的有效性以及资源更新的日期时间等。
PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源。
OPTIONS：查询指定的 URL 能够支持的方法。
CONNECT：使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
TRACE：追踪路径，服务器会将通信路径返回给客户端。

GET 和 POST 的区别：
GET 的参数是以查询字符串出现在 URL 中，并且两者使用"?"连接，而各个变量之间使用"&"连接。而 POST 的参数存储在 Request body 中（可以通过一些抓包工具（Fiddler）查看）。             
GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
GET 只接受 ASCII 字符类型的参数，而 POST 没有限制。
GET 请求的数据会暴露在地址栏中，保留在浏览器历史记录里，而 POST 请求则不会。GET 不安全。
GET 传输的数据要受到 URL 长度限制（最大长度是 2048 个字符），而 POST 可以传输大量的数据，上传文件通常要使用 POST 方式。
GET 方法是安全的，而 POST 却不是。安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。POST 的目的是传送实体主体内容，服务器可能把这个数据存储到数据库中，状态也就发生了改变。安全的方法 GET、HEAD、OPTIONS。不安全的方法 POST、PUT、DELETE。
GET 是幂等的，连续调用多次，客户端接收到的结果都是一样的。POST 不是，如果调用多次，就会增加多行记录。幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。幂等方法不应该具有副作用。所有的安全方法也都是幂等的。
GET 可缓存（会被浏览器主动缓存），POST 不可缓存（除非手动设置）。
在使用 XMLHttpRequest（为客户端提供了在客户端和服务器之间传输数据的功能，通过 URL 来获取数据，网页只更新一部分页面，在 AJAX 中被大量使用）的 GET 方法时浏览器将会把 Header 和 Data 一起发送。 而 POST 方法，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐。

GET 在浏览器回退时是无害的，POST 会再次提交请求。
GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
GET 效率比 POST 高。
GET 方式提交表单的典型应用是搜索引擎。GET 方式就是被设计为查询用的。
  
3.HTTP 状态码
1XX 信息：接收的请求正在处理。
100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

2XX 成功：请求正常处理完毕。
200 OK
204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

3XX 重定向：需要进行附加操作以完成请求。
301 Moved Permanently ：永久性重定向
302 Found ：临时性重定向
303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
（虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。）
304 Not Modified ：不满足请求报文首部包含的一些条件。
307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

4XX 客户端错误：服务器无法处理请求。
400 Bad Request ：请求报文中存在语法错误。
401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
403 Forbidden ：请求被拒绝。
404 Not Found

5XX 服务器错误：服务器处理请求出错。
500 Internal Server Error ：服务器正在执行请求时发生错误。
503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

4.HTTP 请求响应报文结构
HTTP 请求报文由请求行（request line）、请求头部（header）、空行（blank line）和请求正文（request-body）4 个部分组成。
请求行由请求方法、URL 和 HTTP 协议版本三部分组成，它们用空格分隔。

HTTP 响应报文也由四个部分组成，分别是：状态行（status-line）、响应头部（headers）、空行（blank line）和响应正文（response-body）。
状态行由 HTTP 协议版本、状态码、状态码描述三部分组成。

典型请求头部和响应头部：
Accept：用户代理可处理的媒体类型。
Host：请求资源所在服务器。
User-Agent：HTTP 客户端程序的信息。

Location：令客户端重定向至指定 URI
Server：HTTP 服务器的安装信息

5.应用
短连接与长连接：
长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。
从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；
在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。可以在服务器软件（如 Apache）中设定 Keep-Alive 的保持时间。

流水线：是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

Cookie
HTTP 协议是无状态的（协议对于事务处理没有记忆能力，不对请求和响应之间的通信状态进行保存），主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。
Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，会带来额外的性能开销。
Cookie 曾一度用于客户端数据的存储，但渐渐被淘汰，新的浏览器 API 已经允许开发者直接将数据存储到本地。
一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可 (为了安全考虑，重新登录一般要将 Token 重写)。

用途：会话状态管理，个性化设置，浏览器行为跟踪。

创建过程：服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。
Set-Cookie 首部字段属性：
Expires：指定游览器可发送 Cookie 的有效期。
Path：定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。
Domain：指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。
Secure：标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。
HttpOnly：标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。在一定程度上避免跨站脚本攻击 XSS 攻击。

分类：
会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

Session 将用户信息存储在服务器端，存储在服务器端的信息更加安全。
Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。
服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中。客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID。
典型的场景是购物车：要添加商品到购物车的时候，系统不知道是哪个用户操作的，服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

可以通过 Session 来统计网站的用户在线数。

分布式 Session：用户的 Session 信息要分散在各个服务器中。可以用 Spring Session + Redis 实现。
Sticky Session：需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。
缺点：当服务器宕机时，将丢失该服务器上的所有 Session。

Session Replication：在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。
缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。

Session Server：使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。
优点：为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。
缺点:需要去实现存取 Session 的代码。如 Session 集中服务器有问题，会影响应用。 

浏览器禁用 Cookie：使用 Session 和 URL 重写
此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术（把 session id 直接附加在 URL 路径的后面），将 Session ID 作为 URL 的参数进行传递。服务器能够解析重写后的 URL 获取 Session ID。
隐藏的表单域：<input type="hidden" name ="session" value="..."/>，所有页面必须是表单提交之后的结果。

共同之处：Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式。
Cookie 与 Session 比较：
Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session。 
Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密。Cookie 更容易被伪造。
对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。
Cookie 是需要浏览器支持的，可能被禁用。而 Session 不会。
Cookie 支持跨域名访问，Session 仅在他所在的域名内有效。

缓存过期机制：
max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。
Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 max-age 指令。在 HTTP/1.0 中，max-age 指令会被忽略掉。

Expires 和 max-age 的区别：
Expires 在 HTTP/1.0 中已经定义。Cache-Control:max-age 在 HTTP/1.1 中才有定义，为了向下兼容，仅使用 max-age 不够
Expires 指定一个绝对的过期时间（GMT 格式），这么做会导致：1) 客户端和服务器时间不同步导致 Expires 的配置出现问题 2) 很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象
max-age 指定的是从文档被访问后的存活时间，这个时间是个相对值，相对的是文档第一次被请求时服务器记录的 Request_time（请求时间）。
Expires 指定的时间可以是相对文件的最后访问时间（Atime）或者修改时间（MTime）。
Apache 中，max-age 是根据 Expires 的时间来计算出来的。

缓存验证：
状态码 304 Not Modified：不满足请求报文首部包含的一些条件。
ETag：实体标记，是资源的唯一标识。URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。
If-None-Match：比较实体标记（与 If-Match 相反）
Last-Modified：资源的最后修改日期时间
If-Modified-Since：比较资源的更新时间

可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。
Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。Last-Modified 只是记录时间，性能开销小。
如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。                          

代理：代理服务器接受客户端的请求，并且转发给其它服务器。
使用代理的主要目的：缓存、负载均衡、网络访问控制、访问日志记录
代理服务器分为正向代理和反向代理两种：用户察觉得到正向代理的存在；而反向代理一般位于内部网络中，用户察觉不到。

6.HTTPS
HTTP 有以下安全性问题：
使用明文进行通信，内容可能会被窃听；
不验证通信方的身份，通信方的身份有可能遭遇伪装；
无法证明报文的完整性，报文有可能遭篡改。

HTTPS 让 HTTP 先和 SSL 通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。
通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

加密
对称密钥加密：加密和解密使用同一密钥。
优点：运算速度快；
缺点：无法安全地将密钥传输给通信方。

非对称（公开）密钥加密：加密和解密使用不同的密钥。
公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。
非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。
优点：可以更安全地将公开密钥传输给通信发送方；
缺点：运算速度慢。

HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。

认证
通过使用证书来对通信方进行认证。数字证书认证机构 CA 是客户端与服务器双方都可信赖的第三方机构。
服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。
进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

完整性保护
SSL 提供报文摘要功能来进行完整性保护。
HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。
HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

HTTPS 的缺点：
因为需要进行加密解密等过程，因此速度会更慢；
需要支付证书授权的高额费用。

SSL/TLS：安全协议，确保互联网连接安全。TLS 是更为安全的升级版 SSL。SSL/TLS 是有状态的。
SSL/TLS 握手过程：
Client Hello：生成 Random1
Server Hello：生成 Random2，这两个随机数会在后续生成对称秘钥时用到。
Certificate：这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。
Server Key Exchange：如果是 DH 算法，这里发送服务器使用的 DH 参数。RSA 算法不需要这一步。
Certificate Request：Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。
Server Hello Done
Certificate Verify：客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成 Random3，再用服务端公钥非对称加密 Random3 生成 PreMaster Key。
Client Key Exchange：将 PreMaster Key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。

HTTPS 的工作原理：
客户端发起 HTTPS 请求
服务端的配置，数字证书，公钥和私钥
传送证书，公钥
客户端解析证书，由 TLS 来完成
客户端传送加密信息，服务端解密信息
服务端传输加密信息，客户端解密信息

HTTP 和 HTTPS 的区别
HTTP 传输是未加密的明文，而 HTTPS 经过 SSL 加密、认证和完整性保护更加安全。但是 HTTPS 比 HTTP 耗费更多服务器资源。
HTTPS 协议需要到 CA 申请证书。
HTTP 使用简单的无状态的连接，HTTPS 通过 SSL 连接。
HTTP 使用 80 端口，HTTPS 使用 443 端口。

7.HTTP/2.0
HTTP/1.x 缺陷：实现简单是以牺牲性能为代价的：
客户端需要使用多个连接才能实现并发和缩短延迟；
不会压缩请求和响应首部，从而导致不必要的网络流量；
不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

HTTP/2.0 采用的技术：
二进制分帧层，服务端推送，首部压缩。
HTTP/2 在其标准中定义了有状态组件。

Multiplexing 多路传输，一个 TCP 连接中可以完成多个 HTTP 请求（并行）。

HTTP/1.1 新特性：
默认是长连接，TCP 连接不会在一个 HTTP 请求完成之后断开，SSL 也可以使用之前的（刷新页面）。HTTP/1.0 是短连接。
支持流水线，多个请求可以同时发送，Pipelining 浏览器默认不开启。
支持同时打开多个 TCP 连接，Chrome 最多允许一个 host 建立六个 TCP 连接。
支持虚拟主机
新增状态码 100
支持分块传输编码
新增缓存处理指令 max-age。在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
错误状态响应码:在 HTTP1.1 中新增了 24 个错误状态响应码。
带宽优化及网络连接的使用:在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）。

首先考虑 HTTP2 使用 Multiplexing 多路传输，不行则在一个 HOST 上建立多个 TCP 连接。

8.多进程多线程浏览器 Chrome
Browser 主进程：负责协调、主控，只有一个
作用：
负责浏览器界面显示，与用户交互
负责各个页面的管理，创建和销毁其他进程
将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上
网络资源的管理，下载等

插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
GPU 进程：最多一个，用于 3D 绘制等
渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等。

浏览器有时会将多个进程合并。

9.跨域和浏览器同源策略
同源策略：协议/主机/端口都相同。限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
CSRF 跨站请求伪造：生成 Cookie，在不登出受信任网站 A 的情况下，访问危险网站 B。相当于登录了你的账号。

如果非同源将会限制：Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得。AJAX 请求不能发送。
解决对 AJAX 的限制：JSONP、WebSocket 和 CORS

CORS 跨域资源共享：允许浏览器向跨源服务器发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。属于 W3C 标准。
CORS 有两种请求，简单请求和复杂请求。复杂跨域请求会触发预检机制。
对于简单跨域请求，后端只需要在响应体里返回 Access-Controll-Allow 就可以了，但是对于复杂请求，则需要实现一个 Option 方法来返回 Access-Controll-Allow，或者将请求调整为一个简单请求。
请求首部字段 Origin 指示了请求来自于哪个站点，仅指示服务器名称，并不包含任何路径信息。使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。

10.SOCKS 代理
用于客户端与外网服务器之间通讯的中间传递。基本流程：
[需要代理方 ] 向服务器发出请求信息；
[代理方 ] 应答；
[需要代理方 ] 接到应答后发送向[代理方 ] 发送目的 ip 和端口；
代理方 ] 与目的连接；
[代理方 ] 将[需要代理方 ] 发出的信息传到目的方，将目的方发出的信息传到[需要代理方 ]；
代理完成。
