1.简介
SCTP 流控制传输协议：在客户和服务器之间提供关联，面向消息，在连接的端点之间提供多个流按序递送消息，多宿。
TCP 状态转换图，netstat 命令诊断网络问题。

2.套接字编程
套接字地址结构
套接字选项

TCP 套接字编程：
socket()
客户：connect()
服务器：bind(),listen(),accept()
close()
并发：fork(),exec()

UDP 套接字编程：
socket()
服务器：bind()
close()

3.I/O 模型
对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。
Unix 有五种 I/O 模型：
阻塞式 I/O：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
在阻塞的过程中，其它应用进程还可以执行，不消耗 CPU 时间，CPU 利用率会比较高。

非阻塞式 I/O：应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询 polling。
由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。

I/O 复用（select 和 poll，又叫事件驱动和 Reactor 模式）：使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。
让单个进程具有处理多个 I/O 事件的能力，又被称为事件驱动 I/O。
相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

信号驱动式 I/O（SIGIO）：应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。
相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

异步 I/O（AIO）：应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

五大模型的比较：
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O ：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。异步 I/O：不会阻塞。
阻塞式 I/O 和 I/O 复用在第一阶段会阻塞。

4.I/O 复用
select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。
select 和 poll 比较：
差异：
select 会修改描述符，而 poll 不会；
select 的描述符类型使用数组实现，默认只能监听 1024 个描述符，如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符数量的限制。
poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高；
几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

select 和 poll 的功能基本相同：
如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。
select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。

epoll：
已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。
只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。
仅适用于 Linux OS。
epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。
epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
epoll 中的所有描述符都存储在内核中。

工作模式：epoll 的描述符事件有两种触发模式：水平触发 LT 和边沿触发 ET。

应用场景：
select 更加适用于实时性要求比较高的场景，可移植性更好，几乎被所有主流平台所支持。
poll 没有最大描述符数量的限制。
epoll 只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。
