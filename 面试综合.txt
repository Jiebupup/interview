1.多态
编译时多态主要指方法的重载
运行时多态指同一个方法在运行时根据对象引用的不同类型产生不同的表现。
条件：继承，重写，向上转型。

例子：普通员工类和经理类是员工类的子类，使用父类来引用普通员工类和经理类对象，并调用设置工资方法，会执行子类的方法。

2.TCP和UDP
传输层协议，端到端
UDP无连接，面向报文
TCP有连接，提供可靠的服务（通过序号，确认和重传机制），面向字节流，通过滑动窗口实现流量控制，拥塞控制（慢开始与拥塞避免，快重传与快恢复），全双工通信
TCP的三次握手和四次挥手

3.Hashmap
数组+链表，16个桶。
Entry存储key-value对，拉链法解决冲突（头插法）。
桶数小，数据量大，趋于线性查找，时间复杂度度O（n）。
avl树，二三树。

jdk1.8红黑树：一个桶存储的链表长度大于 8 时会将链表转换为红黑树。
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 
（4）如果一个节点是红色的，则它的子节点必须是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
（5）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
插入和删除时自平衡，变色和旋转，时间复杂度O（logn）

与HashTable 的比较：
HashTable 使用 synchronized 来进行同步。
HashMap 可以插入键为 null 的 Entry。
HashMap 的迭代器是 fail-fast 迭代器。
HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
ConcurrentHashMap

4.UNP
I/O模型：阻塞式 I/O，非阻塞式 I/O，I/O 复用，信号驱动 I/O，异步 I/O
五大 I/O 模型比较：UNPp127

I/O 复用：select/poll/epoll
select/poll比较：
select 会修改描述符，而 poll 不会；
select 的描述符类型使用数组实现，而 poll 的描述符类型使用链表实现；
poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高；
如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。select 和 poll 速度都比较慢;
几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

epoll:
红黑树;
仅适用于 Linux;
epoll 中的所有描述符都存储在内核中；
epoll 比 select 和 poll 更加灵活而且没有描述符数量限制;
epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。
epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
epoll 的描述符事件有两种触发模式：LT和ET。

应用场景：
select 更加适用于实时性要求比较高的场景，select 可移植性更好，几乎被所有主流平台所支持。
poll 没有最大描述符数量的限制。
只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。

5.进程间通信
（1）管道
（2）FIFO，也称为命名管道，它是一种文件类型。
FIFO可以在无关的进程之间交换数据，与无名管道不同。
FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

（3）消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

（4）信号量，一个计数器，用于实现进程间的互斥与同步。
信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

（5）共享内存，指两个或多个进程共享一个给定的存储区。
共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
因为多个进程可以同时操作，所以需要进行同步。
信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

五种方式总结：
管道：速度慢，容量有限，只有父子进程能通讯    
FIFO：任何进程间都能通讯，但速度慢    
消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
信号量：不能传递复杂消息，只能用来同步    
共享内存区：能够很容易控制容量，速度快，但要保持同步

6.static
编译时静态绑定，随着类的加载而加载的，因此可以直接用类进行访问。 
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，静态变量在内存中只存在一份。
静态方法：不依赖于任何实例，必须有实现，只能访问所属类的静态变量和静态方法。从内存的角度上静态方法不可以被重写。

7.单例模式Singleton
确保一个类只有一个实例，并提供该实例的全局访问点。
使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

懒汉式（线程不安全->安全） 饿汉式 
双重校检锁 
静态内部类

8.LRU
新的加到链表头，尾删除，有重复的摘下来放到链表头

9.设计模式
SOLID
S（单一功能原则）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。
O（开闭原则）软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。
L（里氏替换原则）派生类必须能完全取代其基类
I（接口隔离原则） 客户不依赖于他不使用的方法。
D(控制反转原则)高层级的模块不应该依赖于低层级的模块，他们应该都依赖于抽象。细节依赖于抽象，而不是抽象依赖于细节。

有什么想问的
1.实习进去之后会接触到什么技术？
2.如何知道自己是否通过面试？
3.对我的表现有什么评价？





























































