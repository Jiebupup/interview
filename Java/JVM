jvm是一个可以执行Java字节码的虚拟进程。
java源程序先经过javac编译器编译成二进制的.class字节码文件，.class字节码文件与平台无关，.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行。

1.运行时数据区域
线程私有：
程序计数器：记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制；在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域。

Java 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。
局部变量表主要存放了编译器可知的各种基本数据类型和对象引用。
该区域可能抛出以下异常：当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。
Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后（return 语句返回或抛出异常返回），都会有一个栈帧被弹出。

本地方法栈：本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是虚拟机栈为虚拟机执行Java方法（也就是字节码），本地方法栈为Native方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

线程共有：
堆：Java虚拟机所管理的内存中最大的一块，在JVM启动的时候被创建。所有对象和数组都在这里分配内存，此内存区域唯一的目的是存放对象实例。堆是垃圾收集的主要区域（"GC 堆"）。
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：新生代和老年代
堆不需要物理上连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

方法区：用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载。

永久代是 HotSpot 的概念。方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现。
JDK 1.8 之前，把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。
从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。元空间使用的是直接内存。
在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。
整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。

运行时常量池是方法区的一部分。Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。还允许运行期间将新的常量放入池中，例如 String 类的 intern()。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

直接内存(不属于运行时数据区域)：在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。
避免了在Java堆和Native堆中来回拷贝数据，显著提高性能。

2.垃圾收集
垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

判断一个对象是否可被回收：
引用计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。因此 Java 虚拟机不使用引用计数算法。

可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。Java 虚拟机使用该算法来判断对象是否可被回收。

方法区的回收：主要是对常量池的回收和对类的卸载。
为了避免内存溢出，在大量使用反射和动态代理的场景（自定义ClassLoader）都需要虚拟机具备类卸载功能。

finalize()：用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。
当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。
引用类型：
强引用：被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。
软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。
弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。
虚引用：一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。

一个常量是废弃常量：在运行时常量池内回收，当前没有任何对象引用该常量。
一个类是无用的类：在方法区内回收，需要满足：
该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
加载该类的 ClassLoader 已经被回收。
该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

垃圾收集算法：
标记 - 清除：不足在于
标记和清除过程效率都不高；
会产生大量不连续的内存碎片，导致无法给大对象分配内存。

标记 - 整理：
优点：不会产生内存碎片。
不足：需要移动大量对象，处理效率比较低。

复制：主要不足是只使用了内存的一半。
采用复制算法回收新生代，并将新生代划分为 Eden 和 Survivor 两部分。
HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1,保证了内存的利用率达到 90%。一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。
如果每次回收有多于 10% 的对象存活，一块 Survivor 不够用时，需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

分代收集：将堆分为新生代和老年代。新生代使用：复制算法；老年代使用：标记 - 清除 或者 标记 - 整理 算法。

垃圾收集器：
CMS 和 G1并行执行：并行指的是垃圾收集器和用户程序同时执行。

CMS：Concurrent Mark Sweep，使用标记 - 清除算法，以获取最短回收停顿时间为目标的收集器
流程：
初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
并发清除：不需要停顿。
在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

缺点：
吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。CMS收集器对CPU资源非常敏感。
无法处理浮动垃圾，由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。预留的内存不够存放浮动垃圾会就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。。
标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

G1：Garbage-First，一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。
堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
通过引入 Region 的概念，将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。新生代和老年代不再物理隔离。
流程：
初始标记
并发标记
最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

特点：
空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

3.内存分配与回收策略
Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。当 Eden 空间满时，就将触发一次 Minor GC。
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

内存分配策略：
大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
大对象直接进入老年代，避免在 Eden 和 Survivor 之间的大量内存复制。
长期存活的对象进入老年代：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
动态对象年龄判定：如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。
空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

当 Eden 空间满时，就将触发一次 Minor GC。 
Full GC 的触发条件：
调用 System.gc()：只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
老年代空间不足：由于内存分配策略中大对象直接进入老年代、长期存活的对象进入老年代等引起。
空间分配担保失败：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。
JDK 1.8 以前的永久代空间不足：方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下会执行Full GC。
Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

4.类加载机制
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。
类加载包含了加载、验证、准备、解析和初始化这 5 个阶段。

类初始化时机
主动引用：
遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。
使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

被动引用：除上述五种场景之外，引用类的方式不会触发初始化。常见例子：
通过子类引用父类的静态字段，不会导致子类初始化。
通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。
常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载（这是因为每一个类加载器都拥有一个独立的类名称空间）。相等包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

类加载器：启动类加载器，扩展类加载器，应用程序类加载器
双亲委派模型：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，依次向上委托，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载类加载器之间的层次关系。
通过组合关系而不是继承关系来实现。用户自定义类加载器->应用程序类加载器->扩展类加载器->启动类加载器。

ClassLoader的方法：
loaderClass()：实现双亲委派
findClass()：用来复写加载
defineClass()：本地方法，最终加载类只能通过defineClass()

自定义类加载器：继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。

5.对象的创建和访问
五步创建对象：
1.类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

2.分配内存：
分配方式：“指针碰撞” 对于没有内存碎片；“空闲列表” 对于有内存碎片。
分配时保证线程安全：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用 CAS 进行内存分配。
 CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

3.初始化零值：这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4.设置对象头：对象头包含这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息以及是否启用偏向锁等。

5.执行 init 方法：执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

访问对象：
句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

6.常量池
常量池在栈中。
只要使用 new 方法，便需要创建新的对象。

String类型的常量池：
直接使用双引号声明出来的 String 对象会直接存储在常量池中。
String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。
字符串拼接会新建对象。

问：String s1 = new String("abc");这句话创建了几个字符串对象？
将创建 1 或 2 个字符串。如果池中已存在字符串文字“abc”，则池中只会创建一个字符串“s1”。如果池中没有字符串文字“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

8 种基本类型的包装类和常量池：浮点数类型的包装类 Float,Double 并没有实现常量池技术，其余六种包装类实现了常量池技术。

7.JDK 监控和故障处理工具
JDK 命令行工具:
jps:查看所有 Java 进程
jstat: 监视虚拟机各种运行状态信息
jinfo: 实时地查看和调整虚拟机各项参数
jmap:生成堆转储快照
jhat: 分析 heapdump 文件
jstack :生成虚拟机当前时刻的线程快照

JDK 可视化分析工具:
JConsole:Java 监视与管理控制台
Visual VM:多合一故障处理工具
