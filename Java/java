1.数据类型
byte（8）
char（16），short（16）
int（32），float（32）
long（64），double（64）
boolean（true或false）所占大小为1B或者4B，取决于虚拟机。JVM 会在编译时期将 boolean 类型的数据转换为 int，JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。
基本数据类型储存在栈中，更加高效。所有数值类型都有正负号。
包装类型：基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。包装类不能被继承。

new Integer()与Integer.valueOf()的区别：new Integer() 每次都会新建一个对象，Integer.valueOf() 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。在 Java 8 中，Integer 缓存池的大小默认为 -128~127。
编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。
基本类型对应的缓冲池：boolean values true and false，all byte values，short values between -128 and 127，int values between -128 and 127，char in the range \u0000 to \u007F
jdk 1.8Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的。

强制类型转换cast。
+=、-=、*=、/=运算符可以执行隐式类型转换。
从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。switch 不支持 long。
大数据类型BigInteger和BigDecimal实现任意精度。但是运算速度变慢。

Java 的参数是按值传递，方法得到的是所有参数值的一个拷贝。不能修改一个基本数据类型的参数（数值型或布尔型），可以改变引用类型的参数所指向对象的值，但不能让该参数引用一个新的对象。

成员变量和局部变量的区别：
局部变量：不能被访问控制修饰符及 static 所修饰，但能被 final 所修饰。成员变量可以被 public,private,static，final 等修饰符所修饰。
成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
成员变量如果没有被赋初值:如果是基本数据类型则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），如果是引用类型 则为null；而局部变量则不会自动赋值。

2.String和数组
String 被声明为 final，因此它不可被继承。
在 Java 8 中，String 内部使用 char 数组存储数据，同时使用 coder 来标识使用了哪种编码。
在 Java 9 之后，String 类的实现改用 byte 数组value存储字符串，同时使用 coder 来标识使用了哪种编码。
value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

不可变的好处：
可以缓存 hash 值：因为 String 的 hash 值经常被使用，不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
安全性：String 经常作为参数，String 不可变性可以保证参数不可变。
线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

自己实现一个不可变的类：
将类声明为final，所以它不能被继承
将所有的成员声明为私有的，这样就不允许直接访问这些成员
对变量不要提供setter方法
将所有可变的成员声明为final，这样只能对它们赋值一次
通过构造器初始化所有成员，进行深拷贝(deep copy)
在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝

String, StringBuffer and StringBuilder：
String 不可变，StringBuffer 和 StringBuilder 可变。
String 是线程安全的，StringBuffer 是线程安全的（内部使用 synchronized 进行同步），StringBuilder 不是线程安全的。
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。StringBuilder 比 StringBuffer 性能高，且适用于单线程。

字符串常量池String Pool：保存着所有字符串字面量，这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。
当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。
在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

new String("abc")会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）:"abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；而使用 new 的方式会在堆中创建一个字符串对象。

数组：
初始化默认值：大括号初始化数组必须出现在创建数组的地方。
范围检查：不能在数组范围之外被访问。
大小不能改变
数组是一种效率最高的存储和随机访问对象引用序列的方式。
实现了 Iterable 接口，可以用 foreach 方法来遍历。
拷贝：多余赋默认值，不够只拷贝最前面的元素

3.面向对象思想
封装：
利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
隐藏内部的细节，用户无需关心对象内部的细节，并可以通过对象对外提供的接口来访问该对象。
好处：减少耦合，减轻维护的负担。

继承：
实现 IS-A 关系，遵循里式替换原则。
父类引用指向子类对象称为向上转型。

访问权限
private：属性和方法可以通过反射访问。
默认包可见
protected：在继承体系中成员对于子类可见，修饰类没有意义。不同包下，在子类中通过父类引用不可以访问其 protected 方法，通过该子类引用可以访问其 protected 方法，不能通过另一个子类引用访问共同基类的 protected 方法。protected的静态变量，无论是否同一个包，在子类中均可直接访问。
public
可以对类或类中的成员（字段以及方法）加上访问修饰符。
如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。确保满足里氏替换原则。
字段决不能是公有的，可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。
如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

重写与重载
重写Override：存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。
@Override 注解让编译器帮忙检查重写的三个限制：子类方法的访问权限必须大于等于父类方法；子类方法的返回类型必须是父类方法返回类型或为其子类型。子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。
方法调用的优先级：this.func(this)、super.func(this)、this.func(super)、super.func(super)转型。
final，private，static方法不能被重写，其他方法都是运行时绑定。

重载Overload：存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。返回值不同，其它都相同不算是重载。

父类的构造方法并不能被继承，所以构造器不能被重写，但是可以被重载。

多态：
相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。
编译时多态：方法的重载。
运行时多态：引用变量的具体类型在运行期才知道，即动态绑定。
运行时多态需要满足继承，重写，向上转型。
例子：乐器类有两个子类：吉他和钢琴，它们都覆盖了父类的 play()，使用父类乐器类来引用子类吉他和钢琴对象，使用乐器类调用 play() 时，会执行吉他类和钢琴类的 play()。

SOLID设计原则
S（单一责任原则）一个类只负责一件事。
O（开放封闭原则）类应该对扩展开放，对修改关闭。在添加新功能时不需要修改代码。符合该原则最典型的是装饰者模式，可以动态地将责任附加到对象上，而不用去修改类的代码。
L（里氏替换原则）子类对象必须能够替换掉所有父类对象。
I（接口分离原则）客户不依赖于他不使用的方法，使用多个专门的接口比使用单一的总接口要好。
D（依赖倒置原则）高层级的模块不应该依赖于低层级的模块，他们应该都依赖于抽象。细节依赖于抽象，而不是抽象依赖于细节。如果高层模块（包含一个应用程序中重要的策略选择和业务模块）依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
依赖于抽象意味着：任何变量都不应该持有一个指向具体类的指针或者引用，任何类都不应该从具体类派生，任何方法都不应该覆写它的任何基类中的已经实现的方法。

4.类和接口
接口和抽象类
abstract抽象类和抽象方法，包含抽象方法的类叫做抽象类。抽象类不能被实例化，需要继承抽象类并实现所有抽象方法才能实例化其子类。
interface接口没有任何的方法实现（java8开始也可以拥有默认的方法实现，修改接口的成本变低），接口的成员（字段 + 方法）默认都是 public ，接口的字段默认都是 static 和 final 的。
接口可以有public和包访问权限。将接口从具体实现中解耦。创建一个类，可以代替为创建一个接口和一个工厂。优先选择类而不是接口，如果必须用接口，则必须进行重构。

在很多情况下，接口优先于抽象类（接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为），比较：
抽象类是 IS-A 关系，接口是 LIKE-A 关系
一个类可以实现多个接口，但只能继承一个抽象类。
接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限（抽象方法不能private）。
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。

选择接口：需要让不相关的类都实现一个方法。需要使用多重继承。
选择抽象类：需要在几个相关的类中共享代码。需要能控制继承来的成员的访问权限，而不是都为 public。需要继承非静态和非常量字段。

Comparator接口：外部排序，专用的比较器。
Comparable接口是在集合内部定义的方法实现的排序，提供compareTo()方法。

枚举类enum
lambda表达式，函数式接口

内部类：
嵌套的接口或类可以被实现为private，从而不允许向上转型。
在外部类的非静态方法中生成指向内部类的引用，在创建内部类对象时需要Outer.inner。
内部类对象能访问外部类的所有成员。内部类对象会捕获指向外部类对象的引用，如果是嵌套类（静态内部类），就不需要这个引用。
匿名内部类：通过实例初始化，达到为匿名内部类创建一个构造器的效果。继承受限，只能继承一个类或接口。
嵌套类可以有static数据、字段和嵌套类，而普通内部类不行。
闭包和回调：闭包是可调用的对象，回调可以在运行时动态地决定需要调用的方法。

内部类最大的优点：每个内部类都能独立地继承一个接口的实现，无论外围类是否已经继承了某个接口的实现，对内部类都没有影响。
利用内部类，可以实现对类的“多重继承”。其他特性：内部类的多个实例与外部类独立；由多个内部类用不同方式实现同一个接口或类；创建内部类时不需要依赖外部类的创建；内部类是独立的实体。

this：表示对当前对象的引用（表示引用类的成员变量，而非函数参数）。在构造方法中引用满足指定参数类型的构造器。除构造器外，禁止在其它方法中调用构造器。
super：访问父类的构造函数，委托父类完成一些初始化的工作。在执行子类的构造方法之前，如果没有用 super 来调用父类特定的构造方法，则会调用父类中没有参数的构造方法。访问父类的成员，如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。
this 和 super必须处于构造器的首行，且不能用在static方法中。

Object类方法：
equals()：equals() 判断引用的对象是否等价。equals方法不能作用于基本数据类型的变量。类没有覆盖 equals() 方法，则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等。
==：基本数据类型==比较的是值，引用数据类型==判断两个变量是否引用同一个对象。
equals()实现：检查是否为同一个对象的引用，如果是直接返回 true；检查是否是同一个类型，如果不是，直接返回 false；将 Object 对象进行转型；判断每个关键域是否相等。
String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

hashCode()：大大减少了 equals 的次数，提高了执行速度。
重写equals为什么要重写hashCode？
相等的两个对象哈希值一定相同，哈希值相同的两个对象不一定相等。
默认的hashCode()是根据对象的内存地址经哈希算法得到哈希值。
如果没有重写hashCode()，hashCode()得出来的值不同，两个对象无法equals()。
因此为了能equals()，必须重写hashCode()，使相等的对象有相同的哈希值。

主要是针对HashSet和HashMap
如果不重写hashcode会出现什么问题？hashCode()确定对象在HashSet中存放的位置，如果不重写hashCode()，添加了两个等价对象但是存放的位置不同就会破坏HashSet的特性。

clone()：protected 方法，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。
如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。
浅拷贝：对于复制对象进行引用传递，拷贝对象和原始对象引用同一个对象。
深拷贝：创建了一个新的对象，并且复制原对象内的成员变量到新对象中，拷贝对象和原始对象的引用类型引用不同对象。每一层的每个对象都进行浅拷贝=深拷贝。
使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。
反序列化readObject()从文件中还原类的对象，不通过构造函数创建对象。

toString()，wait(), notify()，notifyAll()，getClass()
finalize()：使用了本地方法，调用非java代码的方式，需要用finalize()。

5.关键字
final：
数据：声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。
对于基本类型，final 使数值不变。
对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

方法：声明方法不能被子类重写。private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。
类：声明类不允许被继承。

static：
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。当类被Java虚拟机载入的时候，会对static变量进行初始化。
静态方法：在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。
静态语句块：静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行。 该类不管创建多少对象，在类初始化时运行一次。
静态内部类：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。这就意味着，静态内部类不需要依赖于外部类的实例，不能访问外部类的非静态的变量和方法。
静态导包
初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序，最后才是构造函数的初始化。
存在继承时的初始化顺序：父类（静态变量、静态语句块），子类（静态变量、静态语句块），父类（实例变量、普通语句块），父类（构造函数），子类（实例变量、普通语句块），子类（构造函数）。

6.反射
在运行时识别对象和类的信息。
三个动态特性：运行时生成对象实例。运行时调用方法。运行时更改属性。
方法：getClass()或Class.forName()得到Class对象，.newInstance()生成对应的对象，invoke()调用方法。
反射用异常来报告检查结果。

类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName() 这种方式来控制类的加载，该方法会返回一个 Class 对象。
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。
Class 和 java.lang.reflect 一起对反射提供了支持，后者主要包括Field、Method和Constructor 三个类。

优点：可扩展性、用作类浏览器和可视化开发环境、用作调试器和测试工具。
缺点（如果一个功能可以不用反射完成，那么最好就不用）：性能开销、安全限制、内部暴露。

RTTI：在编译时已经知道了所有的类型。使用Class对象。通过匿名基类的引用来发现类型信息。尽量使用多台，只在必须时使用RTTI。
RTTI和反射的区别：RTTI编译器在编译时打开和检查.class文件；对于反射，.class文件在编译时不可获取，在运行时打开和检查.class文件。

RMI远程方法调用：需要在运行时获取类的信息。允许运行在一个Java虚拟机上的对象调用运行在另一个Java虚拟机上的对象的方法。

动态代理：使用到了反射。

7.异常
Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。
Error 用来表示 JVM 无法处理的错误。
Exception 分为受检异常（需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复）和非受检异常（是程序运行时错误）。

常见异常：NullPointerException空指针异常，ClassCastException类型强制转换异常，ArrayIndexOutOfBoundsException数组下标越界异常，IOException输入输出异常，SQLException操作数据库异常。

异常处理：
try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
catch 块：用于处理try捕获到的异常。可以重新抛出异常。
finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

throw和throws的区别：
1、Throw用于方法内部，Throws用于方法声明上
2、Throw后跟异常对象，Throws后跟异常类型
3、Throw后只能跟一个异常对象，Throws后可以一次声明多种异常类型

断言和日志

8.泛型
使用参数化类型，使代码可以应用于多种类型。不能使用基本类型用作类型参数。
使用泛型，可以在编译器防止将错误类型的对象放置到容器中。

类型擦除：在泛型代码的内部，无法获得任何有关泛型参数类型的信息。

元组：仅一次方法调用就能返回多个对象。通过创建一个对象，来持有想要返回的多个对象。
通配符：被限制为单一边界。

9.注解Annontation
Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

注解的用处:
生成文档。
跟踪代码依赖性，实现替代配置文件功能。
在编译时进行格式检查。

注解的原理：注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。
而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。

元注解（专门注解其他的注解）：@Documented、@Retention、@Target、@Inherited。
常见注解：@Override重载、@Deprecated不被推荐使用、@SuppressWarnings抑制警告

单元测试JUnit

10.Java SE 8新特性
Lambda表达式和函数式接口

Stream：能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源。Stream 的操作可以串行执行或者并行执行。
Stream操作
Filter(过滤)：过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作。
Sorted(排序)：如果你不指定一个自定义的 Comparator 则会使用默认排序，该操作属于中间操作。
Map(映射)：中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。
Match(匹配)：Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 最终操作 ，并返回一个 boolean 类型的值。
Count(计数)：计数是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。
Reduce(规约)：这是一个 最终操作 ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的。

新的日期和时间API
接口的默认方法   

11.Java 与 C++ 的区别
Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
Java 支持自动垃圾回收，而 C++ 需要手动回收。
Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。
Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。

面向对象与面向过程的区别

12.容器
容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
容器不能持有基本类型，需要使用自动包装。

Collection
Set：不允许重复
TreeSet：基于红黑树实现，有序，支持范围查找，查找的时间复杂度为O(logN)。
HashSet：基于HashMap实现，无序，查找的时间复杂度为 O(1)。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。如果向HashSet中添加一个已经存在的元素，新添加的集合元素不会覆盖已有的集合元素。
LinkedHashSet：内部使用双向链表维护元素的插入顺序，具有 HashSet 的查找效率。

List
ArrayList：基于动态数组实现，支持快速随机访问。实现了RandomAccess, Cloneable和Serializable接口。默认大小为10。
扩容：新容量的大小为旧容量的 1.5 倍，Arrays.copyOf()把原数组整个复制到新数组中。
删除元素：System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)。
Fail-Fast：modCount 用来记录 ArrayList 结构发生变化的次数。在进行序列化或者迭代等操作时，若modCount发生变化，会抛出 ConcurrentModificationException。java.util包下面的所有的集合类都是fail-fast的。java.util.concurrent包下面的所有的类都是安全失败fail-safe的。
序列化：ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。ArrayList 实现了 writeObject() 序列化和 readObject() 反序列化来控制只序列化数组中有元素填充那部分内容。writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。                  
可以使用 Collections.synchronizedList()，得到一个线程安全的 ArrayList。

Vector：和 ArrayList 类似，但它是线程安全的，使用了 synchronized 进行同步。
与 ArrayList 的比较：
Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制。
Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。

Array与ArrayList比较：
Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。

CopyOnWriteArrayList
读写分离：写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。
使用场景：CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。实现的fail-safe。
缺陷：在写操作时需要复制一个新的数组，内存占用为原来的两倍左右；部分写操作的数据还未同步到读数组中导致数据不一致。因此不适合内存敏感以及对实时性要求很高的场景。

LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。实现了Deque接口。不仅如此，LinkedList 还可以用作栈、队列和双向队列。LinkedList为双向链表。JDK1.6之前为循环链表，JDK1.7取消了循环。
与 ArrayList 的比较：ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；ArrayList 支持随机访问，LinkedList 不支持；LinkedList 在任意位置添加删除元素更快。ArrayList 和 LinkedList 都是不同步的，不保证线程安全。

实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach。
未实现 RandomAccess 接口的list，优先选择foreach。大size的数据，千万不要使用普通for循环。

Queue
双向队列Deque：通过LinkedList实现。
PriorityQueue：基于堆结构实现。调用remove方法，总会获得当前优先级队列中的最小元素。PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。

Map
TreeMap：基于红黑树实现。由Comparable或Comparator排序。

HashMap：基于哈希表实现。Entry<K,V>[] table，数组中的每个位置被当成一个桶，一个桶存放一个链表Entry（存储着键值对）。
拉链法解决冲突：put操作头插法
HashMap只允许一个key为null，允许多个value为null。因为无法调用 null 的 hashCode()，也就无法确定该键值对的桶下标，HashMap 使用第 0 个桶存放键为 null 的键值对。

扩容resize：为了让查找的成本降低，table要尽可能大，HashMap采用动态扩容来根据当前的键值对数量来调整table大小。
默认的table容量capacity是16，默认的装载因子loadFactor是0.75。默认的键值对数量size的临界值threshold = capacity * loadFactor=12。
当Entry的数量超过threshold且新建的Entry刚好落在一个非空的table上，触发扩容capacity*2，并采用transfer()将原有的Entry对象插入到新数组中（会进行rehash()重新计算桶下标）。并发下的resize会造成元素之间会形成一个循环链表。

从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。Entry改为了Node。

HashMap的容量是2的幂次方：
通过限制length是一个2的幂数，indexFor()（求桶的位置）中 h & (length-1) 和 h % length 结果是一致的。取模转换成了&与操作更加高效。
通过右移可以使低位的数据尽量的不同，从而使hash值的均匀分布减少碰撞。

HashTable：和 HashMap 类似，但它是线程安全的，因此也效率低。
HashTable与HashMap比较：
HashTable 使用 synchronized 来进行同步。
HashMap 可以插入键为 null 的 Entry。
HashMap 的迭代器是 fail-fast 迭代器。
HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
初始容量和扩容不同。
HashMap链表长度大于8时，会转换为红黑树。

ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。HashEntry代替Entry。
JDK 1.7 分段锁：将数据分成一段一段的存储，然后给每一段数据配一把锁。当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。默认创建 16 个 Segment锁（继承自 ReentrantLock），并发度与 Segment 数量相等。volatile 修饰数据。
ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。put需要加锁。 
size操作：每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。
ConcurrentHashMap在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

JDK 1.8 取消了分段锁，使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。synchronized只锁定当前链表或红黑二叉树的首节点。也在链表过长时会转换为红黑树。

为什么HashMap支持key或者value为null，而HashTable和ConcurrentHashmap不支持？
Hashtable和ConcurrentHashmap都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。
HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。

LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。可以使用 LinkedHashMap 实现的一个 LRU 缓存。

WeakHashMap：Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。。
Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。
采取的是分代缓存：
经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收。
不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。
当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。
当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。

IdentityHashMap:使用==代替equals对键进行比较。

容器中的设计模式：
迭代器模式：Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。
JDK 1.5 之后使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。
Java中的Iterator可用来遍历Set和List集合，并且只能单向移动。ListIterator实现了Iterator接口，既可以前向也可以后向遍历。
Enumeration接口和Iterator接口的区别：Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。

适配器模式

集合类没有实现Cloneable和Serializable接口：应该由集合类的具体实现来决定如何被克隆或者是序列化。

13.I/O
进程中的IO调用过程：
进程向操作系统请求数据;
操作系统把外部数据加载到内核的缓冲区中; 
操作系统把内核的缓冲区拷贝到进程的缓冲区;
进程获得数据完成自己的功能;

Java I/O 使用了装饰者模式来实现。

磁盘操作File：File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。
从 Java7 开始，可以使用 Paths 和 Files 代替 File。

字节操作InputStream 和OutputStream
不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。

字符操作Reader和Writer
编码就是把字符转换为字节，而解码是把字节重新组合成字符。
GBK：中文字符占 2 个字节，英文字符占 1 个字节；
UTF-8：中文字符占 3 个字节，英文字符占 1 个字节；
UTF-16be：中文字符和英文字符都占 2 个字节。Java 的 char 这种类型使用 UTF-16be 进行编码，使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。大端序最高位字节存储在最低的内存地址处。
getBytes() 的默认编码方式与平台有关，一般为 UTF-8。

在程序中操作的通常是字符形式的数据。
InputStreamReader 实现从字节流解码成字符流；
OutputStreamWriter 实现字符流编码成为字节流。

获取键盘输入：通过 Scanner 或 BufferedReader。

对象操作Serializable
序列化就是将一个对象转换成字节序列，方便存储和传输。
序列化：ObjectOutputStream.writeObject()
反序列化：ObjectInputStream.readObject()

不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。
序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。
transient 关键字可以使一些属性不会被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。

网络操作Socket
InetAddress：用于表示网络上的硬件资源，即 IP 地址。没有公有的构造函数，只能通过静态方法来创建实例。
URL：统一资源定位符；可以直接从 URL 中读取字节流数据。

Sockets：使用 TCP 协议实现网络通信；
ServerSocket：服务器端类
Socket：客户端类
服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。

Datagram：使用 UDP 协议实现网络通信。
DatagramSocket：通信类
DatagramPacket：数据包类

新的输入输出NIO
JDK 1.4引入，高速、面向块，基于通道&缓冲&选择器，同步非阻塞。

I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。
面向流的 I/O 一次处理一个字节数据，为流式数据创建过滤器非常容易，然而面向流的 I/O 通常相当慢。
面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。

NIO核心组件：Channel，Buffer和Selector
通道Channel：是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。
通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。

缓冲区Buffer：不会直接对通道进行读写数据，而是要先经过缓冲区。
缓冲区实质上是一个数组，提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。
缓冲区状态变量。

选择器Selector：NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。
通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。
因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。
应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。
只是有效请求（确实需要进行I/O处理）时，才会使用一个线程去处理，避免了BIO模型下大量线程处于阻塞等待状态的情景。

内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。
向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。

BIO：同步阻塞I/O，数据的读取写入必须阻塞在一个线程内等待其完成。做完一件事再去做另一件事。
如果需要同时做很多事情，就需要系统创建很多线程来完成对应的工作，因为BIO模型下一个线程同时只能做一个工作。如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态。
在BIO模型下的线程阻塞就会导致系统线程的切换，从而对整个系统性能造成一定的影响。

AIO：NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 
在Unix系统下，采用了epoll IO模型，windows 下是使用了IOCP模型。

14.servlet
在Java Web程序中，Servlet主要负责接收用户请求 HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。
Servlet需要在web.xml中配置。
Servlet不能够自行创建并执行，它是在Servlet容器中运行的。
一个Servlet可以设置多个URL访问。Servlet不是线程安全。

优点：
只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销。
如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销。
所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。
Servlet能直接和Web服务器交互，还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。

生命周期： Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。

转发是服务器行为，重定向是客户端行为。重定向是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。

15.补充
Oracle JDK 和 OpenJDK：
OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；
Oracle JDK 比 OpenJDK 更稳定。
Oracle JDK与OpenJDK相比提供了更好的性能；

JRE和JDK：
JRE是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。
JDK是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac和调试器等。
如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。

javax 是扩展的 API 包。

SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类，它允许进行格式化（日期→文本）、解析（文本→日期）和规范化。

SimpleDateFormat为什么不是线程安全的？
在SimpleDateFormat转换日期是通过Calendar对象来操作的，SimpleDateFormat继承DateFormat类，DateFormat类中维护一个Calendar对象，Calendar实例被用来进行日期-时间计算，既被用于format方法也被用于parse方法。
在parse方法的最后，会调用CalendarBuilder的establish方法，入参就是SimpleDateFormat维护的Calendar实例，在establish方法中会调用calendar的clear方法。
SimpleDateFormat维护的用于format和parse方法计算日期-时间的calendar被清空了，如果此时线程A将calendar清空且没有设置新值，线程B也进入parse方法用到了SimpleDateFormat对象中的calendar对象，此时就会产生线程安全问题。

解决方法：每一个使用SimpleDateFormat对象进行日期-时间进行format和parse方法的时候就创建一个新的SimpleDateFormat对象，用完就销毁。此时就可以使用ThreadLocal将SimpleDateFormat绑定到线程上。
