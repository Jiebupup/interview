1.数据类型
byte（8）
char（16），short（16）
int（32），float（32）
long（64），double（64）
boolean（true或false），JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。
基本数据类型储存在栈中，更加高效。所有数值类型都有正负号。

包装类型：基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
new Integer()与Integer.valueOf()的区别：new Integer() 每次都会新建一个对象，Integer.valueOf() 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

强制类型转换cast

大数值BigInteger和BigDecimal实现任意精度。但是运算速度变慢。

Java 的参数是按值传递，方法得到的是所有参数值的一个拷贝。不能修改一个基本数据类型的参数（即数值型或布尔型），可以改变一个对象参数的状态，不能让对象参数引用一个新的对象。

数组：
初始化默认值：大括号初始化数组必须出现在创建数组的地方。
范围检查：不能在数组范围之外被访问。
大小不能改变
数组是一种效率最高的存储和随机访问对象引用序列的方式。
实现了 Iterable 接口，可以用 foreach 方法来遍历。
拷贝：多余赋默认值，不够只拷贝最前面的元素

成员变量和局部变量的区别：
局部变量：不能被访问控制修饰符及 static 所修饰，但能被 final 所修饰。成员变量可以被 public,private,static，final 等修饰符所修饰。
成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
成员变量如果没有被赋初值:如果是基本数据类型则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），如果是引用类型 则为null；而局部变量则不会自动赋值。

2.String
String 被声明为 final，因此它不可被继承。
在 Java 8 中，String 内部使用 char 数组存储数据。
在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。

不可变的好处：
可以缓存 hash 值：因为 String 的 hash 值经常被使用，不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
安全性：String 经常作为参数，String 不可变性可以保证参数不可变。
线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

String, StringBuffer and StringBuilder：
String 不可变（使用final修饰），StringBuffer 和 StringBuilder 可变。
String 是线程安全的，StringBuilder 不是线程安全的，StringBuffer 是线程安全的，内部使用 synchronized 进行同步。
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。StringBuilder 比 StringBuffer 性能高，且适用于单线程。

字符串常量池String Pool：保存着所有字符串字面量，这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。。
在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。
new String("abc")会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。"abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；而使用 new 的方式会在堆中创建一个字符串对象。

3.面向对象思想
封装：隐藏内部的细节，模块化减少耦合，可以通过对象对外提供的接口来访问该对象。

继承：
里式替换原则
private，可以通过反射访问
默认包可见
protected
public
如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。

重写Override：@Override 注解，存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。final，private，static方法不能被重写，其他方法都是运行时绑定。
重载Overload：存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。返回值不同，其它都相同不算是重载。

父类的构造方法并不能被继承，所以构造器不能被重写，但是可以被重载。

多态：
运行时多态需要满足继承，重写，向上转型。
相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。
例子：普通员工类和经理类是员工类的子类，使用父类来引用普通员工类和经理类对象，并调用设置工资方法，会执行子类的方法。

SOLID
S（单一功能原则）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。
O（开闭原则）软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。
L（里氏替换原则）派生类必须能完全取代其基类。
I（接口隔离原则）客户不依赖于他不使用的方法。
D（控制反转原则）高层级的模块不应该依赖于低层级的模块，他们应该都依赖于抽象。细节依赖于抽象，而不是抽象依赖于细节。

4.类和接口
abstract抽象类和抽象方法，包含抽象方法的类叫做抽象类。抽象类不能被实例化，需要继承抽象类并实现所有抽象方法才能实例化其子类。
interface接口没有任何的具体实现（java8开始也可以拥有默认的方法实现），接口的成员（字段 + 方法）默认都是 public ，接口的字段默认都是 static 和 final 的。
接口可以有public和包访问权限。将接口从具体实现中解耦。创建一个类，可以代替为创建一个接口和一个工厂。优先选择类而不是接口，如果必须用接口，则必须进行重构。

在很多情况下，接口优先于抽象类，比较：
抽象类是 IS-A 关系，接口是 LIKE-A 关系
一个类可以实现多个接口，但只能继承一个抽象类。
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限（抽象方法不能private）。

Comparator接口：外部排序，专用的比较器。
Comparable接口是在集合内部定义的方法实现的排序，提供compareTo()方法。

枚举类enum

lambda表达式，函数式接口

内部类：
嵌套的接口或类可以被实现为private，从而不允许向上转型。
在外部类的非静态方法中生成指向内部类的引用，在创建内部类对象时需要Outer.inner。
内部类对象能访问外部类的所有成员。内部类对象会捕获指向外部类对象的引用，如果是嵌套类（静态内部类），就不需要这个引用。
匿名内部类：通过实例初始化，达到为匿名内部类创建一个构造器的效果。继承受限，只能继承一个类或接口。
嵌套类可以有static数据、字段和嵌套类，而普通内部类不行。
闭包和回调：闭包是可调用的对象，回调可以在运行时动态地决定需要调用的方法。

内部类最大的优点：每个内部类都能独立地继承一个接口的实现，无论外围类是否已经继承了某个接口的实现，对内部类都没有影响。
利用内部类，可以实现对类的“多重继承”。其他特性：内部类的多个实例与外部类独立；由多个内部类用不同方式实现同一个接口或类；创建内部类时不需要依赖外部类的创建；内部类是独立的实体。

this：对“调用方法的那个对象”的引用，自动应用于同一类的其他方法。将自身传递给外部方法，必须用this。用this只能调用一个构造器。除构造器外，禁止在其它方法中调用构造器。
super：访问父类的构造函数或访问父类的成员
在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。
this 和 super必须处于构造器的首行，且不能用在static方法中。

Object类通用方法：
equals()：equals() 判断引用的对象是否等价。equals方法不能作用于基本数据类型的变量。类没有覆盖 equals() 方法，则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等。
==：基本数据类型==比较的是值，引用数据类型==判断两个变量是否引用同一个对象。
String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

hashCode()：
hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。
hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
hashCode() 大大减少了 equals 的次数，相应就大大提高了执行速度。
在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。

toString()
wait, notify，notifyAll

clone()：
实现Cloneable接口
浅拷贝：对于复制对象进行引用传递，拷贝对象和原始对象引用同一个对象。
深拷贝：创建了一个新的对象，并且复制原对象内的成员变量到新对象中，拷贝对象和原始对象的引用类型引用不同对象。每一层的每个对象都进行浅拷贝=深拷贝。
使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

getClass（）
finalize（）：使用了本地方法，调用非java代码的方式，需要用finalize（）。

5.关键字
final：
数据：声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。对于基本类型，final 使数值不变；对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。
方法：声明方法不能被子类重写。private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。
类：声明类不允许被继承。

static：
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。当类被Java虚拟机载入的时候，会对static变量进行初始化。
静态方法：在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。Java中static方法不能被覆盖
静态语句块：静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行。 该类不管创建多少对象，在类初始化时运行一次。
静态内部类：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。这就意味着，静态内部类不需要依赖于外部类的实例，不能访问外部类的非静态的变量和方法。
静态导包
初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。静态初始化只有在必要时才会进行。
存在继承时，父类（静态变量、静态语句块），子类（静态变量、静态语句块），父类（实例变量、普通语句块），父类（构造函数），子类（实例变量、普通语句块），子类（构造函数）。

6.反射
在运行时识别对象和类的信息：
RTTI：在编译时已经知道了所有的类型。使用Class对象。通过匿名基类的引用来发现类型信息。尽量使用多台，只在必须时使用RTTI。
反射：运行时发现和使用类的信息。用异常来报告检查结果。
真正区别：RTTI编译器在编译时打开和检查.class文件；对于反射，.class文件在编译时不可获取，在运行时打开和检查.class文件。

RMI远程方法调用：需要在运行时获取类的信息。允许运行在一个Java虚拟机上的对象调用运行在另一个Java虚拟机上的对象的方法

静态代理和动态代理：
静态代理
优点：可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。
缺点：因为代理对象，需要实现与目标对象一样的接口，接口与代理类是1对1的，会导致代理类十分繁多，不易维护，同时一旦接口增加方法，则目标对象和代理类都需要维护。

动态代理：使用了反射
优点：代理对象无需实现接口，免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需在事件处理器中添加对方法的判断即可。
缺点：代理对象不需要实现接口，但是目标对象一定要实现接口，否则无法使用JDK动态代理。

类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName() 这种方式来控制类的加载，该方法会返回一个 Class 对象。
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。
Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：
Field：get() 和 set() 方法读取和修改 Field 对象关联的字段；
Method：invoke() 方法调用与 Method 对象关联的方法；
Constructor：创建新的对象。

反射的优点：可扩展性，类浏览器和可视化开发环境，调试器和测试工具。
反射的缺点：尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。性能开销 ，安全限制，内部暴露。

7.异常
Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。
Error 用来表示 JVM 无法处理的错误，Exception 分为两种：受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；非受检异常 ：是程序运行时错误。

异常处理：
try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
catch 块：用于处理try捕获到的异常。可以重新抛出异常。
finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

throw和throws的区别：
1、Throw用于方法内部，Throws用于方法声明上
2、Throw后跟异常对象，Throws后跟异常类型
3、Throw后只能跟一个异常对象，Throws后可以一次声明多种异常类型

断言和日志

8.泛型
使用参数化类型，使代码可以应用于多种类型。不能使用基本类型用作类型参数。
使用泛型，可以在编译器防止将错误类型的对象放置到容器中。

类型擦除：在泛型代码的内部，无法获得任何有关泛型参数类型的信息。

元组：仅一次方法调用就能返回多个对象。通过创建一个对象，来持有想要返回的多个对象。
通配符：被限制为单一边界。

9.注解
Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。
单元测试JUnit

10.Java SE 8新特性
Lambda表达式和函数式接口
Stream
新的日期和时间API
接口的默认方法

11.Java 与 C++ 的区别
Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
Java 支持自动垃圾回收，而 C++ 需要手动回收。
Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。
Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。

面向对象与面向过程的区别：面向过程性能高而面向对象易维护、易复用、易扩展。

12.容器
容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
容器不能持有基本类型，需要使用自动包装。

Collection：
Set：不允许重复
TreeSet：基于红黑树实现，有序，查找的时间复杂度为O(logN)。
HashSet：基于HashMap实现，无序，查找的时间复杂度为 O(1)。
LinkedHashSet：内部使用双向链表维护元素的插入顺序，具有 HashSet 的查找效率。

List：有序
ArrayList：基于动态数组实现，支持随机访问。实现了RandomAccess, Cloneable和Serializable接口。
扩容：新容量的大小为旧容量的 1.5 倍，把原数组整个复制到新数组中。
Fail-Fast
序列化：没必要全部进行序列化。

Vector：和 ArrayList 类似，但它是线程安全的，使用了 synchronized 进行同步。
与 ArrayList 的比较：Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。
Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。Array大小是固定的，ArrayList的大小是动态变化的。

CopyOnWriteArrayList：写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。
CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。由于内存占用和数据不一致，不适合内存敏感以及对实时性要求很高的场景。

LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。实现了Deque接口。不仅如此，LinkedList 还可以用作栈、队列和双向队列。LinkedList为双向链表。JDK1.6之前为循环链表，JDK1.7取消了循环。
与 ArrayList 的比较：ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；ArrayList 支持随机访问，LinkedList 不支持；LinkedList 在任意位置添加删除元素更快。ArrayList 和 LinkedList 都是不同步的，不保证线程安全。

实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach。
未实现 RandomAccess 接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环。

Queue：
双向队列：通过LinkedList实现。
PriorityQueue：基于堆结构实现。调用remove方法，总会获得当前优先级队列中的最小元素。PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。

Map：键值对
TreeMap：基于红黑树实现。由Comparable或Comparator排序。

HashMap：基于哈希表实现。hashmap数组只允许一个key为null，允许多个value为null。Entry 对象存储着键值对。数组中的每个位置被当成一个桶，一个桶存放一个链表。
拉链法：put操作使用链表的头插法
扩容：默认的容量capacity是16，默认的负载因子loadFactor是0.75。
从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。Entry改为了Node。
HashMap 的长度是2的幂次方：能让存取高效，尽量较少碰撞，尽量把数据分配均匀。
rehash：当添加对象的数量超过阈值threshold，数组大小*2，并将原有的Entry对象插入到新数组中。并发下的rehash 会造成元素之间会形成一个循环链表。

HashTable：和 HashMap 类似，但它是线程安全的，因此也效率低。
与 HashMap 的比较：HashTable 使用 synchronized 来进行同步。HashMap 可以一个 key 为 null ，多个 value 为 null，HashTable不可以。HashMap 的迭代器是 fail-fast 迭代器。HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。初始容量和扩容不同。HashMap链表长度大于8时，会转换为红黑树。

ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
JDK 1.7 分段锁：将数据分成一段一段的存储，然后给每一段数据配一把锁。当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。默认创建 16 个 Segment锁，并发度与 Segment 数量相等。volatile 修饰数据。
ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。put需要加锁。
JDK 1.8 取消了分段锁，使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。synchronized只锁定当前链表或红黑二叉树的首节点。

LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
使用 LinkedHashMap 实现的一个 LRU 缓存。

WeakHashMap：Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。主要用来实现缓存。
IdentityHashMap:使用==代替equals对键进行比较。

容器中的设计模式：
迭代器模式：Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。
使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。
Java中的Iterator可用来遍历Set和List集合，并且只能单向移动。ListIterator实现了Iterator接口，既可以前向也可以后向遍历。
Enumeration接口和Iterator接口的区别：Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。
快速失败(fail-fast)：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。因此不能在多线程下发生并发修改（迭代过程中被修改）。

适配器模式

集合类没有实现Cloneable和Serializable接口：应该由集合类的具体实现来决定如何被克隆或者是序列化。

13.I/O
磁盘操作File

字节操作InputStream 和 OutputStream
装饰者模式
不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。

字符操作Reader 和 Writer
InputStreamReader 实现从字节流解码成字符流；
OutputStreamWriter 实现字符流编码成为字节流。

对象操作Serializable
序列化就是将一个对象转换成字节序列，方便存储和传输。
不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。
序列化的类需要实现 Serializable 接口。
transient 关键字可以使一些属性不会被序列化。

网络操作Socket
InetAddress：用于表示网络上的硬件资源，即 IP 地址；
URL：统一资源定位符；可以直接从 URL 中读取字节流数据。
Sockets：使用 TCP 协议实现网络通信；
Datagram：使用 UDP 协议实现网络通信。

新的输入输出NIO
JDK 1.4引入，面向块，同步非阻塞，面向缓冲，基于通道。

I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。
面向流的 I/O 一次处理一个字节数据，为流式数据创建过滤器非常容易，然而面向流的 I/O 通常相当慢。。
面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。

NIO核心组件：Channel，Buffer和Selector
通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。
通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。

不会直接对通道进行读写数据，而是要先经过缓冲区。缓冲区实质上是一个数组，提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

NIO实现了Selector选择器：一个线程 Thread 使用一个 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。将套接字 Channel 配置为非阻塞，当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。

内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。
向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。

BIO：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。适合低并发。

AIO：NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 

14.servlet
在Java Web程序中，Servlet主要负责接收用户请求 HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。
Servlet需要在web.xml中配置。
Servlet不能够自行创建并执行，它是在Servlet容器中运行的。
一个Servlet可以设置多个URL访问。Servlet不是线程安全。

优点：
只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销。
如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销。
所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。
Servlet能直接和Web服务器交互，还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。

生命周期： Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。

转发是服务器行为，重定向是客户端行为。重定向是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。

session和cookie的区别：
Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式。Cookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录用户的状态。
cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器。服务器检查该cookie，从而判断用户的状态。服务器还可以根据需要修改cookie的内容。 
session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 如果说cookie机制是通过检查客户身上的“通信证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。
客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。
session能够存储任意的Java对象，cookie只能存储String类型的对象。

15.补充
Oracle JDK 和 OpenJDK：
OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；
Oracle JDK 比 OpenJDK 更稳定。
Oracle JDK与OpenJDK相比提供了更好的性能；

javax 是扩展的 API 包。

对象引用存放在栈内存中。

获取键盘输入：通过 Scanner，通过 BufferedReader。
