1.AOP
面向切面编程
横切关注点可以被描述为影响应用多处的系统服务，切面能帮助我们模块化横切关注点，在系统运行时需要的地方进行动态插入运行。分离业务逻辑与系统服务，应用对象只完成业务逻辑。
基于代理模式：JDK和CGLIB动态代理。JDK只能代理接口，CGLIB代理类。
ASPECTJ静态织入。

2.IOC
控制反转，或者叫DI依赖注入
将对象之间的相互依赖关系交给IOC容器来管理，并由IOC容器完成对象的注入。Spring通过XML文件来配置Bean，SpringBoot使用注解配置。
IOC容器的初始化过程：读取XML资源，解析，最终注册到Bean Factory中。
然后创建bean的实例，并利用反射注入property。

IOC是工厂模式

3.MVC
Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。
通常模型对象负责在数据库中存取数据。

View（视图）是应用程序中处理数据显示的部分。
通常视图是依据模型数据创建的。

Controller（控制器）是应用程序中处理用户交互的部分。
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
@ResponseBody：返回给前端所要的数据类型json

Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。

流程：
第1步：浏览器发送指定的请求都会交给前端控制器DispatcherServlet,他会委托其他模块进行真正的业务和数据处理 
第2步：DispatcherServlet根据请求信息调用HandleMapping,解析请求对应的Handler（也就是Controller控制器），HandlerAdapter适配器会根据Handler来调用真正的处理器开处理请求
第3步：目标Controller处理完业务后，返回一个ModelAndView给DispatcherServlet 
第4步：DispatcherServlet通过ViewResolver视图解析器找到对应的视图对象View 
第5步：DispatcherServlet把返回的Model传给View（视图渲染），并返回到浏览器

4.bean的生命周期
实例化bean对象(通过构造方法或者工厂方法)
设置对象属性(setter等)（依赖注入）
如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）
如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身
将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization()
调用InitializingBean的afterPropertiesSet()
调用自定义的初始化方法
将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization()
使用Bean，将一直存在于应用上下文中，直到该应用上下文被销毁。
调用DisposableBean的destroy()
调用自定义的销毁方法

spring中bean生存的容器BeanFactory 、 ApplicationContext 、webApplicationContext 。应用上下文更好。

5.bean的作用域
@scope注解定义Bean的作用域。

singleton：IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。
线程安全问题：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。
解决方法：在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中。

prototype：每次注入或者通过Spring应用上下文获取时，都会创建一个新的Bean实例。

session&request：web应用中，为每次会话或请求创建一个Bean实例。

6.注解
启动类@SpringBootApplication元注解：无实际功能
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited

@SpringbootConfiguration：
@ComponentScan：
@EnableAutoConfiguration：

@Enable开头的注解

那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。bean 就是由 IOC 容器初始化、装配及管理的对象。
@Bean注解通常是我们在标有该注解的方法中定义产生这个 bean
@Autowired 注解自动装配 bean
将一个类声明为Spring的 bean 的注解：
@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中
@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。
@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

7.Spring用到的设计模式
工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
代理设计模式 : Spring AOP 功能的实现。
单例设计模式 : Spring 中的 Bean 默认都是单例的。
模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

8.事务

9.Mybatis
MyBatis 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。和Hibernate一样都是ORM对象关系映射，负责数据库和java对象之间的映射。区别是MyBatis自己控制SQL。

在Mybatis中我们可以定义一个叫做TypeHandler类型处理器的东西，通过它可以实现Java类型跟数据库类型的相互转换。

MyBatis的SQL建议写在XML里，或者写在注解里。
实现DAO接口：建议Mapper自动实现，只需给出DAO接口；或者API编程方式。

MyBatis XML 标签类型：
resultMap 标签的类型属性为 type（必填）。
id, result 标签的类型属性为javaType（可选）。
idArg, arg 标签和上面两个类似，也都是 javaType（可选）。
association 标签的类型属性为 javaType（可选）。
discriminator 标签的类型属性为 javaType（可选）。
collection 这个标签最特殊，有两个类型属性，分别为 javaType（可选） 和 ofType（结果映射时必填）。

10.springBoot Starter
starter会把所有用到的依赖都给包含进来，避免了开发者自己去引入依赖所带来的麻烦。stater机制帮我们完成了项目起步所需要的的相关jar包。
ConfigurationProperties和AutoConfiguration，application.properties 文件满足自定义配置。
利用starter实现自动化配置只需要两个条件——maven依赖、配置文件。
