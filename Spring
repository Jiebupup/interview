1.AOP
Aspect-Oriented Programming 面向切面编程。代理模式。
横切关注点可以被描述为那些与业务无关，却为业务模块所共同调用的逻辑或责任。
切面能帮助我们模块化横切关注点，在系统运行时需要的地方进行动态插入运行。扩展功能不修改源代码。
分离业务逻辑与系统服务，应用对象只完成业务逻辑。可用于事务处理、日志管理、权限控制、缓存控制、性能监控、异常处理等。 

使用 AOP 的好处：
集中处理某一关注点/横切逻辑。
可以很方便地添加/删除关注点。
侵入性少，增强代码地可读性及可维护性。

注意事项：
无法拦截 static、final、private 方法。
无法拦截内部方法调用。

JDK 和 CGLIB 动态代理。Spring AOP 对于动态代理的选择：
默认使用 CGLIB 动态代理。
如果目标对象实现了接口，则默认使用 JDK 动态代理。
如果目标对象实现了接口，且强制使用 CGLIB 动态代理，则使用 CGLIB 动态代理。

ASPECTJ 编译期织入，ASPECTJ 5+ 类加载时织入。Spring AOP 和 AspectJ AOP 的区别：
Spring AOP 属于运行时增强，而 AspectJ 是编译（类加载）时增强。
Spring AOP 基于代理，而 AspectJ 基于字节码操作。
Spring AOP 相对来说简单，而 AspectJ 功能更加强大。
当切面太多的话，最好选择 AspectJ，它比 Spring AOP 快很多。

AspectJ 注解 @Aspect：
连接点 joinpoint：准备增强的方法
切点 pointcut：实际增强的方法。@Pointcut 切面表达式包含指示器 designators、通配符 wildcards 和运算符 operators。
通知/增强 advice：实现的功能
切面 aspect：把增强应用到方法的过程
引入 introduction：向现有的类添加新的方法或者属性
织入 weaving：把切面应用到目标

五种通知 Advice：
前置 @Before
后置 @After
成功 @AfterReturning
异常 @AfterThrowing
环绕 @Around，前面功能全有

多个 AOP 叠加：责任链模式 + 改进版本
用 AOP 实现 transaction、security、cache
security：MethodSecurityInterceptor、PreInvocationAuthrizationAdviceVote、ExpressionBasedPreInvocationAdvice
@PreAuthorize 验证机制：decide -> vote -> before 只需要一个注解就可以实现，debug 进源码看实现流程。
cache：AnnotationCacheSupport、CacheInterceptor、CacheAspectSupport，时序图 invoke -> execute -> doGet -> invokeJoinpoint -> cachePutRequest.apply

2.IOC
Inverse of Control 控制反转，或者叫依赖注入 DI。DI 不能单独存在，需要在 IOC 基础之上完成。工厂模式。
将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器将依赖关系注入到对象之中。实现具有依赖关系的对象之间的解耦。
对象 A 依赖于对象 B，对象 A 获得依赖对象 B 的过程，由主动行为变为了被动行为，控制权颠倒了。控制反转是获得依赖对象的过程被反转。
Spring 通过 XML 文件来配置 Bean，SpringBoot 使用注解配置。反射，根据配置文件中给出的类名生成相应的对象。

使用 IOC 的好处：
降低耦合。
提高了模块的可复用性。
把对象生成放在配置文件里进行定义，更换一个实现子类将会变得很简单，只要修改配置文件就可以，具有热插拨特性。

注意事项：
引入了第三方 IOC 容器，生成对象的步骤变得复杂。
IOC 容器通过反射方式生成对象，在运行效率上有一定的损耗。
需要进行大量的配制工作，比较繁琐。

依赖注入的方式：构造函数、Setter、接口。
Spring IOC 的初始化过程：读取 XML 资源，解析为 BeanDefinition，最终注册到 Bean Factory 中。
bean 的创建方法
实例化 bean 对象的方法

spring 中 bean 生存的容器：BeanFactory、ApplicationContext、webApplicationContext。应用上下文更好。
BeanDefinition：用来管理 bean 的属性和对象间的相互依赖关系

3.MVC
模型 Model 是应用程序中用于处理应用程序数据逻辑的部分。
通常模型对象负责在数据库中存取数据。

视图 View 是应用程序中处理数据显示的部分。
通常视图是依据模型数据创建的。

控制器 Controller 是应用程序中处理用户交互的部分。
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
ResponseEntity：HTTP响应
@ResponseBody：返回给前端json格式的结果
@ResponseStatus：返回状态

流程：
客户端（浏览器）发送请求到前端控制器DispatcherServlet。
DispatcherServlet根据请求信息调用控制器映射HandleMapping，解析请求对应的Handler（控制器Controller），然后返回一个执行链给DispatcherServlet。
适配器HandlerAdapter会根据Handler来调用真正的处理器处理请求和相应的业务逻辑。
处理器返回一个ModelAndView给DispatcherServlet。
DispatcherServlet通过视图解析器ViewResolver找到对应的视图对象View。 
DispatcherServlet把返回的Model传给View（视图渲染），并返回到浏览器。

Model1 时代：整个 Web 应用几乎全部用 JSP 页面组成，JSP 即是控制层又是表现层。
Model2 时代：Java Bean(Model)+ JSP（View）+Servlet（Controller），抽象和封装程度还远远不够。Struts2 比较笨重。
Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。

SSM三层架构
View层：JSP/HTML页面发送请求，获取响应。
Controller层SpringMVC，接受请求并进行相应的流程处理。
Service层Spring：完成具体的业务逻辑
DAO层MyBatis：对数据库进行操作

@RestController vs @Controller
Controller 返回一个页面：单独使用 @Controller 不加 @ResponseBody的话一般使用在要返回一个视图的情况。前后端不分离。
@RestController 返回JSON 或 XML 形式数据：只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务。前后端分离。Spring 4 之后新加的注解。         
@Controller +@ResponseBody 返回JSON 或 XML 形式数据：等于@RestController。@ResponseBody 注解的作用是将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中。                    

4.bean 生命周期（bean 实例化过程）
实例化 bean 对象(通过构造方法或者工厂方法)。Bean 容器找到配置文件中 Spring Bean 的定义。Bean 容器利用 Java Reflection API 创建一个Bean的实例。
设置对象属性(setter 等)（依赖注入）
如果 bean 实现了 BeanNameAware 接口，调用 setBeanName() 传入 bean 的 ID（检查 Aware 接口）
如果 bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory() 传入 ClassLoader 对象的实例
将 bean 传递给 BeanPostProcessor，调用 postProcessBeforeInitialization()
调用 InitializingBean 的 afterPropertiesSet()
调用自定义的初始化方法
将 bean 传递给 BeanPostProcessor，调用 postProcessAfterInitialization()
使用 Bean，将一直存在于应用上下文中，直到该应用上下文被销毁。
调用 DisposableBean 的 destroy()
调用自定义的销毁方法

5.bean的作用域
@scope注解定义Bean的作用域。

singleton：唯一 bean 实例，Spring 中的 bean 默认都是单例的。
线程安全问题：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。
解决方法：在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中。

prototype：每次请求都会创建一个新的 bean 实例。
request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
session：每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。
global-session：全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。

6.注解
@Component 和 @Bean 的区别：
@Component 注解作用于类，而@Bean注解作用于方法。
@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中，@Bean 注解通常是在标有该注解的方法中定义产生这个 bean。
@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。

使用 @Autowired 注解自动装配 bean
将一个类声明为Spring的 bean 的注解：
@Component：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。
@Repository: 对应持久层即 Dao 层，主要用于数据库相关操作。
@Service: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。
@Controller: 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

启动类@SpringBootApplication元注解：无实际功能
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited

@SpringbootConfiguration：
@ComponentScan：
@EnableAutoConfiguration：

@Enable开头的注解

@RequestMapping：处理请求地址映射
@ResponseBody：返回json数据。

7.Spring用到的设计模式
工厂模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
代理模式 : Spring AOP 功能的实现。
单例模式 : Spring 中的 Bean 默认都是单例的。把已经初始过的变量放在一个Map中，下次再要使用这个变量的时候，先判断Map中有没有。
模板模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
装饰器模式 : 连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式: Spring 事件驱动模型。
适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

8.事务
事务管理：按照给定的事务规则来执行提交或者回滚操作。
发生 unchecked 异常时会发生回滚。只有非只读事务才能回滚。

Spring 事务管理接口
PlatformTransactionManager：（平台）事务管理器，根据不同持久层框架提供对应的接口实现类。
TransactionDefinition：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。
TransactionStatus：事务运行状态。

Spring 并不直接管理事务，而是提供了多种事务管理器，将事务管理的职责委托给持久化机制所提供的相关平台框架的事务来实现。

PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务。
TransactionDefinition 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。
隔离级别：定义了一个事务可能受其他并发事务影响的程度。Spring 事务中的隔离级别多了 DEFAULT，使用后端数据库默认的隔离级别。
传播行为：为了解决业务层方法之间互相调用的事务问题。
超时属性：一个事务允许执行的最长时间。
只读属性：对事物资源是否执行只读操作。
回滚规则：定义事务回滚规则。

TransactionStatus 接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状态信息。
PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的 TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。

编程式事务与声明式事务
编程式事务：通过 Transaction Template 手动管理事务，实际应用中很少使用。
声明式事务：基于 XML 和基于注解，实际是通过 AOP 实现，推荐使用（代码侵入性最小）。
实现声明式事务的四种方式：TransactionInterceptor、TransactionProxyFactoryBean、<tx> 和 <aop> 命名空间、@Transactional。
@Transactional(rollbackFor = Exception.class) 注解：如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性，那么事物只会在遇到 RuntimeException 的时候才会回滚，加上 rollbackFor=Exception.class，可以让事物在遇到非运行时异常时也回滚。

9.Mybatis
MyBatis 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。和 Hibernate 一样都是 ORM 对象关系映射，负责数据库和 Java 对象之间的映射。区别是 MyBatis 自己控制 SQL。

在 Mybatis 中我们可以定义一个叫做 TypeHandler 类型处理器的东西，通过它可以实现 Java 类型跟数据库类型的相互转换。

动态 sql 是 mybatis 的主要特性之一，在 mybatis 中我们可以把参数传到 xml 文件，由 mybatis 对 sql 及其语法进行解析，mybatis支 持使用 ${} 和 #{}。
# 和 $ 的区别：
使用 ${} 方式传入的参数，mybatis 不会对它进行特殊处理，一般用于传入数据库对象。MyBatis 排序时使用 order by 动态参数时需要注意，用 $ 而不是 #。
使用 #{} 传进来的参数，mybatis 默认会将其当成字符串，加双引号。
# 和 $ 在预编译处理中是不一样的。# 类似 jdbc 中的 PreparedStatement，对于传入的参数，在预处理阶段会使用 ? 代替，待真正查询的时候即在数据库管理系统 DBMS 中才会代入参数。而 ${} 则是简单的替换。
由于 PreparedStatement，#{} 可以有效防止 sql 注入，${} 则可能导致 sql 注入成功。因此能使用 #{} 的地方应尽量使用 #{}。

MyBatis的 SQL 建议写在 XML 里，或者写在注解里。
实现 DAO 接口：建议 Mapper 自动实现，只需给出 DAO 接口；或者 API 编程方式。

MyBatis XML 标签类型：
resultMap 标签的类型属性为 type（必填）。
id, result 标签的类型属性为javaType（可选）。
idArg, arg 标签和上面两个类似，也都是 javaType（可选）。
association 标签的类型属性为 javaType（可选）。
discriminator 标签的类型属性为 javaType（可选）。
collection 这个标签最特殊，有两个类型属性，分别为 javaType（可选） 和 ofType（结果映射时必填）。

10.springBoot Starter
starter会把所有用到的依赖都给包含进来，避免了开发者自己去引入依赖所带来的麻烦。stater机制帮我们完成了项目起步所需要的的相关jar包。
ConfigurationProperties和AutoConfiguration，application.properties 文件满足自定义配置。
利用starter实现自动化配置只需要两个条件——maven依赖、配置文件。

11.jdbcTemplate
ORM持久化技术：JDBC、Hibernate、MyBatis、JPA，Spring都对其进行了封装Template模板类。
步骤：
导入jar包（数据库驱动的jar包）
创建对象，设置数据库信息
创建jdbcTemplate对象，设置数据源
调用jdbcTemplate对象里面的方法实现操作CRUD

jdbc查询操作：Connection conn,PreparedStatement psmt,ResultSet rs。

查询操作：
查询某一个值queryForObject
返回对象：自己写个类实现RowMapper接口完成数据封装

12.SSH
Struts+Spring+Hibernate
对象关系映射ORM

Hibernate和Spring整合时，Hibernate核心配置文件和位置没有固定要求
Spring提供HibernateTemplate进行封装

Struts核心：Action、值栈、拦截器

Spring中s使用ServletContext对象和监听器
