1.AOP
面向切面编程
使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。
基于代理思想，对原来目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象，调用增强功能的代码，从而对原有业务方法进行增强 ！
分为JDK动态代理和Cglib动态代理（对没有实现接口的类增强）。

实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；
二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码.

2.IOC
控制反转
实现将组件间的关系从程序内部提到外部容器（spring的xml）来管理。
首先外部容器（spring.xml）中会动态的注册业务所需的对象（接口/类）。

或者叫DI依赖注入:
组件之间的依赖关系由容器在应用系统运行期来决定， 也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。
创建被调用者实例的工作通常由spring容器来完成，然后注入调用者。

IOC是工厂模式
AOP是代理模式

3.MVC
Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。
通常模型对象负责在数据库中存取数据。
View（视图）是应用程序中处理数据显示的部分。
通常视图是依据模型数据创建的。
Controller（控制器）是应用程序中处理用户交互的部分。
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

4.bean的生命周期
实例化bean对象(通过构造方法或者工厂方法)
设置对象属性(setter等)（依赖注入）
如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）
如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身
将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization()
调用InitializingBean的afterPropertiesSet()
调用自定义的初始化方法
将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization()
使用Bean，将一直存在于应用上下文中，直到该应用上下文被销毁。
调用DisposableBean的destroy()
调用自定义的销毁方法

spring中bean生存的容器BeanFactory 、 ApplicationContext 、webApplicationContext 。应用上下文更好。

5.bean的作用域
通过声明scope配置项，可以灵活定义Bean的作用范围。

singleton：IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。

prototype：IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例。

request、、session、global-session。

6.注解
