1.AOP
面向切面编程。代理模式。
横切关注点可以被描述为那些与业务无关，但却对多个对象产生影响的公共行为和逻辑。切面能帮助我们模块化横切关注点，便于减少系统的重复代码，降低模块间的耦合度，在系统运行时需要的地方进行动态插入运行。
分离业务逻辑与系统服务，应用对象只完成业务逻辑。可用于权限认证、日志、事务处理。扩展功能不修改源代码。   

JDK和CGLIB动态代理。JDK只能代理接口，CGLIB代理类。
ASPECTJ静态代理实现aop：基于xml配置和注解方式。

纵向机制：继承
连接点：可以被增强的方法
切入点：实际增强的方法
通知/增强：实现的功能
切面：把增强应用到方法的过程

使用表达式配置切入点
<aop:config>配置切入点和切面</aop:config>
切入点：<aop:pointcut expression="" id=""/>
切面：<aop:aspect ref=""><aop:before method="" pointcut-ref=""/></aop:aspect>前置增强

2.IOC
控制反转，或者叫DI依赖注入。DI不能单独存在，需要在IOC基础之上完成。工厂模式。
将对象之间的相互依赖关系交给IOC容器来管理，并由IOC容器完成对象的注入。Spring通过XML文件来配置Bean，SpringBoot使用注解配置。创建对象由Spring来管理。

依赖注入方式：（1）工厂方法注入（2）构造器注入（3）Setter注入 （4）注解注入

xml方式
底层原理：xml配置文件，dom4j解决xml，工厂设计模式，反射。
<bean id=""class=""></bean>只需要变化这一部分来降低耦合,Class.forName(), .newInstance()。
IOC创建对象：1.导入jar包和引入约束，2.创建类和方法，3.写配置文件，4.ApplicationContext context=new ClassPathXmlApplicationContext(".xml")和context.getBean("")。

bean的实例化方法（用来创建对象）：构造器（无参数构造函数）、静态工厂和实例工厂。
bean标签属性：id,class（创建对象所在类的全路径）,name（可以包含特殊符号）,scope（bean的作用范围）。

属性注入：创建对象时向类里面属性设置值。
注入方法：set()property标签放注入对象，ref属性代替value属性。有参数构造方法constructor-arg标签。
p名称空间：xmlns:p=""，bean标签中加p:pname属性。用来注入复制属性array、list、map等，property内有多个value属性。

IOC容器的初始化过程：读取XML资源，解析，最终注册到Bean Factory中。
然后创建bean的实例，并利用反射注入property。

注解方式
使用在类、属性、方法之上。
开启包注解扫描context:component-scan标签，context:annotation-config标签只扫描属性上的注解。
四个注解来创建对象@Component,@Controller（WEB层）,@Service（业务层）,@Repository（持久层）
@scope
使用@Autowired注解完成对象（先@Component）注入，或者带属性的@Resource

配置文件和注解混合使用：创建对象使用配置文件，注入属性用注解。

IOC用于创建对象和注入属性

3.分层
DAO层：jdbcTemplate
service层：IOC
web层：springMVC

4.MVC
Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。
通常模型对象负责在数据库中存取数据。

View（视图）是应用程序中处理数据显示的部分。
通常视图是依据模型数据创建的。

Controller（控制器）是应用程序中处理用户交互的部分。
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
@ResponseBody：返回给前端所要的数据类型json

Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。

流程：
第1步：浏览器发送指定的请求都会交给前端控制器DispatcherServlet,他会委托其他模块进行真正的业务和数据处理 
第2步：DispatcherServlet根据请求信息调用HandleMapping,解析请求对应的Handler（也就是Controller控制器），HandlerAdapter适配器会根据Handler来调用真正的处理器开处理请求
第3步：目标Controller处理完业务后，返回一个ModelAndView给DispatcherServlet 
第4步：DispatcherServlet通过ViewResolver视图解析器找到对应的视图对象View 
第5步：DispatcherServlet把返回的Model传给View（视图渲染），并返回到浏览器

5.bean的生命周期
实例化bean对象(通过构造方法或者工厂方法)
设置对象属性(setter等)（依赖注入）
如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）
如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身
将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization()
调用InitializingBean的afterPropertiesSet()
调用自定义的初始化方法
将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization()
使用Bean，将一直存在于应用上下文中，直到该应用上下文被销毁。
调用DisposableBean的destroy()
调用自定义的销毁方法

spring中bean生存的容器BeanFactory 、 ApplicationContext 、webApplicationContext 。应用上下文更好。

BeanDefinition：用来管理bean的属性和对象间的相互依赖关系

Bean创建的方法：xml、@Bean、@Component,@Controller（WEB层）,@Service（业务层）,@Repository（持久层）
@Bean：用在方法之上，产生一个Bean交给Spring容器管理

6.bean的作用域
@scope注解定义Bean的作用域。

singleton：IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。默认属性。
线程安全问题：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。
解决方法：在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中。

prototype：每次注入或者通过Spring应用上下文获取时，都会创建一个新的Bean实例。

session&request：web应用中，为每次会话或请求创建一个Bean实例。

7.注解
启动类@SpringBootApplication元注解：无实际功能
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited

@SpringbootConfiguration：
@ComponentScan：
@EnableAutoConfiguration：

@Enable开头的注解

那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。bean 就是由 IOC 容器初始化、装配及管理的对象。
@Bean注解通常是我们在标有该注解的方法中定义产生这个 bean
@Autowired 注解自动装配 bean
将一个类声明为Spring的 bean 的注解：
@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中
@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。
@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

@RequestMapping：处理请求地址映射
@ResponseBody：返回json数据。

8.Spring用到的设计模式
工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
代理设计模式 : Spring AOP 功能的实现。
单例设计模式 : Spring 中的 Bean 默认都是单例的。
模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

9.事务
事务管理:按照给定的事务规则来执行提交或者回滚操作。aop思想。
发生unchecked异常会发生rollback。只有非只读事务才能回滚。

Spring事务管理接口
PlatformTransactionManager：（平台）事务管理器，不同dao框架提供不同的实现类。
TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)
TransactionStatus：事务运行状态

编程式事务与声明式事务。声明式事务可以通过XML和注解实现。都需要先配置事务管理器。
实现方式
基于 TransactionInterceptor 的声明式事务
基于 TransactionProxyFactoryBean 的声明式事务
基于< tx> 和< aop>命名空间的声明式事务管理
基于 @Transactional 的全注解方式

xml方法：配置事务管理器<bean id="" class=""><property name="" ref=""></>、配置事务增强<tx:advice id="" transaction-manager=""><tx:attributes><tx:method name="" propagation=""/></>、配置切面<aop:config><aop:pointcut expression="" id=""><aop:advisor advice-ref="" pointcut-ref=""/></> 
注解方法：配置事务管理器、配置事务注解<tx:annotation-driven transaction-manager=""></>、方法上@Transactional

Spring 事务中的隔离级别多了ISOLATION_DEFAULT使用后端数据库默认的隔离级别。

Spring 事务传播行为
支持当前事务
TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
不支持当前事务
TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。
其他情况：TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

10.Mybatis
MyBatis 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。和Hibernate一样都是ORM对象关系映射，负责数据库和java对象之间的映射。区别是MyBatis自己控制SQL。

在Mybatis中我们可以定义一个叫做TypeHandler类型处理器的东西，通过它可以实现Java类型跟数据库类型的相互转换。

动态 sql 是 mybatis 的主要特性之一，在mybatis中我们可以把参数传到xml文件，由mybatis对sql及其语法进行解析，mybatis支持使用${}和#{}。
 # 和 $ 的区别：
使用${}方式传入的参数，mybatis不会对它进行特殊处理，而使用#{}传进来的参数，mybatis默认会将其当成字符串。所以对于传入分组(order)字段或者排序字段(order)，应使用${},避免出现order  by "id" 等情况。
#和$在预编译处理中是不一样的。#类似jdbc中的PreparedStatement，对于传入的参数，在预处理阶段会使用?代替，待真正查询的时候即在数据库管理系统中（DBMS）才会代入参数。而${}则是简单的替换。
由于PreparedStatement ，#{}可以有效防止sql注入，${}则可能导致sql注入成功。因此能使用#{}的地方应尽量使用#{}。

MyBatis的SQL建议写在XML里，或者写在注解里。
实现DAO接口：建议Mapper自动实现，只需给出DAO接口；或者API编程方式。

MyBatis XML 标签类型：
resultMap 标签的类型属性为 type（必填）。
id, result 标签的类型属性为javaType（可选）。
idArg, arg 标签和上面两个类似，也都是 javaType（可选）。
association 标签的类型属性为 javaType（可选）。
discriminator 标签的类型属性为 javaType（可选）。
collection 这个标签最特殊，有两个类型属性，分别为 javaType（可选） 和 ofType（结果映射时必填）。

11.springBoot Starter
starter会把所有用到的依赖都给包含进来，避免了开发者自己去引入依赖所带来的麻烦。stater机制帮我们完成了项目起步所需要的的相关jar包。
ConfigurationProperties和AutoConfiguration，application.properties 文件满足自定义配置。
利用starter实现自动化配置只需要两个条件——maven依赖、配置文件。

12.SSM三层架构和运行流程
View层：JSP/HTML页面发送请求，获取响应。
Controller层SpringMVC，接受请求并进行相应的流程处理。
Service层Spring：完成具体的业务逻辑
DAO层MyBatis：对数据库进行操作

13.jdbcTemplate
ORM持久化技术：JDBC、Hibernate、MyBatis、JPA，Spring都对其进行了封装Template模板类。
步骤：
导入jar包（数据库驱动的jar包）
创建对象，设置数据库信息
创建jdbcTemplate对象，设置数据源
调用jdbcTemplate对象里面的方法实现操作CRUD

jdbc查询操作：Connection conn,PreparedStatement psmt,ResultSet rs。

查询操作：
查询某一个值queryForObject
返回对象：自己写个类实现RowMapper接口完成数据封装

14SSH
Struts+Spring+Hibernate
对象关系映射ORM

Hibernate和Spring整合时，Hibernate核心配置文件和位置没有固定要求
Spring提供HibernateTemplate进行封装

Struts核心：Action、值栈、拦截器

Spring中s使用ServletContext对象和监听器
