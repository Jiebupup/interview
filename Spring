1.AOP
面向切面编程。代理模式。
横切关注点可以被描述为与业务无关，却为业务模块所共同调用的逻辑或责任。切面能帮助我们模块化横切关注点，便于减少系统的重复代码，降低模块间的耦合度，在系统运行时需要的地方进行动态插入运行。分离业务逻辑与系统服务，应用对象只完成业务逻辑。扩展功能。                                             
基于代理模式：JDK和CGLIB动态代理。JDK只能代理接口，CGLIB代理类。
ASPECTJ静态织入。

2.IOC
控制反转，或者叫DI依赖注入。DI不能单独存在，需要在IOC基础之上完成。工厂模式。
将对象之间的相互依赖关系交给IOC容器来管理，并由IOC容器完成对象的注入。Spring通过XML文件来配置Bean，SpringBoot使用注解配置。创建对象由Spring来管理。

xml方式
底层原理：xml配置文件，dom4j解决xml，工厂设计模式，反射。
<bean id=""class=""></bean>只需要变化这一部分来降低耦合,Class.forName(), .newInstance()。
IOC创建对象：1.导入jar包和引入约束，2.创建类和方法，3.写配置文件，4.ApplicationContext context=new ClassPathXmlApplicationContext(".xml")和context.getBean("")。

bean的实例化方法：用来创建对象，使用类的无参数构造方法。或者静态工厂和实例工厂。
bean标签属性：id,class（创建对象所在类的全路径）,name（可以包含特殊符号）,scope（bean的作用范围）。

属性注入：创建对象时向类里面属性设置值。
注入方法：set()property标签放注入对象，ref属性代替value属性。有参数构造方法constructor-arg标签。
p名称空间：xmlns:p=""，bean标签中加p:pname属性。用来注入复制属性array、list、map等，property内有多个value属性。

IOC容器的初始化过程：读取XML资源，解析，最终注册到Bean Factory中。
然后创建bean的实例，并利用反射注入property。

注解方式
使用在类、属性、方法之上。
开启包注解扫描context:component-scan标签，context:annotation-config标签只扫描属性上的注解。
四个注解来创建对象@Component,@Controller（WEB层）,@Service（业务层）,@Repository（持久层）
@scope
使用@Autowired注解完成对象（先@Component）注入，使用@Service。或者带属性的@Resource

配置文件和注解混合使用：创建对象使用配置文件，注入属性用注解。

3.分层
DAO层：jdbcTemplate
service层：IOC
web层：springMVC

4.MVC
Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。
通常模型对象负责在数据库中存取数据。

View（视图）是应用程序中处理数据显示的部分。
通常视图是依据模型数据创建的。

Controller（控制器）是应用程序中处理用户交互的部分。
通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
@ResponseBody：返回给前端所要的数据类型json

Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。

流程：
第1步：浏览器发送指定的请求都会交给前端控制器DispatcherServlet,他会委托其他模块进行真正的业务和数据处理 
第2步：DispatcherServlet根据请求信息调用HandleMapping,解析请求对应的Handler（也就是Controller控制器），HandlerAdapter适配器会根据Handler来调用真正的处理器开处理请求
第3步：目标Controller处理完业务后，返回一个ModelAndView给DispatcherServlet 
第4步：DispatcherServlet通过ViewResolver视图解析器找到对应的视图对象View 
第5步：DispatcherServlet把返回的Model传给View（视图渲染），并返回到浏览器

5.bean的生命周期
实例化bean对象(通过构造方法或者工厂方法)
设置对象属性(setter等)（依赖注入）
如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）
如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身
将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization()
调用InitializingBean的afterPropertiesSet()
调用自定义的初始化方法
将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization()
使用Bean，将一直存在于应用上下文中，直到该应用上下文被销毁。
调用DisposableBean的destroy()
调用自定义的销毁方法

spring中bean生存的容器BeanFactory 、 ApplicationContext 、webApplicationContext 。应用上下文更好。

BeanDefinition：用来管理bean的属性和对象间的相互依赖关系

6.bean的作用域
@scope注解定义Bean的作用域。

singleton：IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。默认属性。
线程安全问题：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。
解决方法：在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中。

prototype：每次注入或者通过Spring应用上下文获取时，都会创建一个新的Bean实例。

session&request：web应用中，为每次会话或请求创建一个Bean实例。

7.注解
启动类@SpringBootApplication元注解：无实际功能
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited

@SpringbootConfiguration：
@ComponentScan：
@EnableAutoConfiguration：

@Enable开头的注解

那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。bean 就是由 IOC 容器初始化、装配及管理的对象。
@Bean注解通常是我们在标有该注解的方法中定义产生这个 bean
@Autowired 注解自动装配 bean
将一个类声明为Spring的 bean 的注解：
@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中
@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。
@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

@RequestMapping：处理请求地址映射
@ResponseBody：返回json数据。

8.Spring用到的设计模式
工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
代理设计模式 : Spring AOP 功能的实现。
单例设计模式 : Spring 中的 Bean 默认都是单例的。
模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

9.事务

10.Mybatis
MyBatis 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。和Hibernate一样都是ORM对象关系映射，负责数据库和java对象之间的映射。区别是MyBatis自己控制SQL。

在Mybatis中我们可以定义一个叫做TypeHandler类型处理器的东西，通过它可以实现Java类型跟数据库类型的相互转换。

MyBatis的SQL建议写在XML里，或者写在注解里。
实现DAO接口：建议Mapper自动实现，只需给出DAO接口；或者API编程方式。

MyBatis XML 标签类型：
resultMap 标签的类型属性为 type（必填）。
id, result 标签的类型属性为javaType（可选）。
idArg, arg 标签和上面两个类似，也都是 javaType（可选）。
association 标签的类型属性为 javaType（可选）。
discriminator 标签的类型属性为 javaType（可选）。
collection 这个标签最特殊，有两个类型属性，分别为 javaType（可选） 和 ofType（结果映射时必填）。

11.springBoot Starter
starter会把所有用到的依赖都给包含进来，避免了开发者自己去引入依赖所带来的麻烦。stater机制帮我们完成了项目起步所需要的的相关jar包。
ConfigurationProperties和AutoConfiguration，application.properties 文件满足自定义配置。
利用starter实现自动化配置只需要两个条件——maven依赖、配置文件。
