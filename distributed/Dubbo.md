## 简介

Dubbo 是阿里巴巴公司开源的一个高性能&轻量级的 Java 分布式服务框架，通过 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。

它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。

SOA 面向服务架构。



## 1.RPC

远程过程调用协议 Remote Procedure Call Protocol，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。

让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。RPC 的目标是要把这些步骤都封装起来。

RPC 协议假定某些传输协议的存在，如 TCP/IP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨域了传输层和应用层。

采用客户端（服务调用方）/服务器端（服务提供方）模式，都运行在自己的 JVM 中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。

RPC 主要依赖的技术包括序列化、反序列化和数据传输协议，这是一种定义与实现相分离的设计。

**RPC 方案**

RMI（JDK 自带）、Dubbo、Motan、gRPC、Hessian、Thrift。

**RPC 和 HTTP **

如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应，这类框架并不能算是 RPC 框架，比如 Feign。 

RPC 调用是面向服务的封装，比 HTTP 调用提高了服务的可用性和效率等。

**RPC 和 RESTful** 

RPC 主要指内部服务之间的调用，RESTful 也可以用于内部服务之间的调用，但其主要用途还在于外部系统提供服务。

![rpc](/Users/wangjie/Desktop/面试知识点/pic/rpc1.png)

​																										最简单的 RPC 框架

#### RPC 调用过程

![rpc3](/Users/wangjie/Desktop/面试知识点/pic/rpc3.png)

​																										自己设计一个 RPC 框架



1. 客户端 client 以本地调用方式（即以接口的方式）调用服务。
2. 客户端存根 client stub 接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）。
3. 客户端通过 sockets 将消息发送到服务端。
4. 服务端存根 server stub 收到消息后进行解码（将消息对象反序列化）。
5. 服务端存根根据解码结果调用本地的服务。
6. 本地服务执行并将结果返回给服务端存根。
7. 服务端存根将返回结果打包成消息（将结果消息对象序列化）。
8. 服务端 server 通过 sockets 将消息发送到客户端。
9. 客户端存根接收到结果消息，并进行解码（将结果消息发序列化）。
10. 客户端得到最终结果。

#### 如何设计一个类似 Dubbo 的 RPC 框架

- 注册中心：推荐使用 Zookeeper。注册中心负责服务地址的注册与查找，相当于目录服务。服务端启动的时候将 ip+port 注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。

- 网络传输：既然要调用远程的方法就要发请求，请求中至少要包含调用的类名、方法名以及相关参数。推荐基于 NIO 的 Netty 框架。

- 序列化：既然涉及到网络传输就一定涉及到序列化，JDK 自带的序列化效率低并且有安全漏洞。比较常用的序列化协议有 hession2、kyro、protostuff。
- 动态代理：使用动态代理可以屏蔽远程方法调用的细节比如网络传输，也就是说当调用远程方法的时候，实际会通过代理对象来传输网络请求。
- 负载均衡：某个服务的访问量特别大，需要将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。负载均衡要做到正确选择处理该请求的服务器。避免单个服务器响应同一请求而造成的服务器宕机、崩溃等问题。

关键词：注册中心，动态代理，负载均衡，NIO，hessian。

#### 优化点

- 使用 Netty（基于 NIO）替代 BIO 实现网络传输。
- 使用开源的序列化机制 Kyro（也可以用其它的）替代 JDK 自带的序列化机制。
- 使用 Zookeeper 管理相关服务地址信息。
- Netty 重用 Channel 避免重复连接服务端。
- 使用 CompletableFuture 包装接受客户端返回结果（之前的实现是通过 AttributeMap 绑定到 Channel 上实现的） 详见：使用 CompletableFuture 优化接受服务提供端返回结果。
- 增加 Netty 心跳机制：保证客户端和服务端的连接不被断掉，避免重连。
- **客户端调用远程服务的时候进行负载均衡**：调用服务的时候，从很多服务地址中根据相应的负载均衡算法选取一个服务地址。ps：目前只实现了随机负载均衡算法。
- 处理一个接口有多个类实现的情况：对服务分组，发布服务的时候增加一个 group 参数即可。
- 集成 Spring 通过注解注册服务。
- 增加服务版本号：建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级。为什么要增加服务版本号？为后续不兼容升级提供可能，比如服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。
- 对 SPI 机制的运用。
- 增加可配置比如序列化方式、注册中心的实现方式，避免硬编码：通过 API 配置，后续集成 Spring 的话建议使用配置文件的方式进行配置。
- 使用注解进行服务消费。

客户端与服务端通信协议（数据包结构）重新设计，将原有的 RpcRequest 和 RpcReuqest 对象作为消息体，然后增加如下字段（可以参考：《Netty 入门实战小册》和 Dubbo 框架对这块的设计）：

- 魔数： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。
- 序列化器编号：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。
- 消息体长度： 运行时计算出来。
- ......
- 编写测试为重构代码提供信心。



## 2.工作原理

#### 核心功能

- 远程通讯：提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
- 集群容错：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
- 自动发现：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

#### 特性

- 负载均衡：同一个服务部署在不同的机器时该调用那一台机器上的服务。
- 服务调用链路生成：解决服务之间互相是如何调用的。
- 服务访问压力以及时长统计、资源调度和治理：基于访问压力实时管理集群容量，提高集群利用率。
- 服务降级：某个服务挂掉之后调用备用服务。

#### 节点角色

<img src="/Users/wangjie/Desktop/面试知识点/pic/rpc2.png" alt="rpc2" style="zoom:67%;" />

​																										Dubbo 架构图



Provider：暴露服务的服务提供方。

Container：服务运行容器。

Consumer：调用远程服务的服务消费方。

Registry：服务注册与发现的注册中心。

Monitor：统计服务的调用次数和调用时间的监控中心。

#### 调用关系

服务容器负责启动，加载，运行服务提供者。

服务提供者在启动时，向注册中心 Zookeeper 注册自己提供的服务。

服务消费者在启动时，向注册中心订阅自己所需的服务。

注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。

服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。

服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

#### Dubbo 架构的特点

连通性、健壮性、伸缩性、以及向未来架构的升级性。

**连通性**

注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。

监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示。

服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销。

服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销。

注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外。

注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。

注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。

注册中心和监控中心都是可选的，服务消费者可以*<u>直连</u>*服务提供者。

**健壮性**

监控中心宕掉不影响使用，只是丢失部分采样数据
数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
注册中心对等集群，任意一台宕掉后，将自动切换到另一台
注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
服务提供者无状态，任意一台宕掉后，不影响使用
服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

**伸缩性**

注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心
服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者

**升级性**

当服务集群规模进一步扩大，带动 IT 治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。

#### 分层

service、config、proxy、registry、cluster、monitor、protocal、exchange、transport、serialize，从下至上各层均为单向依赖，每一层都可以剥离上层被复用。Service 和 Config 层为 API，其它各层均为 SPI。

#### zookeeper 宕机

假如 zookeeper 注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，因为提供者的地址等信息被拉取到了本地缓存，是 dubbo 健壮性的一种提现。

#### Dubbo 直连

注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。所以，我们可以完全可以绕过注册中心——采用 dubbo 直连 ，即在服务消费方配置服务提供方的位置信息。



## 3.通信和传输协议

#### Dubbo 协议

默认走 Dubbo 通信协议，采用 NIO 复用单一长连接（建立连接过后可以持续发送请求，无须再建立连接），并使用线程池并发处理请求，减少握手和加大并发效率，性能较好。

使用场景：传输数据量小（每次请求在 100kb 以内），但是并发量很高。

#### Hessian 协议

默认走 Hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。

#### RMI 协议

走 Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。

#### HTTP 协议

走 JSON 序列化。

#### webservice

走 SOAP 文本序列化。

#### Protocol Buffer

Protocol Buffer 其实是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 JSON、XML 要高很多。

**PB 性能好的原因**

- 使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍。
- 数据压缩效果好，序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。



## 4.负载均衡策略和集群容错策略、动态代理策略

#### 负载均衡策略

**random load balance**

默认情况下，Dubbo 是 random load balance ，即随机调用实现负载均衡，可以对 provider 不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。按概率动态调整权重。

**roundrobin loadbalance**

这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。

**leastactive loadbalance**

这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求。

**consistanthash loadbalance**

一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。

#### 集群容错策略

**failover cluster 模式**

失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。（失败重试其它机器）

**failfast cluster 模式**

一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）

**failsafe cluster 模式**

出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。

**failback cluster 模式**

失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。

**forking cluster 模式**

并行调用多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源

**broadcacst cluster 模式**

逐个调用所有的 provider。任何一个 provider 出错则报错（从 2.1.0 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。

#### 动态代理策略

默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。



## 5.spi 思想

service provider interface，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。spi 机制一般用在插件扩展的场景。

Java spi 经典的思想体现，大家平时都在用，比如说 jdbc。Java 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。在系统跑的时候，会在底层使用你引入的那个 jar 中提供的实现类。

Dubbo Protocol 接口，在系统运行的时候，Dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。如果你没配置，那就走默认的实现。

@SPI("dubbo") 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的。如果想要动态替换掉默认的实现类，需要使用 @Adaptive 接口。

如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key=实现类。然后对于对应的组件，类似 <dubbo: protocol> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 Dubbo 的各种功能，提供你自己的实现。



## 6.服务治理、服务降级、失败重试以及超时重试

#### 服务治理

对复杂微服务：

- 调用链路自动生成：对各个服务之间的调用自动记录下来，然后自动将各个服务之间的依赖关系和调用链路生成出来
- 服务访问压力以及时长统计：自动统计各个接口和服务之间的调用次数以及访问延时，可以来看当前系统的压力主要在哪里，如何来扩容和优化
- 其他：服务分层（避免循环依赖），调用链路失败监控和报警，服务鉴权，每个服务的可用性的监控（接口调用成功率）

#### 服务降级

比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。

#### 失败重试和超时重试

由于网络问题，设置 timeout 和 retries 参数。
