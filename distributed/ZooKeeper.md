## 简介

ZooKeeper 为大型分布式计算提供开源的分布式配置服务、同步服务、命名注册、数据一致性解决方案、数据发布/订阅、负载均衡、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

ZooKeeper 曾经是 Hadoop 的一个子项目，现在是一个独立的顶级项目。

ZooKeeper 底层其实只提供了两个功能：管理（存储、读取）用户程序提交的数据，为用户程序提供数据节点监听服务。



## 1.特点

#### 简单的数据模型

ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。

名称空间由 ZooKeeper 中的数据寄存器 znode 组成，这些类似于文件和目录。

与为存储设计的典型文件系统不同，ZooKeeper 数据保存在内存中，这意味着 ZooKeeper 可以实现高吞吐量和低延迟。

#### 高可用

集群部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。 

客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个 TCP 链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。

组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议来保持数据的一致性。

#### 顺序一致性

从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。

对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳 ZXID。

#### 原子性

所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。

#### 单一系统映像

无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。

#### 可靠性

一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。

#### 高性能

ZooKeeper 将数据保存在内存中，在读多于写的应用程序中尤其地高性能，因为写会导致所有的服务器间同步状态，读多于写是协调服务的典型场景。



## 2.使用场景

#### 注册中心

ZooKeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心，提供发布订阅服务。

服务生产者将自己提供的服务注册到 ZooKeeper，服务的消费者在进行服务调用的时候先到 ZooKeeper 中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。

#### 分布式协调

A 系统发送请求之后可以在 ZooKeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 ZooKeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。

#### 分布式锁

一个机器接收到了请求之后先获取 ZooKeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。

通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。

#### 元数据/配置信息管理

ZooKeeper 可以用作很多系统的配置信息的管理，比如 Kafka、Storm 等等很多分布式系统都会选用 ZooKeeper 来做一些元数据、配置信息的管理，还包括 Dubbo 的注册中心和 Solr 集群的管理工具。还为 Hbase 和 Hadoop 提供了服务。

#### 高可用性 HA

hadoop、hdfs、yarn 等很多大数据系统，都选择基于 ZooKeeper 来开发 HA 高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过 ZooKeeper 感知到切换到备用进程。

#### 命名服务

可以通过 ZooKeeper 的顺序节点生成全局唯一 ID

#### **数据发布/订阅**

通过 Watcher 机制可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。



## 3.组件

#### 数据节点 znode

**数据模型**

数据模型采用层次化的多叉树形结构，由斜杠 / 的进行分割的路径，数据节点被称为 znode，例如 /foo/path1。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。

每个 znode 由状态信息 stat 和节点存放的数据的具体内容 data 组成。

**版本**

stat 中记录了这个 znode 的三个数据版本，分别是当前 znode 的版本 dataVersion、当前 znode 子节点的版本 cversion 和当前 znode 的 ACL 版本 aversion。

**权限控制 ACL**

类似于 UNIX 文件系统的权限控制，CREATE，READ，WRITE，DELETE，ADMIN 五种权限。其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对子节点的权限控制。

**内存**

ZooKeeper 将所有数据存储在内存中，保证了高吞吐量和低延迟。

ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上

**持久节点**

一旦持久节点被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。

**临时节点**

临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。

临时节点只能做叶子节点，不能创建子节点。

ZooKeeper 还允许用户为每个节点添加一个特殊的属性 SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。

#### **身份认证**

- **world**：默认方式，所有用户都可无条件访问。
- **auth**：不使用任何 id，代表任何已认证的用户。
- **digest**：username:password。
- **ip**：对指定 ip 进行限制。

#### 事件监听器 watcher

是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。

**事件**

节点创建、节点删除、节点数据修改和子节点变更。

#### ZooKeeper 服务器与客户端会话 session

在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。

客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。

通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 watch 事件通知。

**sessionTimeout**

设置一个客户端会话的超时时间。

当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。

**sessionID**

是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。



## 4.集群

ZooKeeper 本身就是一个分布式程序，只要半数以上节点存活，ZooKeeper 就能正常服务。

为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。

#### ZAB 协议

ZooKeeper Atomic Broadcast，是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。

在 ZooKeeper 中，集群间通过 ZAB 协议来保持数据的一致性。主备模式的系统架构

ZAB 协议包括两种基本的模式，分别是崩溃恢复和消息广播。

**拜占庭将军问题**

指在不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以所有的一致性算法的必要前提就是安全可靠的消息通道。

**Paxos 算法**

通用的分布式一致性算法。应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法。

Paxos 算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致 。

#### master/slave 主备模式

最典型集群模式。master 服务器作为主服务器提供写服务，其他的 slave 服务器从服务器通过异步复制的方式获取 master 服务器最新的数据提供读服务。

在 ZooKeeper 中没有选择传统的 master/slave 概念，而是引入了 leader、follower 和 observer 三种角色。

**leader**

ZooKeeper 集群中的所有机器选举产生 leader。leader 既可以为客户端提供写服务又能提供读服务。除了 leader 外，follower 和 observer 都只能提供读服务。

ZooKeeper 集群中的服务器状态 LOOKING：寻找 Leader。

只允许唯一的一个 leader 服务器来进行事务请求的处理。leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。而如果集群中的其他机器接收到客户端的事务请求，那么这些非 leader 服务器会首先将这个事务请求转发给 leader 服务器。

**follower 和 observer**

follower 和 observer 唯一的区别在于 observer 机器不参与 leader 的选举过程，也不参与写操作的过半写成功策略，因此 observer 机器可以在不影响写性能的情况下提升集群的读性能。

**恢复模式**

当 leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的 leader 服务器。

1. 选举阶段 election：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。

2. 发现阶段 discovery：在这个阶段，follower 跟准 leader 进行通信，同步 follower 最近接收的事务提议。

3. 同步阶段 synchronization：同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后，准 leader 才会成为真正的 leader。

4. 广播阶段 broadcast：当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的数据同步，进入这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步，然后一起参与到消息广播流程中去。

#### 集群为啥最好奇数台？

ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。

2n 和 2n-1 的容忍度都是 n-1，不必增加那一个不必要的 ZooKeeper。