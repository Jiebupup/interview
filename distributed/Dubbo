1.简介
Dubbo 是阿里巴巴公司开源的一个高性能分布式服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。
Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。SOA 面向服务架构。

2.RPC
远程过程调用协议 Remote Procedure Call Protocol，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
RPC 协议假定某些传输协议的存在，如 TCP/IP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨域了传输层和应用层。RPC 使得开发分布式程序就像开发本地程序一样简单。
采用客户端（服务调用方）/服务器端（服务提供方）模式，都运行在自己的 JVM 中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。
RPC 主要依赖的技术包括序列化、反序列化和数据传输协议，这是一种定义与实现相分离的设计。
RPC 主要指内部服务之间的调用，RESTful 也可以用于内部服务之间的调用，但其主要用途还在于外部系统提供服务。

RPC 方案：RMI（JDK 自带）、Dubbo、Hessian、Thrift、gRPC。
良好的 RPC 调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用 HTTP 调用则缺少了这些特性。
成熟的 RPC 框架还提供服务自动注册与发现、智能负载均衡、可视化的服务治理和运维、运行期流量调度等等功能。

RPC 调用过程：
客户端 client 以本地调用方式（即以接口的方式）调用服务；
客户端存根 client stub 接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；
客户端通过 sockets 将消息发送到服务端；
服务端存根 server stub 收到消息后进行解码（将消息对象反序列化）；
服务端存根根据解码结果调用本地的服务；
本地服务执行并将结果返回给服务端存根；
服务端存根将返回结果打包成消息（将结果消息对象序列化）；
服务端 server 通过 sockets 将消息发送到客户端；
客户端存根接收到结果消息，并进行解码（将结果消息发序列化）；
客户端得到最终结果。

RPC 主要解决了：让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。RPC 的目标是要把这些步骤都封装起来。

3.工作原理
核心功能
远程通讯: 提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

特性
负载均衡：同一个服务部署在不同的机器时该调用那一台机器上的服务。
服务调用链路生成：解决服务之间互相是如何调用的。
服务访问压力以及时长统计、资源调度和治理：基于访问压力实时管理集群容量，提高集群利用率。
服务降级：某个服务挂掉之后调用备用服务。

节点角色
Provider：暴露服务的服务提供方。
Consumer：调用远程服务的服务消费方。
Registry：服务注册与发现的注册中心。
Monitor：统计服务的调用次数和调用时间的监控中心。
Container：服务运行容器。

调用关系：
服务容器负责启动，加载，运行服务提供者。
服务提供者在启动时，向注册中心（Zookeeper）注册自己提供的服务。
服务消费者在启动时，向注册中心订阅自己所需的服务。
注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。

连通性
注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小
监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示
服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销
服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销
注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外
注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者
注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表
注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

健壮性
监控中心宕掉不影响使用，只是丢失部分采样数据
数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
注册中心对等集群，任意一台宕掉后，将自动切换到另一台
注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
服务提供者无状态，任意一台宕掉后，不影响使用
服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

伸缩性
注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心
服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者

升级性
当服务集群规模进一步扩大，带动 IT 治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。

分层：service、config、proxy、registry、cluster、monitor、protocal、exchange、transport、serialize，从下至上各层均为单向依赖，每一层都可以剥离上层被复用。Service 和 Config 层为 API，其它各层均为 SPI。

zookeeper 宕机：假如 zookeeper 注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，因为提供者的地址等信息被拉取到了本地缓存，是 dubbo 健壮性的一种提现。
dubbo 直连：注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。所以，我们可以完全可以绕过注册中心——采用 dubbo 直连 ，即在服务消费方配置服务提供方的位置信息。

4.通信协议和序列化协议
dubbo 支持多种通信协议：
默认就是走 dubbo 协议：采用 NIO 复用单一长连接（建立连接过后可以持续发送请求，无须再建立连接），并使用线程池并发处理请求，减少握手和加大并发效率，性能较好。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。
rmi 协议：走 Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。
hessian 协议：走 hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。
http 协议：走 json 序列化。
webservice：走 SOAP 文本序列化。

dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。但是 hessian 是其默认的序列化协议。

Protocol Buffer 其实是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 JSON、XML 要高很多。
其实 PB 之所以性能如此好，主要得益于两个：第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍；第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。

5.负载均衡策略和集群容错策略、动态代理策略
负载均衡策略：
默认情况下，dubbo 是 random load balance ，即随机调用实现负载均衡，可以对 provider 不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。按概率动态调整权重。
roundrobin loadbalance：这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。
leastactive loadbalance：这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求。
consistanthash loadbalance：一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。

集群容错策略：
failover cluster 模式：失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。（失败重试其它机器）
failfast cluster 模式：一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）
failsafe cluster 模式：出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。
failback cluster 模式：失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。
forking cluster 模式：并行调用多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源
broadcacst cluster 模式：逐个调用所有的 provider。任何一个 provider 出错则报错（从 2.1.0 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。

动态代理策略：
默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。

6.spi 思想
service provider interface，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。spi 机制一般用在插件扩展的场景。
Java spi 经典的思想体现，大家平时都在用，比如说 jdbc。Java 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。在系统跑的时候，会在底层使用你引入的那个 jar 中提供的实现类。

dubbo Protocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。如果你没配置，那就走默认的实现。
@SPI("dubbo") 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的。如果想要动态替换掉默认的实现类，需要使用 @Adaptive 接口。
如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key=实现类。然后对于对应的组件，类似 <dubbo:protocol> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。

7.服务治理、服务降级、失败重试以及超时重试
服务治理：对复杂微服务
（1）调用链路自动生成：对各个服务之间的调用自动记录下来，然后自动将各个服务之间的依赖关系和调用链路生成出来
（2）服务访问压力以及时长统计：自动统计各个接口和服务之间的调用次数以及访问延时，可以来看当前系统的压力主要在哪里，如何来扩容和优化
（3）其他：服务分层（避免循环依赖），调用链路失败监控和报警，服务鉴权，每个服务的可用性的监控（接口调用成功率）

服务降级：比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。

失败重试和超时重试：由于网络问题，设置 timeout 和 retries 参数。

8.如何保持幂等性
幂等性就是一个接口，多次发起同一个请求，必须保证操作只能执行一次。

对于每个请求必须有一个唯一的标识，如订单号。
每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 MySQL 中记录个状态。
每次接收请求需要进行判断，判断之前是否处理过，可以使用唯一键约束。
只有成功插入这个支付流水，才可以执行实际的支付扣款。

9.顺序性
一旦引入顺序性保障，比如使用分布式锁，会导致系统复杂度上升，而且会带来效率低下，热点数据压力过大等问题。
从业务逻辑上设计的这个系统最好是不需要这种顺序性的保证，将多个操作合并成一个操作。

将某个订单 id 对应的请求扔一个内存队列里去，强制排队，这样来确保他们的顺序性。

10.如何设计一个类似 Dubbo 的 RPC 框架
服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信息，可以用 zookeeper 来做。
消费者需要去注册中心拿对应的服务信息吧，而且每个服务可能会存在于多台机器上。
接着就该发起一次请求了，基于动态代理，面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址。
有个负载均衡算法完成找想找的机器发送请求。
用 netty 了，nio 方式发送请求，用 hessian 序列化协议发送相应格式的数据。
服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码。

关键词：注册中心，动态代理，负载均衡，NIO，hessian。

11.系统拆分
拆分系统将项目分为多个服务，每个人负责每个人的部分，每个服务都独立部署，提高开发效率
先拆分一轮，后面如果系统更复杂了，可以继续分拆。
http 接口通信维护起来成本很高，你要考虑超时重试、负载均衡等等各种乱七八糟的问题。dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡、服务实例上下线自动感知、超时重试等等乱七八糟的问题。那你就不用自己做了，用 dubbo 就可以了。
