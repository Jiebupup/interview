1.简介
Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。
Spring Cloud 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。
阿里开源的 Spring Cloud Alibaba 是 Spring Cloud 规范的实现。Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。

2.微服务架构
描述了将软件应用程序设计为若干个可独立部署的服务套件的特定方法。
微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的进程中运行，并以轻量级机制（通常是 HTTP 资源 API）进行通信。这些服务围绕业务功能构建，可通过全自动部署机制来独立部署。这些服务共用一个最小型的集中式管理，它们可以使用不同的编程语言编写，并使用不同的数据存储技术。
微服务架构风格：将应用程序构建为服务套件。除了服务可独立部署、独立扩展的事实之外，每个服务还提供了一个牢固的模块边界，甚至允许以不同的编程语言编写不同的服务。他们也可以由不同的团队管理。

3.特征
通过服务进行组件化
围绕业务能力进行组织
去中心化的治理
分散数据管理
基建自动化
设计时为故障做好准备

4.单体式迁移到微服务
应该采取逐步迁移单体式应用的策略，通过逐步生成微服务新应用，与旧的单体式应用集成，随着时间推移，单体式应用在整个架构中比例逐渐下降直到消失或者成为微服务架构一部分。
策略 1——停止挖掘
策略 2——将前端和后端分离
策略 3——抽出服务

5.微服务和分布式数据管理问题
在微服务架构中，每个微服务都有自己私有的数据集。不同微服务可能使用不同的 SQL 或者 NoSQL 数据库。
尽管数据库架构有很强的优势，但是也面对数据分布式管理的挑战。第一个挑战就是如何在多服务之间维护业务交易一致性；第二个挑战是如何从多服务环境中获取一致性数据。
最佳解决办法是采用事件驱动架构。其中碰到的一个挑战是如何原子性的更新状态和发布事件。有几种方法可以解决此问题，包括将数据库视为消息队列、交易日志挖掘和事件源。

6.Dubbo 和 Spring Cloud 的关系
未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。
在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。我们后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。

7.服务发现 Eureka
Eureka 是基于表现层状态转换 REST 的服务，主要在 AWS 云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为 Eureka 服务器。Eureka 还带有一个基于 Java 的客户端组件 Eureka Client，它使与服务的交互变得更加容易。
客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。
在 Netflix，更复杂的负载均衡器将 Eureka 包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。

角色：服务提供者 Eureka Client Provider、消费者、中介 Eureka Server（服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者）。
服务提供者
服务注册 Register：当 Eureka Client Provider 向 Eureka Server 注册时（REST 请求），它提供自身的元数据 metaData，比如 IP 地址、端口，运行状况指示符 URL，主页等。
服务续约 Renew：Eureka 客户会每隔 30 秒(默认情况下)发送一次心跳来续约。通过续约来告知 Eureka Server 该 Eureka 客户仍然存在，没有出现问题。正常情况下，如果 Eureka Server 在 90 秒没有收到 Eureka 客户的续约，它会将实例从其注册表中删除（服务剔除 Eviction）。
服务同步：两个服务提供者分别注册到了两个不同的服务注册中心上，信息分别被两个服务注册中心所维护。此时，由于服务注册中心之间因互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取到。

服务消费者
获取注册列表信息 Fetch Registries：
Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。
该注册列表信息定期（每 30 秒钟）更新一次。每次返回注册列表信息可能与 Eureka 客户端的缓存信息不同，Eureka 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka 客户端则会重新获取整个注册表信息。
Eureka 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。
Eureka 客户端和 Eureka 服务器可以使用 JSON/XML 格式进行通讯。在默认的情况下 Eureka 客户端使用压缩 JSON 格式来获取注册列表的信息。
对于访问实例的选择，Eureka 中有 Region 和 Zone 的概念，一个 Region 中可以包含多个 Zone，每个服务客户端需要被注册到一个 Zone 中，所以每个客户端对应一个 Region 和一个 Zone。在进行服务调用的时候，优先访问同处一个一个 Zone 中的服务提供方，若访问不到，就访问其他的 Zone。

服务下线 Cancel：Eureka 客户端在程序关闭时向 Eureka 服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除，并把该下线事件传播出去。该下线请求不会自动完成。

服务注册中心
失效剔除：Eureka Server 在启动的时候会创建一个定时任务，默认每隔一段时间（默认为 60 秒）将当前清单中超时（默认为 90 秒）没有续约的服务剔除出去。
自我保护：
Eureka Server 在运行期间，会统计心跳失败的比例在 15 分钟之内是否低于 85%，如果出现低于的情况，Eureka Server 会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。
但是，在这段保护期间内实例若出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败的情况，所以客户端必须要有容错机制，比如可以使用请求重试、断路器等机制。

可以充当服务发现的组件有很多：Zookeeper，Consul，Eureka 等。

8.负载均衡 Ribbon
Ribbon 是 Netflix 公司的一个开源的负载均衡项目，是一个客户端/进程内负载均衡器，运行在消费者端。
其工作原理就是 Consumer 端获取到了所有的服务列表之后，在其内部使用负载均衡算法，进行对多个系统的调用。
Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡器，需要和 Eureka 配合。

Nginx 和 Ribbon 的对比：
Nignx 和 Ribbon 不同的是，它是一种集中式的负载均衡器。将所有请求都集中起来，然后再进行负载均衡。
Nginx 中请求是先进入负载均衡器，而在 Ribbon 中是先在客户端进行负载均衡才进行请求的。

Ribbon 中有更多的负载均衡调度算法，其默认是使用的 RoundRobinRule 轮询策略。还有 RandomRule 随机策略和 RetryRule 重试策略。
在 Ribbon 中你还可以自定义负载均衡算法，你只需要实现 IRule 接口，然后修改配置文件或者自定义 Java Config 类。

通过 Spring Cloud Ribbon 的封装，我们在微服务架构中使用客户端负载均衡调用只需要如下两步：
服务提供者只需要启动多个服务实例并且注册到一个注册中心或是多个相关联的服务注册中心。
服务消费者直接通过调用被 @LoadBalanced 注解修饰过的 RestTemplate 来实现面向服务的接口调用。

9.Feign
Feign 的关键机制是使用了动态代理。
RestTemplate 是 Spring 提供的一个访问 Http 服务的客户端类，微服务之间的调用是使用的 RestTemplate。Eureka 框架中的注册、续约等，底层都是使用的 RestTemplate。
每次都调用 RestRemplate 的 API 太麻烦，可以将被调用的服务代码映射到消费者端，就是 Open Feign。
Open Feign 也是运行在消费者端的，使用 Ribbon 进行负载均衡，所以 Open Feign 直接内置了 Ribbon。

Feign 是和 Ribbon 以及 Eureka 紧密协作的：
首先 Ribbon 会从 Eureka Client 里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口。
然后 Ribbon 就可以使用默认的 Round Robin 算法，从中选择一台机器。
Feign 就会针对这台机器，构造并发起请求。

10.Zuul
Zuul 是从设备和 web 站点到 Netflix 流应用后端的所有请求的前门。作为边界服务应用，Zuul 是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个亚马逊自动缩放组（亚马逊的一种云计算方式）的能力。
网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行鉴权、限流、 路由、监控等功能。
Zuul中最关键的功能：路由和过滤器。
Zuul 首先需要向 Eureka 进行注册，能拿到所有 Consumer 的信息如元数据(名称，ip，端口)来进行路由映射。对于路由规则的维护，Zuul 默认会将通过以服务名作为 ContextPath 的方式来创建路由映射。
过滤：能实现限流，灰度发布，权限控制等等。对微服务接口的拦截和校验。
Zuul 作为网关肯定也存在单点问题，如果我们要保证 Zuul 的高可用，我们就需要进行 Zuul 的集群配置，这个时候可以借助额外的一些负载均衡器比如 Nginx。

11.配置管理 Config
既能对配置文件统一地进行管理，又能在项目运行时动态修改配置文件。
Spring Cloud Config 为分布式系统中的外部化配置提供服务器和客户端支持。使用 Config服务器，可以在中心位置管理所有环境中应用程序的外部属性。
Spring Cloud Config 就是能将各个应用/系统/模块的配置文件存放到统一的地方然后进行管理(Git 或者 SVN)。
启动的时候才会进行配置文件的加载，那么我们的 Spring Cloud Config 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。
Webhooks，这是 github 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。
使用 Bus 消息总线 + Spring Cloud Config 进行配置的动态刷新。
Spring Cloud Bus：用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。
Spring Cloud Bus 的作用就是管理和广播分布式系统中的消息，也就是消息引擎系统中的广播模式。当然作为消息总线的 Spring Cloud Bus 可以做很多事而不仅仅是客户端的配置刷新功能。
拥有了 Spring Cloud Bus 之后，我们只需要创建一个简单的请求，并且加上 @ResfreshScope 注解就能进行配置的动态修改了。
