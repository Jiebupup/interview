1.简介
在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务。
Hystrix 可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。
Hystrix 通过将依赖服务进行资源隔离，进而阻止某个依赖服务出现故障时在整个系统所有的依赖服务调用中进行蔓延；同时Hystrix 还提供故障时的 fallback 降级机制。
总而言之，Hystrix 通过这些方法帮助我们提升分布式系统的可用性和稳定性。

2.设计原则
对依赖服务调用时出现的调用延迟和调用失败进行控制和容错保护。
在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延。比如某一个服务故障了，导致其它服务也跟着故障。Hystrix 可以对其进行资源隔离。
提供 fail-fast（快速失败）和快速恢复的支持。
提供 fallback 优雅降级的支持。
支持近实时的监控、报警以及运维操作。

阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。
避免请求排队和积压，采用限流和 fail fast 来控制故障。
提供 fallback 降级机制来应对故障。
使用资源隔离技术，比如 bulkhead（舱壁隔离技术）、swimlane（泳道技术）、circuit breaker（断路技术）来限制任何一个依赖服务的故障的影响。
通过近实时的统计/监控/报警功能，来提高故障发现的速度。
通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度。
保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。

3.Hystrix 底层的执行流程
Hystrix 最基本的支持高可用的技术：资源隔离 + 限流
创建 command
调用 command 执行方法
检查是否开启缓存 request cache
检查是否开启了断路器 circuit breaker
检查线程池/队列/信号量是否已满
执行 command
断路健康检查
调用 fallback 降级机制

基于 request cache 请求缓存技术优化批量商品数据查询接口：
在一次请求上下文中，如果有多个 command，参数都是一样的，调用的接口也是一样的，而结果可以认为也是一样的。那么这个时候，我们可以让第一个 command 执行返回的结果缓存在内存中，然后这个请求上下文后续的其它对这个依赖的调用全部从内存中取出缓存结果就可以了。
这样的话，好处在于不用在一次请求上下文中反复多次执行一样的 command，避免重复执行网络请求，提升整个请求的性能。
HystrixCommand 和 HystrixObservableCommand 都可以指定一个缓存 key，然后 Hystrix 会自动进行缓存，接着在同一个 request context 内，再次访问的话，就会直接取用缓存。

fallback 优雅降级、circuit breaker 断路器快速熔断。

Hystrix 通过判断线程池或者信号量是否已满，超出容量的请求，直接 Reject 走降级，从而达到限流的作用。
限流是限制对后端的服务的访问量，比如说你对 MySQL、Redis、Zookeeper 以及其它各种后端中间件的资源的访问的限制，其实是为了避免过大的流量直接打死后端的服务。
信号量实现对某个依赖服务的并发访问量的限制，线程池通过线程池/队列的大小来限制流量。信号量可以用来限流和削峰，但是不能用来对调用延迟的服务进行 timeout 和隔离。

基于 timeout 机制为服务接口调用超时提供安全保护：
一般来说，在调用依赖服务的接口的时候，比较常见的一个问题就是超时。超时是在一个复杂的分布式系统中，导致系统不稳定，或者系统抖动。出现大量超时，线程资源会被 hang 死，从而导致吞吐量大幅度下降，甚至服务崩溃。
在 Hystrix 中，我们可以手动设置 timeout 时长，如果一个 command 运行时间超过了设定的时长，那么就被认为是 timeout，然后 Hystrix command 标识为 timeout，同时执行 fallback 降级逻辑。

Sentinel 和 Hystrix：
Sentinel 是阿里中间件团队研发的面向分布式服务架构的轻量级高可用流量控制组件，于 2018 年 7 月正式开源。Sentinel 主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户提升服务的稳定性。
Hystrix 的关注点在于以隔离和熔断为主的容错机制，超时或被熔断的调用将会快速失败，并可以提供 fallback 机制。
而 Sentinel 的侧重点在于：多样化的流量控制、熔断降级、系统负载保护、实时监控和控制台。
Sentinel 特性：轻量级、高性能，流量控制，系统负载保护，实时监控和控制面板，生态良好。

4.资源隔离
要把对某一个依赖服务的所有调用请求，全部隔离在同一份资源池内，不会去用其它资源了。
避免说对某一个依赖服务的调用，因为依赖服务的接口调用的延迟或者失败，导致服务所有的线程资源全部耗费在这个服务的接口调用上。
Hystrix 进行资源隔离，其实是提供了一个抽象，叫做 command。这也是 Hystrix 最最基本的资源隔离技术。
Hystrix 采用了 Bulkhead Partition 舱壁隔离技术，来将外部依赖进行资源隔离，进而避免任何外部依赖的故障导致本服务崩溃。

小型电商网站的商品详情页系统架构：小型电商网站的页面展示采用页面全量静态化的思想。数据库中存放了所有的商品信息，页面静态化系统，将数据填充进静态模板中，形成静态化页面，推入 Nginx 服务器。用户浏览网站页面时，取用一个已经静态化好的 html 页面，直接返回回去，不涉及任何的业务逻辑处理。
好处在于，用户每次浏览一个页面，不需要进行任何的跟数据库的交互逻辑，也不需要执行任何的代码，直接返回一个 html 页面就可以了，速度和性能非常高。对于小网站，页面很少，很实用，非常简单，Java 中可以使用 velocity、freemarker、thymeleaf 等等，然后做个 cms 页面内容管理系统，模板变更的时候，点击按钮或者系统自动化重新进行全量渲染。
坏处在于，对于一些大型的电商网站，亿级数量的页面，你说你每次页面模板修改了，都需要将这么多页面全量静态化，每次渲染花的时间太多。

大型电商网站的商品详情页系统架构：当商品数据发生变更时，会将变更消息压入 MQ 消息队列中。缓存服务从消息队列中消费这条消息时，感知到有数据发生变更，便通过调用数据服务接口，获取变更后的数据，然后将整合好的数据推送至 redis 中。Nginx 本地缓存的数据是有一定的时间期限的，比如说 10 分钟，当数据过期之后，它就会从 redis 获取到最新的缓存数据，并且缓存到自己本地。用户浏览网页时，动态将 Nginx 本地数据渲染到本地 html 模板并返回给用户。
虽然没有直接返回 html 页面那么快，但是因为数据在本地缓存，所以也很快，其实耗费的也就是动态渲染一个 html 页面的性能。如果 html 模板发生了变更，不需要将所有的页面重新静态化，也不需要发送请求，没有网络请求的开销，直接将数据渲染进最新的 html 页面模板后响应即可。

商品接口服务故障导致缓存服务资源耗尽：
如果系统访问量很高，Nginx 本地缓存过期失效了，redis 中的缓存也被 LRU 算法给清理掉了，那么会有较高的访问量，从缓存服务调用商品服务。
但如果此时商品服务的接口发生故障，调用出现了延时，缓存服务全部的线程都被这个调用商品服务接口给耗尽了，每个线程去调用商品服务接口的时候，都会卡住很长时间，后面大量的请求过来都会卡在那儿，此时缓存服务没有足够的线程去调用其它一些服务的接口，从而导致整个大量的商品详情页无法正常显示。      
 
从 Nginx 开始，缓存都失效了，Nginx 会直接通过缓存服务调用商品服务获取最新商品数据，有可能出现调用延时而把缓存服务资源耗尽的情况。此时需要通过资源隔离保证系统的高可用性。

默认情况下，Hystrix 使用线程池模式：
利用 HystrixCommand 获取单条数据：我们通过将调用商品服务的操作封装在 HystrixCommand 中，限定一个 key，在这里我们可以简单认为这是一个线程池，每次调用商品服务，就只会用该线程池中的资源，不会再去用其它线程资源了。
利用 HystrixObservableCommand 批量获取数据：只要是获取商品数据，全部都绑定到同一个线程池里面去，我们通过 HystrixObservableCommand 的一个线程去执行，而在这个线程里面，批量把多个 productId 的 productInfo 拉回来。
从 Nginx 开始，缓存都失效了，那么 Nginx 通过缓存服务去调用商品服务。线程池就存在于缓存服务中，即使商品服务接口故障了，最多就只有线程大小个线程会 hang 死在调用商品服务接口的路上。

通过 Hystrix 信号量实现资源隔离：只是起到一个开关的作用，其它的请求都会被拒绝，从而达到资源隔离和限流保护的作用。

线程池与信号量的区别：
线程池隔离技术，是用 Hystrix 自己的线程去执行调用；而信号量隔离技术，是直接让 tomcat 线程去调用依赖服务。

适用场景：
线程池技术，适合绝大多数场景，比如说我们对依赖服务的网络请求的调用和访问、需要对调用的 timeout 进行控制（捕捉 timeout 超时异常）。
信号量技术，适合说你的访问不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，并且系统内部的代码，其实不涉及任何的网络请求，那么只要做信号量的普通限流就可以了，因为不需要去捕获 timeout 类似的问题。

Hystrix 隔离策略细粒度控制：
线程池机制，每个 command 运行在一个线程中，限流是通过线程池的大小来控制的；信号量机制，command 是运行在调用线程中，通过信号量的容量来进行限流。
线程池其实最大的好处就是对于网络访问请求，如果有超时的话，可以避免调用线程阻塞住。
而使用信号量的场景，通常是针对超大并发量的场景下。限流保护，一般用信号量常见于那种基于纯内存的一些业务逻辑服务，而不涉及到任何网络访问请求。
command key & command group、command thread pool、command key & command group & command thread pool、coreSize、queueSizeRejectionThreshold、execution.isolation.semaphore.maxConcurrentRequests。

5.fallback 降级
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。 
高峰期，为了保证核心服务正常运行，需要停掉一些不太重要的业务，或者某些服务不可用时，执行备用逻辑从故障服务中快速失败或快速返回，以保障主体业务不受影响。
Hystrix 提供的降级主要是为了容错，保证当前服务不受依赖服务故障的影响

Hystrix 出现以下四种情况，都会去调用 fallback 降级机制：
断路器处于打开的状态。
资源池已满（线程池+队列 / 信号量）。
Hystrix 调用各种接口，或者访问外部依赖出现了任何异常的情况。
访问外部依赖的时候，访问时间过长，报了 TimeoutException 异常。

两种最经典的降级机制
纯内存数据：在降级逻辑中，你可以在内存中维护一个 ehcache，作为一个纯内存的基于 LRU 自动清理的缓存，让数据放在缓存内。如果说外部依赖有异常，fallback 这里直接尝试从 ehcache 中获取数据。
默认值：fallback 降级逻辑中，也可以直接返回一个默认值。

降级回退方式：
Fail Fast 快速失败：快速失败是最普通的命令执行方法，命令没有重写降级逻辑。 如果命令执行发生任何类型的故障，它将直接抛出异常。
Fail Silent 无声失败：指在降级方法中通过返回null，空Map，空List或其他类似的响应来完成。
Fallback: Static：指在降级方法中返回静态默认值。 这不会导致服务以“无声失败”的方式被删除，而是导致默认行为发生。如：应用根据命令执行返回true / false执行相应逻辑，但命令执行失败，则默认为true。
Fallback: Stubbed：当命令返回一个包含多个字段的复合对象时，适合以 Stubbed 的方式回退。
Fallback: Cache via Network：有时，如果调用依赖服务失败，可以从缓存服务（如redis）中查询旧数据版本。由于又会发起远程调用，所以建议重新封装一个Command，使用不同的ThreadPoolKey，与主线程池进行隔离。
Primary + Secondary with Fallback：有时系统具有两种行为- 主要和次要，或主要和故障转移。主要和次要逻辑涉及到不同的网络调用和业务逻辑，所以需要将主次逻辑封装在不同的Command中，使用线程池进行隔离。
为了实现主从逻辑切换，可以将主次command封装在外观HystrixCommand的run方法中，并结合配置中心设置的开关切换主从逻辑。由于主次逻辑都是经过线程池隔离的HystrixCommand，因此外观HystrixCommand可以使用信号量隔离，而没有必要使用线程池隔离引入不必要的开销。

自动降级分类：超时降级、失败次数降级、故障降级、限流降级。
