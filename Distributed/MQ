1.简介
消息队列MQ是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。

JMS消息模型
点对点：消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。
发布/订阅：消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。

发布与订阅模式和观察者模式有以下不同：
观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。
观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。

JMS和AMQP
JMS：java消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。
AMQP：高级消息队列协议是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

区别：
AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。
AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。
AMQP跨平台、跨语言，仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。
AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。

2.使用场景(为什么使用消息队列|好处)
异步处理：发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。
流量削锋：在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。
应用解耦：采用Pub/Sub 发布订阅模型，模块之间不直接进行调用，模块之间耦合度很低，修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。

坏处：系统可用性降低，复杂度提高，带来一致性问题

3.可靠性
发送端：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。
接收端：保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的；保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。

4.常见消息队列ActiveMQ、RabbitMQ、RocketMQ、Kafka比较
ActiveMQ：Apache出品
吞吐量比RocketMQ、Kafka 低
延迟ms级
基于主从架构实现高可用	
有较低的概率丢失数据
MQ 领域的功能极其完备
基于JMS规范实现的。

RabbitMQ：Erlang 语言开发
吞吐量比RocketMQ、Kafka 低
延迟us级，延迟最低，这是 RabbitMQ 的一大特点
基于主从架构实现高可用
有较低的概率丢失数据
RabbitMQ有稳定的支持，活跃度也高
基于AMQP协议来实现

生产者与消费者模型，Producer->Exchange->Queue->Consumer。
Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。
RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略：direct(默认)，fanout, topic, 和 headers（不推荐）。
RabbitMQ 中通过 Binding(绑定) 将 Exchange(交换器) 与 Queue(消息队列) 关联起来。
一个消息可投入一个或多个队列。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。RabbitMQ 不支持队列层面的广播消费。
RabbitMQ 中消息只能存储在 队列 中，Kafka 将消息存储在 topic（主题） 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。
Broker（消息中间件的服务节点），服务器

RocketMQ：阿里开发
高吞吐，topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic
延迟ms级
可用性高，分布式架构
消息可靠性高，经过参数优化配置可以做到 0 丢失
MQ 功能较为完善，扩展性好
活跃度不算高，有风险
RocketMQ思路起源于Kafka，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。

RocketMQ用2PC实现分布式消息。
RocketMQ 不使用 ZooKeeper 作为注册中心，而使用自制的 NameServer。
组件通信间使用 Netty 的自定义协议。
Dubbo 负载均衡策略。

Kafka：
和RocketMQ相似，功能较为简单，主要支持简单的 MQ 功能。
大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准。社区活跃度很高。
Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。
同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。
kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响。

Sender线程。

5.如何保证高可用
RabbitMQ 的高可用性（主从式）：
单机模式
普通集群模式：普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。
没做到分布式，无高可用，主要为了提高吞吐量

镜像集群模式：真正的高可用。创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。
性能开销太大，不是分布式，不能扩展

Kafka 的高可用性（分布式）：
一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。
副本机制保证高可用：如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。

6.如何保证消息消费的幂等性（不被重复消费）
数据要写库，先根据主键查一下，如果这数据都有了，就别插入了，update 一下。
写 Redis，每次都是 set，天然幂等性。
让生产者发送每条数据的时候，里面加一个全局唯一的 id。消费前查一下之前有没有消费过。
基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。

7.如何保证消息的可靠性传输（处理消息丢失的问题）
RabbitMQ：
生产者弄丢了数据：事务机制（同步Rollback和Commit，导致吞吐量下降，性能降低）和confirm机制（异步消息回调）。一般在生产者避免数据丢失，都是用 confirm 机制的。               
RabbitMQ 弄丢了数据：开启 RabbitMQ 的持久化，故障恢复。可以跟生产者那边的 confirm 机制配合起来。                            
消费端弄丢了数据：ack 机制。

Kafka：
生产者设置了 acks=all，一定不会丢。
Kafka 弄丢了数据:配置topic,Kafka 服务端,producer 端。在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。
消费端弄丢了数据:关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。此时可能会有重复消费，需要自己保证幂等性。

8.如何保证消息的顺序性？
RabbitMQ：拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 
Kafka：
一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。
写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。

9.如何解决大量消息在 mq 里积压
先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。
新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。
然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。
接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。
等快速消费完积压数据之后，得恢复原先部署的架构

mq 中的消息过期失效了导致数据丢失：批量重导，把丢失的数据补回来

10.让你写一个消息队列，该如何进行架构设计？
可伸缩性：需要的时候快速扩容以增加吞吐量和容量。参考kakfa分布式系统，broker -> topic -> partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，给 topic 增加 partition，然后做数据迁移，增加机器。
持久化：保证数据不会丢失，顺序I/O读写性能高
可用性
可靠性
