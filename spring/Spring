1.简介
Spring 框架是 Java 平台的一个开源的全栈应用程序框架和控制反转容器实现。该框架的一些核心功能理论上可用于任何 Java 应用，但 Spring 还为基于 Java 企业版平台构建的 Web 应用提供了大量的拓展支持，基本上完全代替了 EJB 模型。

Spring 框架特性 
Core technologies：依赖注入，AOP，事件，资源，i18n，验证，数据绑定，类型转换，SpEL。
Testing：模拟对象，TestContext 框架，Spring MVC 测试，WebTestClient。
Data Access：事务，DAO 支持，JDBC，ORM，编组 XML。
Spring MVC 和 Spring WebFlux
Integration：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。
Languages：Kotlin，Groovy，动态语言。

其他模块：Aspects。

Spring5 基于 JDK8，支持候选组件索引代替类路径扫描（对于大型项目启动时间降低），支持 Kotlin，响应式编程，Junit5，更新依赖类库。

2.AOP
面向切面编程。代理模式。
横切关注点可以被描述为那些与业务无关，却为业务模块所共同调用的逻辑或责任。
切面能帮助我们模块化横切关注点，在系统运行时需要的地方进行动态插入运行。扩展功能不修改源代码。减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
分离业务逻辑与系统服务，应用对象只完成业务逻辑。可用于事务处理、日志管理、权限控制、缓存控制、性能监控、异常处理等。 
JDK & CGLIB 动态代理。
Spring AOP 已经集成了 AspectJ。Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理，而 AspectJ 基于字节码操作。AspectJ 功能更加强大，而 Spring AOP 相对来说更简单。当切面太多的话，最好选择 AspectJ，它比 Spring AOP 快很多。 

注意事项：
无法拦截 static、final、private 方法。
无法拦截内部方法调用。

Spring AOP 对于动态代理的选择：
默认使用 CGLIB 动态代理。
如果目标对象实现了接口，则默认使用 JDK 动态代理。
如果目标对象实现了接口，且强制使用 CGLIB 动态代理，则使用 CGLIB 动态代理。

AspectJ 注解 @Aspect：
连接点 joinpoint：准备增强的方法
切入点 pointcut：实际增强的方法。@Pointcut 和 XML 中的 aop:aspect 标签，切入点表达式包含指示器 designators、通配符 wildcards 和运算符 operators。
通知/增强 advice：实现的功能
切面 aspect：把增强应用到方法的过程
引入 introduction：向现有的类添加新的方法或者属性
织入 weaving：把切面应用到目标

五种通知 Advice：
前置 @Before
后置 @AfterReturning：切入点方法正常执行后，和异常通知两者只能执行一个（对应 commit 和 rollback）
最终 @After：最后执行。XML 和注解的 @After 执行顺序不一样。
异常 @AfterThrowing：切入点方法产生异常后执行后
环绕 @Around，前面功能全有

采用 XML：xmlns:aop 和 aop:config 标签。前面四个通知采用 XML 实现，环绕通知需要自己编码实现 ProceedingJoinPoint 接口，并 proceed() 调用切入点方法
注解在 XML 中开启 AOP：aop:aspect-autoproxy。XML 可以被注解完全代替。

多个 AOP 叠加：责任链模式 + 改进版本
用 AOP 实现 transaction、security、cache
security：MethodSecurityInterceptor、PreInvocationAuthrizationAdviceVote、ExpressionBasedPreInvocationAdvice
@PreAuthorize 验证机制：decide -> vote -> before 只需要一个注解就可以实现，debug 进源码看实现流程。
cache：AnnotationCacheSupport、CacheInterceptor、CacheAspectSupport，时序图 invoke -> execute -> doGet -> invokeJoinpoint -> cachePutRequest.apply

3.IOC
控制反转，将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。IOC 容器是 Spring 用来实现 IOC 的载体，IOC 容器实际上就是个 Map，存放的是各种对象。
将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。
IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或注解即可，完全不用考虑对象是如何被创建出来的。然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
Spring 时代我们一般通过 XML 文件来配置 bean，后来开发人员觉得 XML 文件来配置不太好，于是 Spring Boot 注解配置就慢慢开始流行起来。
Spring IOC 的初始化过程：XML 读取为 Resource，解析为 BeanDefinition，注册为 BeanFactory。

Java bean 不只实体类。配置文件 + 反射创建类。
配置文件可以先 ApplicationContext，再 getBean() 根据 bean 名称获取 bean 对象。
spring 中 bean 生存的容器：BeanFactory、ApplicationContext、webApplicationContext。应用上下文更好，配合单例，也可以指定是否延迟初始化。
先获取 ApplicationContext，再 getBean()。ApplicationContext 三个实现类 ClassPathXmlApplicationContext（更常用）、FileSystemXmlApplicationContext、AnnotationConfigApplicationContext。
BeanFactory 使用到 bean 的时候（即 getBean() 时）才会创建对象，Resource -> BeanFactory。延迟加载。
创建 bean 的三种方式：默认构造函数 id + class、工厂方法额外 factory-bean + factory-method、静态工厂 StaticFactory（JAR 包中的类使用 Spring 容器创建可以使用这两个工厂方法）。
BeanDefinition：用来管理 bean 的属性和对象间的相互依赖关系

依赖注入 DI。DI 不能单独存在，需要在 IOC 基础之上完成。工厂模式。
对象 A 依赖于对象 B，对象 A 获得依赖对象 B 的过程，由主动行为变为了被动行为，控制权颠倒了。控制反转是获得依赖对象的过程被反转。控制权交由 Spring 框架来管理。从上到下依赖变为从下到上注入。依赖注入在初始化的过程中就不可避免的会写大量的 new。
能注入的类型：基本类型和 String（配置文件的 value 属性，其他类型用 ref 且需要配置过）、XML 或注解配置的 bean、复杂类型（构造函数和 setter 来注入）和集合类型（结构相同的标签可以互换，map 对应 property，只能用 XML 实现）。
注入方式：构造函数（配置文件的 constructor-arg 标签）、setter（配置文件的 property 标签，更常用，类中加 set 方法）、注解（XML 中加 xmlns:context 和 context:component-scan 标签）。
构造函数方式注入必须要注入数据，不然创建对象不成功，如果用不到这些数据也必须提供。
选择 XML 或者 注解需要看是用别人的 JAR 包还是自己开发。

使用 IOC 的好处：
降低耦合。
提高了模块的可复用性。
在创建实例的时候不需要了解其中的细节。
把对象生成放在配置文件里进行定义，更换一个实现子类将会变得很简单，只要修改配置文件就可以，具有热插拨特性。

缺点：
引入了第三方 IOC 容器，生成对象的步骤变得复杂。
IOC 容器通过反射方式生成对象，在运行效率上有一定的损耗。
需要进行大量的配制工作，比较繁琐。

4.MVC
SpringMVC 框架是以请求为驱动，围绕 Servlet 设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。
其中核心类是 DispatcherServlet，它是一个 Servlet，顶层是实现的 Servlet 接口。作为 Spring MVC 的入口函数，作用是接收请求，响应结果。
耦合低，重用性高。但使项目架构变得复杂。
SpringMVC 使用：需要在 web.xml 中配置 DispatcherServlet。并且需要配置 Spring 监听器 ContextLoaderListener。

模型 Model 是应用程序中用于处理应用程序数据逻辑的部分。JavaBean。
通常模型对象负责在数据库中存取数据。

视图 View 是应用程序中处理数据显示的部分。JSP
通常视图是依据模型数据创建的。

控制器 Controller 是应用程序中处理用户交互的部分。Servlet，web.xml 和 springmvc.xml。
通常控制器负责读取用户输入，向模型发送数据，把数据交给视图展示。

web.xml 配置：
DispatcherServlet
加载 springmvc.xml：
<init-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>classpath:springmvc.xml</param-value>
</init-param>

过滤器，解决中文乱码问题：
<filter></filter>
<filter-mapping></filter-mapping>

过滤器 HiddentHttpMethodFilter：改变 HTTP 请求方式，使得支持 GET、POST、PUT 和 DELETE 请求。
监听器 <listener></listener> 加设置配置文件 applicationContext.xml 的位置 <context-param></context-param>。

springmvc.xml 配置：
视图解析器对象
<mvc:annotation-driven/> 等于配置了 HandlerMapping 和 HandlerAdapter。
自定义类型转换器 conversionService
不拦截静态资源 <mvc:resources mapping= location=/> 
文件解析器 multipartResolver
异常处理器
拦截器 <mvc:interceptors></mvc:interceptors> 
 
流程：
客户端或浏览器发送请求，直接请求到前端控制器 DispatcherServlet。
DispatcherServlet 根据请求信息调用处理器映射器 HandlerMapping，解析请求对应的处理器 Handler。解析出具体的类.方法。
解析到对应的 Handler（也就是我们平常说的控制器 Controller）后，开始由处理器适配器 HandlerAdapter 处理。任何类.方法都会被适配为可以被适配器执行的样子。
HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑。
处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。
视图解析器 ViewResolver 会根据逻辑 View 查找实际的 View。
DispatcherServlet 把返回的 Model 传给 View（视图渲染）。
DispatcherServlet 把 View 返回给请求者。

其中 Handler 和 View 需要自己开发，其他由框架提供。基于组件的方式。

Model1 时代：整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作，JSP 即是控制层又是表现层。
Model2 时代：Java Bean（Model）+ JSP（View）+ Servlet（Controller），早期的 JavaWeb MVC 开发模式，抽象和封装程度还远远不够，重复造轮子，程序的可维护性和复用性低。
Struts2 比较笨重，而 Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。
Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层（控制层，返回数据给前台页面）。

SSM 三层架构
表现层 SpringMVC：接受用户参数，显示页面。
业务层 Spring：处理业务逻辑。
持久层 MyBatis：操作数据库。

@RestController vs @Controller
@Controller：返回一个页面，单独使用 @Controller 不加 @ResponseBody 的话一般使用在要返回一个视图的情况，这种情况属于比较传统的 SpringMVC 的应用，对应于前后端不分离的情况。
@RestController：返回 JSON 或 XML 形式数据，但只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应 Response 中，这种情况属于 RESTful web 服务，这也是目前日常开发所接触最常用的前后端分离。Spring 4 之后新加的注解。         
@Controller + @ResponseBody 等于 @RestController。@ResponseBody 注解的作用是将 Controller 的方法返回的 JavaBean 对象转换为指定的格式之后，写入到 HTTP 响应对象的 body 中。返回 JSON 格式的情况比较多。                    

@RequestMapping：将对页面的 HTTP 请求映射到方法或者类，并且默认映射所有 HTTP 方法。映射路径 path/value，HTTP 方法 method，URL 参数限制 params，请求头限制 headers。
请求参数的绑定：URL 的参数可以传到 Controller 中。参数过多可以封装到 JavaBean 中，方法参数传这个 JavaBean 类型，可以是表单的请求参数。还可以封装到容器中。

在方法中传入 HttpServletRequest 和 HttpServletResponse 就可以获取这两个对象以及原生 API。
@RequestParam：URL 参数的绑定。
@PathVariable：.../{id} 和 name="id"。传参。
@RequestHeader
@CookieValue
@ModelAttribute：放在方法上会在控制器方法执行前执行。有有返回值和无返回值（需要 Map）两种情况，用来给在表单提交数据之外的参数赋值。加在参数前则可以从 Map 中取值。
@SessionAttribute：model.addAttribute() 会把值存到 request 对象中，在多个控制器方法共享参数。

响应返回值是 void 需要 forward 或者 redirect，分别为 request.getRequestDispatcher().forward(request,response) 和 response.sendRedirect(request.getContextPath()+)。
或者直接进行响应：response.getWriter().print()。
设置中文乱码问题：response.setCharacterEncoding("UTF-8");response.setContentType("text/html;charset=UTF-8");

返回 ModelAndView：底层是 map。是传入 model 返回 String 的底层。
返回 String 中使用 forward 和 redirect。
@RequestBody

文件上传：传统方法 new File(path)，解析 upload.parseRequest(request)，上传。上传到服务端文件夹下。SpringMVC 方法配置文件解析器，并在 Controller 中传参 MultipartFile。跨服务器上传。
异常处理：目标是浏览器显示友好的提示而不是出错信息。需要编写自定义异常类，Controller 抛出这个异常，还要编写异常处理类。
拦截器 interceptor：预处理和后处理，只会拦截 Controller 的方法。编写拦截器类，配置。还有页面完成后处理。多个拦截器按先进后出的顺序。

Spring 整合 SpringMVC：启动 Tomcat 服务器的时候加载 Spring 的配置文件 applicationContext.xml，用到监听器 ContextLoaderListener 监听 ServletContext 对象，让监听器取加载 Spring 的配置文件。
Spring 整合 MyBatis：配置连接池，配置 SqlSessionFactory，配置 DAO 所在包。有了 applicationContext.xml 可以替代 MyBatis 的主配置文件 configuration.xml。只需要编写 Mapper 和 SQL。 
Spring 整合声明式事务：配置事务管理器，事务通知，AOP。

5.bean
可重用组件。那些组成应用程序的主体及由 Spring IOC 容器所管理的对象。IOC 容器初始化、装配及管理的对象。bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。
bean 的生命周期（bean 实例化过程，不同作用域的 bean 不同，@PostConstruct 和 @PreDestory 注解生命周期）：
bean 容器找到配置文件中 Spring bean 的定义。bean 容器利用 Java Reflection API 创建一个 bean 的实例。
使用 set() 设置对象属性。
如果 bean 实现了 BeanNameAware 接口，调用 setBeanName() 传入 bean 的名字。
如果 bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()，传入 ClassLoader 对象的实例。
同理，其他 Aware 接口。
将 bean 传递给 BeanPostProcessor，调用 postProcessBeforeInitialization()。
调用 InitializingBean 的 afterPropertiesSet()。
调用自定义的初始化方法：如果 bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。
将 bean 传递给 BeanPostProcessor，调用 postProcessAfterInitialization()。
使用 bean，将一直存在于应用上下文中，直到该应用上下文被销毁。
调用 DisposableBean 的 destroy()。
调用自定义的销毁方法：如果 bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。

bean 的作用域：
@scope 注解定义 bean 的作用域。

singleton：唯一 bean 实例，Spring 中的 bean 默认都是单例的。创建容器时就同时自动创建了一个 bean 对象，或者指定延迟初始化。容器销毁 bean 死亡。
Spring 的单例是基于 Spring 容器的，单例 Bean 在此容器内只有一个，Java 的单例是基于 JVM，每个 JVM 内只有一个实例。
单例 bean 的线程安全问题：当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。
解决方法：在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中。

prototype：每次请求都会创建一个新的 bean 实例。创建容器的时候并没有实例化，而是延迟初始化。JVM 垃圾回收。
有状态的 bean 应该使用 prototype 作用域，而对无状态的 bean 则应该使用 singleton 作用域。

request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
session：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。
global-session：全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。集群环境，负载均衡。

@Component 和 @Bean 的区别：
@Component 注解作用于类，而 @Bean 注解作用于方法。
@Component 通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中，@Bean 注解通常是在标有该注解的方法中定义产生这个 bean。
@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。

将一个类声明为 bean 的注解：
使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类，采用以下注解可实现：
@Component：通用的注解，可标注任意类为 Spring 组件。如果一个 bean 不知道属于哪个层，可以使用 @Component 注解标注。创建对象，把当前对象存入 Spring 容器中，相当于 XML 的 <bean>。
@Repository：对应持久层即 DAO 层，主要用于数据库相关操作。
@Service：对应服务层，主要涉及一些复杂的逻辑，需要用到 DAO 层。
@Controller：对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

@Autowired：只要容器中有唯一一个 bean 对象类型和要注入的变量类型相匹配，就可以注入成功。可以作用于变量上和方法上。
@Qualifier：在按照类注入的基础上再根据名称注入。给类注入时不能单独使用，需要配合 @Autowired，给方法和变量注入时可以单独使用。
@Resource：根据 bean 的 ID 注入，可以单独使用。
基本类型和 String 无法用上述注解实现，需要使用 @Value，可以使用 Spring 的 EL 表达式 SpEL。

6.注解
元注解：
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented

@Configuration：指定配置类。
@ComponentScan：从扫描的路径中找出标识了需要装配的类，自动装配到 Spring 的 bean 容器中。相当于在 XML 中加了 context:component-scan 标签。
@Bean：把当前方法的返回值作为 bean 对象放入 Spring 容器中。如果方法有参数，会去 Spring 容器中查找可用的 bean 对象，查找方式和 @Autowired 一样。
@AnnotationConfigApplicationContext：代替 XML，当传入了所有需要的 .class 时 @Configuration 可以不写。
@Import：导入子配置类。
@PropertySource：指定 properties 文件的位置。
@RunWith 和 @ContextConfiguration：Spring 整合 JUnit。版本要对应。
@Param：给参数取别名，如果只有一个参数且在 <if> 里使用，必须加 @Param。

7.Spring 用到的设计模式
代理模式
工厂模式
单例模式：Spring 中的 Bean 默认都是单例的。把已经初始过的变量放在一个 map 中，下次再要使用这个变量的时候，先判断 map 中有没有。
模板模式：Spring 中以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
装饰器模式：连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式：Spring 事件驱动模型。
适配器模式：Spring AOP 的 advice 使用到了适配器模式，Spring MVC 中也是用到了适配器模式适配 controller。

8.事务
Spring 事务管理接口
PlatformTransactionManager：（平台）事务管理器，根据不同持久层框架提供对应的接口实现类。具体的实现就是各个平台自己的事情了。
TransactionDefinition：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。
TransactionStatus：事务运行状态。

事务管理：按照给定的事务规则来执行提交或者回滚操作。
Spring 并不直接管理事务，而是提供了多种事务管理器，将事务管理的职责委托给 Hibernate 或者 JTA 等持久化机制所提供的相关平台框架的事务来实现。

PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务。
TransactionDefinition 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。
隔离级别：定义了一个事务可能受其他并发事务影响的程度。Spring 事务中的隔离级别多了 DEFAULT，使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED 隔离级别。
传播行为：为了解决业务层方法之间互相调用的事务问题。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。
超时属性：一个事务允许执行的最长时间。如果超过该时间限制但事务还没有完成，则自动回滚事务。
只读属性：对事物资源是否执行只读操作。将事务标志为只读以提高事务处理的性能。
回滚规则：定义事务回滚规则。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（与 EJB 的回滚行为一致）。但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。           

TransactionStatus 接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状态信息。
PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的 TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。

@Transactional(rollbackFor = Exception.class)：这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。保证数据的一致性。
在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚。

Spring 管理事务的方式分为编程式事务与声明式事务。
编程式事务：硬编码，不推荐使用。通过 TransactionTemplate 手动管理事务。
声明式事务：基于 XML 和基于注解，在配置文件中配置，推荐使用。实际是通过 AOP 实现，代码侵入性小。
实现声明式事务的四种方式：基于 TransactionInterceptor、基于 TransactionProxyFactoryBean、基于 <tx> 和 <aop> 命名空间、基于 @Transactional。

XML：在 XML 中配置事务管理器和事务通知（配置事务的属性），还要在 aop:config 中建立切入点表达式和事务通知之间的对应关系。
注解：在 XML 中配置事务管理器和开启 Spring 对注解事务的支持，使用 @Transactional。
使用 XML 方式可以避免多次 @Transactional。

纯注解需要写 Configuration 类，连接数据库的配置类，事务管理器类。加上 @Configuration、@ComponentScan、@ 、@PropertySource、@EnableTransactionManagment、@Transactional、@Value、@Bean 等。

9.Spring Boot
起步依赖：spring-boot-starter 会把所有用到的依赖都给包含进来，避免了开发者自己去引入依赖所带来的麻烦。stater 机制帮我们完成了项目起步所需要的的相关 JAR 包。
自动配置 端点监控

@SpringBootApplication：启动类，@SpringbootConfiguration、@EnableAutoConfiguration 和 @ComponentScan 对其注解。和启动类同级和其子包下会自动扫描。
spring-boot-devtools：热部署。
spring-boot-starter-parent 依赖于 spring-boot-dependencies，包含了依赖的软件的版本。
spring-boot-starter-web
autoconfigure 下 META-INF 的 spring.factories，有很多 *AutoConfiguration，@ConfigurationProperties 包含要配置的属性。
写一个 application.yml/.properties 文件来自定义配置。@Value 获取这个配置文件的属性，@ConfigurationProperties 获取对象并填充到对象对应的各条属性中。
spring-boot-configuration-processor 在写 .yml 文件时会根据类的属性提示。

Spring Boot 整合 MyBatis：application.yml 中写数据库连接信息、MyBatis 包扫描和加载 MyBatis 映射文件。JPA 类似。
@SpringBootTest
Spring Boot 整合 Redis：RedisTemplate。

线程池的的创建：
Spring Boot 启动类上加 @EnableAsync。
我们可以使用 Spring Boot 默认的线程池，不过一般我们会自定义线程池，因为比较灵活，配置方式有：XML 文件和 @Configuration。
applicationContext.xml 中引入：开启异步并引入线程池和定义线程池。
或者引入线程池的配置 <import resource="threadPool.xml" /> <task:annotation-driven executor="WhifExecutor" />
@Async 创建异步方法。

注解方式：@Configuration 和 @EnableAsync 写一个配置类，创建异步方法。
@PostConstruct：项目启动时就执行一次该方法。

如下方式会使 @Async 失效：
异步方法使用 static 修饰。
异步类没有使用 @Component 注解（或其他注解）导致 Spring 无法扫描到异步类。
异步方法不能与被调用的异步方法在同一个类中。
类中需要使用 @Autowired 或 @Resource 等注解自动注入，不能自己手动 new 对象。
没加 @EnableAsync。
