1.单例模式
保证一个类中有一个实例，并提供一个访问它的全局访问点。

好处：
对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销。
由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

组成：
私有构造函数
私有静态变量
公有静态函数
私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

懒汉式-线程不安全：变量延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。在多线程下 uniqueInstance 会被实例化多次。
懒汉式-线程安全：对 getUniqueInstance() 方法加锁。线程阻塞时间过长，性能差。
饿汉式：直接实例化 uniqueInstance。

双重校验锁：先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。两次校验中加上 synchronized (Singleton.class)。
需要使用双重校验锁，也就是需要使用两个 if 语句的原因：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作。而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。
uniqueInstance 采用 volatile 关键字修饰：禁止 JVM 的指令重排（uniqueInstance = new Singleton() 不是原子性操作，多线程环境下导致一个线程获得还没有初始化的实例）。

静态内部类：在静态内部类中声明和初始化 uniqueInstance。
当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。
实现简单，延迟初始化，由 JVM 提供了对线程安全的支持。

枚举：可以防止反射攻击。
在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。
该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。
能应对序列化和反序列化：该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。

2.工厂方法模式
定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
每个对象都有一个与之对应的工厂。

简单工厂：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。违背了开放-封闭原则，可以通过反射的机制来避免。
简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。
在简单工厂中，创建对象的是另一个类；而在工厂方法中，是由子类来创建对象。

抽象工厂模式创建的是对象家族，而工厂方法模式只是用于创建一个对象。
抽象工厂模式用到了工厂方法模式来创建单一对象。
抽象工厂使用了组合，而工厂方法模式使用了继承。

3.原型模式
使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。clone()。

4.责任链模式
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。面对一个黑盒。不纯的责任链模式一个请求可以最终不被任何接收端对象所接收。
servlet中的filter，dubbo中的filter，mybatis中的plugin实现责任链。

5.命令模式
命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。

将命令封装成对象中，具有以下作用：
使用命令来参数化其它对象
将命令放入队列中进行排队
将命令的操作记录到日志中
支持可撤销的操作

6.迭代器模式
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
Iterator 主要定义了 hasNext() 和 next() 方法。

7.观察者模式
定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。观察者模式又叫做发布-订阅（Publish/Subscribe）模式。
主题（Subject）是被观察的对象。主题具有注册和移除观察者、并通知所有观察者的功能，通过维护一张观察者列表来实现这些操作的。
观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。

优点：观察者的数量动态可变。对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。观察者和被观察者之间松耦合。满足开-闭原则。
缺点：观察者对象很多的话，将所有的观察者都通知到会花费很多时间。被观察者之间有循环依赖会导致系统崩溃。只发送通知不能了解到观察者发生的具体变化。

观察者模式被广泛应用于游戏引擎的事件系统。

8.策略模式
定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。是设计原则中开闭原则最典型的体现。
能够根据所传递的参数对象的不同而具有不同行为。

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。
但是状态模式是通过状态转移（指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变）来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。

9.模板模式
定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

10.适配器模式
把一个类接口转换成另一个用户需要的接口。

11.装饰器模式
为对象动态添加功能。

12.享元模式
通过共享技术有效地实现了大量细粒度对象的复用，这些对象一部分内部状态是相同的。

13.代理模式
代理类与委托类有同样的接口，通常会存在关联关系，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。                          
可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。

按照代理的创建时期，代理类可以分为两种。 
静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
缺点：每一个代理类只能为一个接口服务，会产生过多的代理和重复代码，同时一旦接口增加方法，则目标对象和代理类都需要维护。

动态代理：在程序运行时，运用反射机制动态创建而成。一个代理类完成全部的代理功能。同时接口增加方法也无需再维护目标对象和代理对象。
JDK 代理接口，CGLIB 代理类。CGLIB 是一个字节码增强库，为 AOP 等提供了底层支持。CGLIB 基于继承实现代理，无法对 static、final 类和 private、static 方法进行代理。

代理也可以分为：远程代理、虚拟代理、保护代理、智能代理。

14.MVC模式
模式-视图-控制器
