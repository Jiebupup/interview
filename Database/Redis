1.简介
Redis 是速度非常快的非关系型（NoSQL）内存键值数据库。  
键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。
Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。
Redis是一个单进程单线程且采用多路I/O复用模型，非阻塞IO技术, 使之可以同时处理多个连接请求(减少网络IO耗时), 也不需要关心锁，线程切换等资源消耗问题。

缓存的目的：高性能与高并发
缓存是走内存的，内存天然就支撑高并发。
命中率：当某个请求能够通过访问缓存而得到响应时，称为缓存命中。缓存命中率越高，缓存的利用率也就越高。
最大空间：缓存通常位于内存中，内存的空间通常比磁盘空间小的多，缓存的最大空间不可能非常大。当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。

2.数据类型&数据结构
数据类型
字符串、列表、集合、散列表、有序集合
STRING、LIST、SET（去重，交集、并集、差集）、HASH、ZSET（排序）

ZSET增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。
使用ZIPLIST和SKIPLIST两种方式编码，ziplist 所保存的元素数量超过服务器属性 server.zset_max_ziplist_entries 的值（默认值为 128 ）或者新添加元素的 member 的长度大于服务器属性 server.zset_max_ziplist_value 的值（默认值为 64 ），ZIPLIST将会转换为 SKIPLIST。 
ziplist查找某个给定元素的复杂度为 O(N) 。
SKIPLIST：
同时使用字典和跳跃表两个数据结构来保存有序集元素。
使用字典结构，并将 member 作为键，score 作为值，可以在O(1)的时间：检查给定 member 是否存在于有序集（被很多底层函数使用）；取出 member 对应的 score 值（实现 ZSCORE 命令）。
通过使用跳跃表， 可以让有序集支持：在 O(logN) 期望时间、 O(N) 最坏时间内根据 score 对 member 进行定位（被很多底层函数使用）；范围性查找和处理操作，这是（高效地）实现 ZRANGE 、 ZRANK 和 ZINTERSTORE 等命令的关键。

通过同时使用字典和跳跃表， 有序集可以高效地实现按成员查找和按顺序查找两种操作。

数据结构 
字典dict：dictht 是一个散列表结构，使用拉链法保存哈希冲突。

跳跃表：是有序集合的底层实现之一（加散列表）
基于多指针有序链表实现的，可以看成多个有序链表。在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。
空间复杂度O(n)、查找&插入&删除O(logn) 

与红黑树等平衡树相比的优点：
插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
更容易实现；
支持无锁操作。

3.使用场景&缓存位置
使用场景
计数器，缓存，查找表，消息队列，会话缓存，分布式锁实现
LIST可以实现分页查询，Set 可以实现共同好友等功能，ZSet 可以实现排行榜等功能。

缓存位置
浏览器、ISP、反向代理、本地缓存、分布式缓存、数据库缓存、Java 内部的缓存、CPU 多级缓存

4.Redis 与 Memcached
两者都是非关系型内存键值数据库（分布式缓存），主要有以下不同：
redis 实际上是个单线程的多路 IO 复用模型（redis 内部使用文件事件处理器 file event handler是单线程的），Memcached是多线程的非阻塞IO复用的网络模型。
redis 原生支持集群模式，而memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
redis 只使用单核，而 memcached 可以使用多核。
Memcached 仅支持字符串类型，而Redis有多种数据类型。
Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。
Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。Redis Cluster 实现了分布式的支持。
在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高。

Java 自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

5.键的过期时间
Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。
对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

6.数据淘汰策略
redis 过期策略是：定期删除+惰性删除。
大量过期key堆积在内存里，导致 redis 内存块耗尽了走数据淘汰策略。
可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰
allkeys-random：从所有数据集中任意选择数据进行淘汰
noeviction：禁止驱逐数据

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略
Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。

7.持久化
Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。
RDB 快照：将某个时间点的所有数据都存放到硬盘上。实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
如果系统发生故障，将会丢失最后一次创建快照之后的数据。
如果数据量很大，保存快照的时间会很长。

优点：紧凑，适合用于备份，可以将数据集还原到不同的版本，适用于灾难恢复。父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。           
缺点：保存 RDB 文件的过程中可能会丢失数据。在数据集比较庞大时，fork() 可能会非常耗时 。

AOF 文件：将写命令添加到 AOF 文件（Append Only File）的末尾，用来记录数据发生的变化（增删改）。通过重新执行这些命令来还原数据集。
使用 AOF 持久化需要设置同步选项（always，everysec，no），从而确保写命令同步到磁盘文件上的时机。
随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。
Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件。

优点：AOF 的默认策略为每秒钟 fsync 一次，就算发生故障停机，也最多只会丢失一秒钟的数据。append only对 AOF 文件的写入不需要进行 seek ，即使日志因为某些原因而包含了未写入完整的命令，redis-check-aof 工具也可以轻易地修复这种问题。AOF 文件的内容非常容易被人读懂，对文件进行分析也很轻松，导出 AOF 文件也非常简单。                                                                                   
缺点：AOF 文件的体积通常要大于 RDB 文件的体积。AOF 的速度可能会慢于 RDB 。在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间。

生产环境其实更多是二者结合使用的。

8.事务&事件
事务
多个命令被一次性发送给服务器，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。
Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。watch

事件
Redis 服务器是一个事件驱动程序。
文件事件，时间事件，事件的调度与执行

9.复制
通过使用 slave of host port 命令来让一个服务器成为另一个服务器的从服务器，采用异步方式复制数据到 slave 节点。一个从服务器只能有一个主服务器，并且不支持主主复制。
连接过程：
主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
主服务器每执行一次写命令，就向从服务器发送相同的写命令。

随着负载不断上升，形成主从链。

主从(master-slave)架构：一主多从，实现读写分离，主节点负责写，并且将数据复制到其它的 slave 节点，从节点负责读。可以很轻松实现水平扩容，支撑读高并发。
如果采用了主从架构，那么必须开启 master node 的持久化。

复制会带来数据一致性问题。
通过主从架构的切换和哨兵实现高可用。

10.哨兵Sentinel
哨兵可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。
功能
集群监控：负责监控 redis master 和 slave 进程是否正常工作。
消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。
故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。
即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的。

主从架构
哨兵主备切换的数据丢失问题
哨兵集群的自动发现机制（哨兵互相之间的发现）

11.分片
分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。
范围分片、哈希分片
客户端分片、代理分片、服务器分片

12.redis cluster
主要是针对海量数据+高并发+高可用的场景。redis cluster 支撑 N 个 redis master node，可以横向扩容更多的 master 节点。
自动将数据进行分片，每个 master 上放一部分数据。提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的。

集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。
集中式是将集群元数据（节点信息、故障等等）几种存储在某个节点上。
gossip 协议是所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。
集中式的好处在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。
gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。

分布式寻址算法：hash 算法（大量缓存重建）、一致性 hash 算法（自动缓存迁移）+虚拟节点（自动负载均衡）、redis cluster 的 hash slot 算法

redis cluster 的高可用：主备切换，和哨兵类似。直接集成了 replication 和 sentinel 的功能。

13.缓存问题
缓存穿透：指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。
解决方案：对这些不存在的数据缓存一个空数据；对这类请求进行过滤（布隆过滤器）。

缓存雪崩：指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。
在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。
解决方案：
为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现。
为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。

事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。
事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

缓存 “无底洞” 现象：为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。
解决方案：优化批量数据操作命令；减少网络通信次数；降低接入成本，使用长连接 / 连接池，NIO 等。

*缓存一致性：要求数据库数据MySQL更新的同时缓存数据Redis也能够实时更新。
缓存和数据库是两类不同的存储资源，如果要追求绝对的数据一致性，唯一的办法就是分布式事务。
应该删除缓存代替更新缓存。
导致数据不一致的场景：
一、更新数据库成功，删除缓存失败，数据不一致；
二、删除缓存成功，更新数据库失败，数据弱一致；

解决并发下场景二问题：串行到一个队列里，每个更新数据请求都在前一个请求完成后再执行。或者对更新操作加锁。

正确做法
写操作：
1.清除缓存；若失败则返回错误信息（本次写操作失败）。
2.对key加分布式锁。
3.更新数据库；若失败则返回错误信息（本次写操作失败）同时释放锁，此时数据弱一致。
4.更新缓存，即使失败也返回成功，同时释放锁，此时数据弱一致。

读操作：
1.查询缓存，命中则直接返回结果。
2.对key加分布式锁。
3.查询数据库，将结果直接写入缓存，返回结果，同时释放锁。

14.CDN
内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。
加速用户获取数据，命中cdn时不需要访问后端服务器，互联网公司自己搭建或租用cdn。
优点：
更快地将数据分发给用户
通过部署多台服务器，从而提高系统整体的带宽性能
多台服务器可以看成是一种冗余机制，从而具有高可用性

15.一致性哈希DHT
数据分布
哈希分布：哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。
传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。

顺序分布：将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。
顺序分布相比于哈希分布的主要优点如下：
能保持数据原有的顺序；
并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。

一致性哈希：
是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。
将哈希空间 [0, 2^(n-1)] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。
一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点。
删除服务器节点：原服务器到前一个服务器（以顺时针方向）之间的数据会被重定位到后一个服务器节点。
增加服务器节点：新服务器到前一个服务器之间的数据会被重定位到新服务器节点。

虚拟节点：
一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。
数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。
解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。

16.redis 的并发竞争
多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同。
redis 自己就有天然解决这个问题的 CAS 类的乐观锁方案。
基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。
同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。Zookeeper更加可靠。

17热点key
大量请求访问的key

首先，发现热点key：
凭借业务经验预估
在客户端或Proxy层进行收集
redis自带命令monitor或redis-cli的热点key发现功能–hotkeys
还有自己抓包评估（Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP）。

然后解决：
利用二级缓存，在你发现热key以后，把热key缓存到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。分散了请求。
备份多台Redis服务器分摊热key请求

在项目运行过程中，自动发现热key，然后程序自动处理：监控热key，通知系统做处理。

18.Redis为什么设计为单线程？
因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。单线程容易实现。

19.Redis单线程为什么还能这么快？
完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
使用多路I/O复用模型，非阻塞IO，用很少的线程也能快速处理大量任务；
使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

20.Redis 的 IO 模型
Redis采用了多路IO复用及非阻塞IO技术。
多路IO复用模型是利用select、poll、epoll可以同时监察多个流的IO事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
采用多路IO复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络IO的时间消耗)。
非阻塞IO意味着线程在读写IO时可以不必再阻塞。
