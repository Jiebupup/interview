1.简介
Redis 是速度非常快的非关系型（NoSQL）内存键值数据库。  
Redis是一个单进程单线程且采用多路非阻塞I/O复用模型，使之可以同时处理多个连接请求(减少网络IO耗时), 也不需要关心锁，线程切换等资源消耗问题。

缓存的目的：高性能与高并发。缓存是走内存的，内存天然就支撑高并发。
命中率：当某个请求能够通过访问缓存而得到响应时，称为缓存命中。缓存命中率越高，缓存的利用率也就越高。
最大空间：缓存通常位于内存中，内存的空间通常比磁盘空间小的多，缓存的最大空间不可能非常大。当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。
淘汰策略：FIFO需要经常访问最新的数据，LRU保证内存中的数据都是经常被访问的数据（保证缓存命中率），LFU优先淘汰一段时间内使用次数最少的数据。
键的过期时间：Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

2.数据类型&数据结构
数据类型
键的类型只能为字符串，值支持五种数据类型。
字符串、列表、集合、散列表、有序集合
STRING、LIST（lrange命令分页）、SET（去重，交集、并集等）、HASH、ZSET（排序）

ZSET增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。
使用ZIPLIST和SKIPLIST两种方式编码，ziplist 所保存的元素数量超过服务器属性 server.zset_max_ziplist_entries 的值（默认值为 128 ）或者新添加元素的 member 的长度大于服务器属性 server.zset_max_ziplist_value 的值（默认值为 64 ），ZIPLIST将会转换为 SKIPLIST。 
ziplist查找某个给定元素的复杂度为 O(N) 。
SKIPLIST：
同时使用字典和跳跃表两个数据结构来保存有序集元素。
使用字典结构，并将 member 作为键，score 作为值，可以在O(1)的时间：检查给定 member 是否存在于有序集（被很多底层函数使用）；取出 member 对应的 score 值（实现 ZSCORE 命令）。
通过使用跳跃表， 可以让有序集支持：在 O(logN) 期望时间、 O(N) 最坏时间内根据 score 对 member 进行定位（被很多底层函数使用）；范围性查找和处理操作，这是（高效地）实现 ZRANGE 、 ZRANK 和 ZINTERSTORE 等命令的关键。

通过同时使用字典和跳跃表， 有序集可以高效地实现按成员查找和按顺序查找两种操作。

数据结构 
字典dict：dictht 是一个散列表结构，使用拉链法保存哈希冲突。
Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。
渐进式 rehash：为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。
在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。

跳跃表：是有序集合的底层实现之一（加散列表）
基于多指针有序链表实现的，可以看成多个有序链表。在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。
查找、插入或删除的时间复杂度O(logn) 

与红黑树等平衡树相比的优点：
插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
更容易实现；
支持无锁操作。

3.使用场景
计数器：对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。
缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。
查找表：DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。
消息队列：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息不过最好使用 Kafka、RabbitMQ 等消息中间件。
会话缓存：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
分布式锁实现：可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

LIST 可以实现分页查询，Set 可以实现共同好友等功能，ZSet 可以实现排行榜等功能。

缓存位置
浏览器：当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。
ISP：网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。
反向代理：反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。
本地缓存：使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。
分布式缓存：使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。分布式缓存单独部署，可以根据需求分配硬件资源，服务器集群都可以访问分布式缓存
数据库缓存：MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。
Java 内部的缓存：Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。
CPU 多级缓存：CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。

4.Redis 与 Memcached
两者都是非关系型内存键值数据库，主要有以下不同：
redis 只使用单核，而 memcached 可以使用多核。redis 单线程，Memcached 多线程。
Memcached 仅支持字符串类型，而Redis有五种数据类型。
Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化，数据会一直在内存中。Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高。
Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。Redis Cluster 实现了分布式的支持。自带的 map 或者 guava 实现的是本地缓存。

5.数据淘汰策略
redis 过期策略是：对于设置了过期时间的数据定期删除+惰性删除。还不行就走淘汰。
可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。
volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰
allkeys-random：从所有数据集中任意选择数据进行淘汰
noeviction：禁止驱逐数据

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。
使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略。
Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。

6.持久化
Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。
RDB 快照：将某个时间点的所有数据都存放到硬盘上。实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
如果系统发生故障，将会丢失最后一次创建快照之后的数据。
如果数据量很大，保存快照的时间会很长。
快照持久化是Redis默认采用的持久化方式。

优点：紧凑，适合用于备份，可以将数据集还原到不同的版本，适用于灾难恢复。父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。           
缺点：保存 RDB 文件的过程中可能会丢失数据。在数据集比较庞大时，fork() 可能会非常耗时。

AOF 文件：每执行一条会更改Redis中的数据的命令，就将该命令添加到 AOF 文件（Append Only File）的末尾，用来记录数据发生的变化（增删改）。通过重新执行这些命令来还原数据集。
使用 AOF 持久化需要设置同步选项（always，everysec兼顾数据和写入性能，no），从而确保写命令同步到磁盘文件上的时机。因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。
随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令，新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。
在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件。即使重写过程中发生停机，现有的 AOF 文件也不会丢失。

优点：AOF 的默认策略为每秒钟 fsync 一次，就算发生故障停机，也最多只会丢失一秒钟的数据，当硬盘忙于执行写入操作的时候，Redis还会放慢自己的速度以便适应硬盘的最大写入速度。append only对 AOF 文件的写入不需要进行 seek ，即使日志因为某些原因而包含了未写入完整的命令，redis-check-aof 工具也可以轻易地修复这种问题。AOF 文件的内容非常容易被人读懂，对文件进行分析也很轻松，导出 AOF 文件也非常简单。实时性更好。                                                                                   
缺点：AOF 文件的体积通常要大于 RDB 文件的体积。AOF 的速度可能会慢于 RDB 。在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间。

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化。生产环境其实更多是二者结合使用的。
如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

7.事务&事件
事务
一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。
多个命令被一次性发送给服务器，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。
Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。WATCH。
redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。

事件
Redis 服务器是一个事件驱动程序。
文件事件：
服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。
Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。

时间事件：
服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。时间事件又分为：定时事件和周期性事件。
Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。

事件的调度与执行：
服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。
事件调度与执行由 aeProcessEvents 函数负责。

8.复制
通过使用 slave of host port 命令来让一个服务器成为另一个服务器的从服务器，采用异步方式复制数据到 slave 节点。一个从服务器只能有一个主服务器，并且不支持主主复制。
连接过程：
主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
主服务器每执行一次写命令，就向从服务器发送相同的写命令。

随着负载不断上升，形成主从链。

主从(master-slave)架构：一主多从，实现读写分离，主节点负责写，并且将数据复制到其它的 slave 节点，从节点负责读。可以很轻松实现水平扩容，支撑读高并发。
如果采用了主从架构，那么必须开启 master node 的持久化。

复制会带来数据一致性问题。
通过主从架构的切换和哨兵实现高可用。

9.哨兵
哨兵Sentinel可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。
功能
集群监控：负责监控 redis master 和 slave 进程是否正常工作。
消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。
故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。
即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的。

主从架构
哨兵主备切换的数据丢失问题
哨兵集群的自动发现机制（哨兵互相之间的发现）

10.分片
分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。
范围分片、哈希分片
客户端分片、代理分片、服务器分片

11.redis cluster
主要是针对海量数据+高并发+高可用的场景。redis cluster 支撑 N 个 redis master node，可以横向扩容更多的 master 节点。
自动将数据进行分片，每个 master 上放一部分数据。提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的。

集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。
集中式是将集群元数据（节点信息、故障等等）几种存储在某个节点上。
gossip 协议是所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。
集中式的好处在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。
gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。

分布式寻址算法：hash 算法（大量缓存重建）、一致性 hash 算法（自动缓存迁移）+虚拟节点（自动负载均衡）、redis cluster 的 hash slot 算法

redis cluster 的高可用：主备切换，和哨兵类似。直接集成了 replication 和 sentinel 的功能。

12.缓存问题
缓存穿透：指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。
解决方案：对这些不存在的数据缓存一个空数据；对这类请求进行过滤（布隆过滤器）。

缓存雪崩：指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。
在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。
解决方案：
为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现。
为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。

事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。
事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

缓存无底洞：为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。
解决方案：优化批量数据操作命令；减少网络通信次数；降低接入成本，使用长连接 / 连接池，NIO 等。

*缓存一致性：要求数据库数据MySQL更新的同时缓存数据Redis也能够实时更新。
缓存和数据库是两类不同的存储资源，如果要追求绝对的数据一致性，唯一的办法就是分布式事务。
应该删除缓存代替更新缓存。
导致数据不一致的场景：
一、更新数据库成功，删除缓存失败，数据不一致；
二、删除缓存成功，更新数据库失败，数据弱一致；

解决并发下场景二问题：串行到一个队列里，每个更新数据请求都在前一个请求完成后再执行。或者对更新操作加锁。

雪崩就本地缓存+限流+降级+Redis高可用+Redis持久化
穿透就布隆过滤器，把空值缓存起来
击穿就临时加锁，缓存后释放锁

正确做法
写操作：
1.清除缓存；若失败则返回错误信息（本次写操作失败）。
2.对key加分布式锁。
3.更新数据库；若失败则返回错误信息（本次写操作失败）同时释放锁，此时数据弱一致。
4.更新缓存，即使失败也返回成功，同时释放锁，此时数据弱一致。

读操作：
1.查询缓存，命中则直接返回结果。
2.对key加分布式锁。
3.查询数据库，将结果直接写入缓存，返回结果，同时释放锁。

13.CDN
内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。
加速用户获取数据，命中CDN时不需要访问后端服务器。
优点：
更快地将数据分发给用户
通过部署多台服务器，从而提高系统整体的带宽性能
多台服务器可以看成是一种冗余机制，从而具有高可用性

14.一致性哈希DHT
数据分布
哈希分布：哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。
传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。

顺序分布：将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。
顺序分布相比于哈希分布的主要优点如下：
能保持数据原有的顺序；
并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。

一致性哈希：
是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。
将哈希空间 [0, 2^(n-1)] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。
一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点。
删除服务器节点：原服务器到前一个服务器（以顺时针方向）之间的数据会被重定位到后一个服务器节点。
增加服务器节点：新服务器到前一个服务器之间的数据会被重定位到新服务器节点。

虚拟节点：
一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。
数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。
解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。

15热点key
大量请求访问的key

首先，发现热点key：
凭借业务经验预估
在客户端或Proxy层进行收集
redis自带命令monitor或redis-cli的热点key发现功能–hotkeys
还有自己抓包评估（Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP）。

然后解决：
利用二级缓存，在你发现热key以后，把热key缓存到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。分散了请求。
备份多台Redis服务器分摊热key请求

在项目运行过程中，自动发现热key，然后程序自动处理：监控热key，通知系统做处理。

16.Redis为什么设计为单线程？
redis 内部使用文件事件处理器 file event handler 是单线程的，所以 redis 才叫做单线程的模型。
因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。单线程容易实现。

17.Redis单线程为什么还能这么快？
完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
使用多路I/O复用模型，非阻塞IO，用很少的线程也能快速处理大量任务；
使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

18.Redis 的 IO 模型
Redis采用了多路IO复用及非阻塞IO技术。
多路IO复用模型是利用select、poll、epoll可以同时监察多个流的IO事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
采用多路IO复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络IO的时间消耗)。
非阻塞IO意味着线程在读写IO时可以不必再阻塞。
