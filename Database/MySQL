1.索引
B+ Tree：所有叶子节点位于同一层，顺序访问指针来提高区间查询的性能。文件系统及数据库系统普遍采用 B+ Tree 作为索引结构。
优势：更少的查找次数（出度大），利用磁盘预读特性。
是大多数 MySQL 存储引擎的默认索引类型。
不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。
因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。
InnoDB 的 B+Tree 索引分为主索引和辅助索引。这种索引方式被称为聚簇索引。一个表只能有一个聚簇索引。

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
还有哈希索引，全文索引，空间数据索引，

索引优化：独立的列，多列索引，索引列的顺序，前缀索引，覆盖索引

优点：
大大减少了服务器需要扫描的数据行数。
帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。
将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

使用条件：对于中到大型的表，索引就非常有效；对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配（使用分区技术）。

2.查询性能优化
Explain ：用来分析 SELECT 查询语句
优化数据访问
重构查询方式

MySQL 默认采用自动提交模式

3.存储引擎
InnoDB：
MySQL 默认的事务型存储引擎，可以使用 Commit 和 Rollback 语句。
支持行级锁，外键。
支持mvcc
实现了四个标准的隔离级别，默认隔离级别是可重复读。
主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
支持真正的在线热备份。
支持宕机恢复。

MyISAM：多了支持压缩表和空间数据索引。

4.数据类型
整型，浮点数，字符串，时间和日期

5.切分
水平切分Sharding：将同一个表中的记录按行拆分到多个结构相同的表中。
垂直切分：将一张表按列切分成多个表
Sharding 策略
Sharding 存在的问题：事务问题，连接，ID 唯一性

6.复制
主从复制：涉及binlog 线程、I/O 线程和 SQL 线程。
读写分离：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

7.并发一致性问题
丢失修改:T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

读脏数据:T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
发生在未提交读

不可重复读:T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
发生在未提交读和提交读。不可重复读强调的是更新。

幻读:T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。
发生在未提交读和提交读、可重复读。幻读强调的是插入和删除。

8.隔离级别
未提交读（READ UNCOMMITTED）:事务中的修改，即使没有提交，对其它事务也是可见的。

提交读（READ COMMITTED）:一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可重复读（REPEATABLE READ）:保证在同一个事务中多次读取同样数据的结果是一样的。

可串行化（SERIALIZABLE）:强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。

9.锁机制
读写锁：
排它锁（Exclusive），简写为 X 锁，又称写锁。
共享锁（Shared），简写为 S 锁，又称读锁。

意向锁：意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。

封锁协议

行锁：
InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据时InnoDB才使用行级锁，否则InnoDB将使用表锁。

Record Locks:锁定一个记录上的索引，而不是记录本身。
Gap Locks:锁定索引之间的间隙，但是不包含索引本身。

Next-Key Locks：Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。
在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

乐观锁：
乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

数据版本（Version）记录机制或时间戳（timestamp）实现
读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
