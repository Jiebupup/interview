1.简介
MySQL是一个关系型数据库管理系统，属于 Oracle 旗下产品。关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。

2.索引
B+ Tree：所有叶子节点位于同一层，叶子节点自小而大顺序链接，叶子结点中包含了全部元素的信息。有k个子树的中间节点包含有k个元素，每个元素不保存数据只用来索引。所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
文件系统及数据库系统普遍采用 B+ Tree 作为索引结构。
优势：单一节点存储更多的元素，更少的查找次数（出度大），利用磁盘预读特性。所有查询都要查找到叶子节点，查询性能稳定。所有叶子节点形成有序链表，便于范围查询。
是大多数 MySQL 存储引擎的默认索引类型。不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找（最左）。
InnoDB 的 B+Tree 索引分为主索引和辅助索引，主索引的叶子节点 data 域记录着完整的数据记录，辅助索引的叶子节点的 data 域记录着主键的值，这种索引方式被称为聚簇索引。一个表只能有一个聚簇索引。在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据（索引元素所指向的数据记录）。

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
还有哈希索引（Memory引擎默认支持，适合在绝大多数需求为单条记录查询）（主要），全文索引，空间数据索引R-Tree，

索引优化：
独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。
索引列的顺序：让选择性最强的索引列放在前面。
前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。
覆盖索引：索引包含所有需要查询的字段的值。

聚簇索引，索引扫描来做排序，冗余和重复索引，未使用的索引，索引和锁

索引的优点：
大大加快了数据的检索速度（将无序的数据变为有序），减少了服务器需要扫描的数据行数。
帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。
将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
通过创建唯一性索引，保证数据库每一行数据的唯一性。

使用条件：对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；对于中到大型的表，索引就非常有效；对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配（使用分区技术）。

3.查询性能优化&库表结构优化
查询
Explain ：用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。
比较重要的字段有select_type查询类型、key使用的索引和rows扫描的行数。

优化数据访问
减少请求的数据量：只返回必要的列：最好不要使用 SELECT * 语句。只返回必要的行：使用 LIMIT 语句来限制返回的数据。缓存重复查询的数据。
减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。

重构查询方式
切分查询：一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
分解关联查询：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联。

优化特定类型的查询：COUNT()查询、关联查询、子查询、GROUP BY和DISTINCT、LIMIT分页、SQL_CALC_FOUND_ROWS、UNION查询以及静态查询分析和用户自定义变量。

库表
范式和反范式、优缺点
缓存表和汇总表
加快ALTER TABLE操作的速度

4.存储引擎
InnoDB：
MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。可以使用 Commit 和 Rollback 语句。
实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。
主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
内部优化：从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区。
支持真正的在线热备份，读写混合。
支持行级锁，外键，MVCC，宕机恢复。

MyISAM：
多了支持压缩表和空间数据索引。设计简单，不支持事务，
不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入。
崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

5.数据类型
整型，浮点数，字符串（CHAR 和 VARCHAR、BLOB二进制和TEXT字符存储很大数据），时间和日期，位数据，选择标识符identifier和特殊类型数据。

6.切分
拓展写能力，应对高并发和大数据。
水平切分Sharding：将同一个表中的记录按行拆分到多个结构相同的表中。水平拆分最好分库。
当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

垂直切分：将一张表按列切分成多个表
在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中

Sharding 策略：哈希取模，范围，映射表
Sharding 存在的问题：事务问题，连接，ID 唯一性

如何设计才可以让系统从未分库分表动态切换到分库分表上？
停机迁移方案，双写迁移方案

分库分表之后，id 主键如何处理？全局唯一的 id 
基于数据库：数据库自增 id，设置数据库 sequence 或者表自增字段步长
本地：UUID， 太长了、占用空间大，作为主键性能太差了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作。在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。
snowflake 算法：分布式 id 生成算法  

7.复制
MySQL支持两种复制方式：基于行的复制和基于语句（逻辑）的复制。这两种方式都是在主库（服务器）上记录二进制日志，在备库重放日志的方式来实现异步的数据复制。在同一时间点备库的数据可能与主库的不一致。
通过复制可以将读操作指向备库来扩展读。不适合扩展写操作，因为一主库多备库的架构中，整个系统的性能取决于写入最慢的那部分。不能像分发读操作那样把写操作等同地分发到更多服务器上。

主从复制：
binlog 线程：在主库上把数据更改记录到二进制日志中
I/O 线程：备库将主库上的日志复制到自己的中继日志中
SQL 线程：备库读取中继日志中的事件并将其重放到备库数据之上

复制拓扑：一主库多备库，主-主模式下的主-主复制，主-被模式下的主-主复制，拥有备库的主-主结构，环形复制，主库&分发主库&备库，树形，自定义。

读写分离：
主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。
读写分离能提高性能的原因：
主从服务器负责各自的读和写，极大程度缓解了锁的争用；
从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

MySQL 主从同步延时问题：从库的数据一定会比主库慢一些。
解决方案：分库。打开 MySQL 支持的并行复制，多个库并行复制。重写代码。设置直连主库（不推荐）。

8.并发一致性问题
丢失修改:T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

读脏数据:T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
发生在未提交读

不可重复读:T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
发生在未提交读和提交读。不可重复读强调的是更新。

幻读:T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。
发生在未提交读和提交读、可重复读。幻读强调的是插入和删除。

9.隔离级别
未提交读（READ UNCOMMITTED）:事务中的修改，即使没有提交，对其它事务也是可见的。

提交读（READ COMMITTED）:一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可重复读（REPEATABLE READ）:保证在同一个事务中多次读取同样数据的结果是一样的。

可串行化（SERIALIZABLE）:强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。

10.锁机制
读写锁：
排它锁（Exclusive），简写为 X 锁，又称写锁。
共享锁（Shared），简写为 S 锁，又称读锁。

意向锁：意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。

封锁协议：三级封锁协议和两段锁协议
MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

行锁：粒度更小
InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据时InnoDB才使用行级锁，否则InnoDB将使用表锁。只在存储引擎层实现。

Record Locks:锁定一个记录上的索引，而不是记录本身。
Gap Locks:锁定索引之间的间隙，但是不包含索引本身。

Next-Key Locks间隙锁：Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。
在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。阻止多个事务将记录插入到同一范围内
当查询的索引含有唯一属性时，将next-key lock降级为record key。

悲观锁：先关闭autocommit，再select * from table for update 开启
乐观锁：MVCC实现，实际上并没有加锁

11.多版本并发控制MVCC
采用MVCC来支持高并发比单纯的加锁更高效。行级锁的变种，很多情况下避免了加锁。通过保存在数据的某个时间点的快照来实现的。不管执行多少时间，同一个事务看到的数据都是一致的，多个事务看到同一行数据可能是不同的。分为乐观和悲观
用于隔离每个事物的数据版本，使得多个事物的操作读锁与写锁不冲突，不会互相阻塞。把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读。
MVCC是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

版本号
系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
事务版本号：事务开始时的系统版本号。

隐藏的列:MVCC 在每行记录后面都保存着两个隐藏的列，用来存储:
创建版本号：指示创建一个数据行的快照时的系统版本号；
删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

Undo 日志:MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。

实现过程：SELECT、INSERT、DELETE、UPDATE。如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。多个事务读取同一行，比较版本号。

快照读：使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。
当前读：读取的是最新的数据，需要加锁。

MVCC 不能解决幻影读问题。

12.一条SQL语句在MySQL中如何执行的
一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎
另一类对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit

13.一条SQL语句执行得很慢的原因有哪些
大多数情况下很正常，偶尔很慢：数据库在刷新脏页或执行的时候遇到了锁。
一直执行的很慢：没有用上索引或数据库选错了索引。

14.数据库中间件
用来分库分表，读写分离
Cobar，MyCAT，OneProxy，Vitess，MaxScale与MySQL Route官方。
