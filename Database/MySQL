MySQL 默认采用自动提交模式

1.索引
B+ Tree：所有叶子节点位于同一层，顺序访问指针来提高区间查询的性能。文件系统及数据库系统普遍采用 B+ Tree 作为索引结构。
优势：更少的查找次数（出度大），利用磁盘预读特性。
是大多数 MySQL 存储引擎的默认索引类型。
不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。
因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。
InnoDB 的 B+Tree 索引分为主索引和辅助索引。这种索引方式被称为聚簇索引。一个表只能有一个聚簇索引。

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
还有哈希索引，全文索引，空间数据索引，

索引优化：独立的列，多列索引，索引列的顺序，前缀索引，覆盖索引

优点：
大大减少了服务器需要扫描的数据行数。
帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。
将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

使用条件：对于中到大型的表，索引就非常有效；对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配（使用分区技术）。

2.查询性能优化
Explain ：用来分析 SELECT 查询语句
优化数据访问
重构查询方式

3.存储引擎
InnoDB：
MySQL 默认的事务型存储引擎，可以使用 Commit 和 Rollback 语句。
支持行级锁，外键。
支持mvcc
实现了四个标准的隔离级别，默认隔离级别是可重复读。
主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
支持真正的在线热备份。
支持宕机恢复。

MyISAM：多了支持压缩表和空间数据索引。

4.数据类型
整型，浮点数，字符串，时间和日期

5.切分
水平切分Sharding：将同一个表中的记录按行拆分到多个结构相同的表中。
垂直切分：将一张表按列切分成多个表
Sharding 策略
Sharding 存在的问题：事务问题，连接，ID 唯一性

6.复制
主从复制：涉及binlog 线程、I/O 线程和 SQL 线程。
读写分离：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

7.并发一致性问题
丢失修改:T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

读脏数据:T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
发生在未提交读

不可重复读:T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
发生在未提交读和提交读.不可重复读强调的是更新.

幻读:T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。
发生在未提交读和提交读

8.隔离级别
未提交读（READ UNCOMMITTED）:事务中的修改，即使没有提交，对其它事务也是可见的。

提交读（READ COMMITTED）:一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可重复读（REPEATABLE READ）:保证在同一个事务中多次读取同样数据的结果是一样的。

可串行化（SERIALIZABLE）:强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。

9.锁机制
记录锁:单个行记录上的锁
使用主键索引或唯一索引作查询条件更新的话会产生记录锁

间隙锁:锁定一个范围,不包含记录本身
没有建立索引或者是非唯一索引，搜索条件里有多个查询条件(即使每个列都有唯一索引)，都会产生间隙锁。
间隙锁的目的是为了防止幻读

通过两个方面实现：
（1）防止间隙内有新数据被插入
（2）防止已存在的数据，更新成间隙内的数据

innodb自动使用间隙锁的条件：
（1）必须在RR级别下
（2）检索条件必须有索引

Next-key锁:锁定一个范围,包含区间右索引
