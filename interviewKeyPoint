1.TCP和UDP
UDP丢包问题解决：包多的时候，要能保证接收端在收到数据后能立刻再次回到监听状态，委托回调；每个包不要携带过长的数据量，可以拆分成若干小包后在每个包头前编号；降低发送方发送包的速度。
UDP实现可靠传输：在应用层实现重传，确认和序号机制（利用包）。

TCP包最大1500B，UDP包最大64KB。

2.红黑树
jdk1.8：一个桶存储的链表长度大于 8 时会将链表转换为红黑树。
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 
（4）如果一个节点是红色的，则它的子节点必须是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
（5）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
插入和删除时自平衡，变色和旋转，时间复杂度O（logn）

3.I/O 复用：select/poll/epoll
select和poll比较:
差异：
select 会修改描述符，而 poll 不会；
select 的描述符类型使用数组实现，而 poll 的描述符类型使用链表实现；
poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高；
几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

select 和 poll 的功能基本相同：
如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
select 和 poll 速度都比较慢。
select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。
select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。

epoll：
红黑树。
只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。
仅适用于 Linux OS。
epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。
epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
epoll 中的所有描述符都存储在内核中。

工作模式：epoll 的描述符事件有两种触发模式：LT和 ET。

应用场景：
select 更加适用于实时性要求比较高的场景，可移植性更好，几乎被所有主流平台所支持。
poll 没有最大描述符数量的限制。
epoll 只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。

4.单例模式Singleton
保证一个类中有一个实例,并提供一个访问它的全局访问点。

做法：
私有构造函数
私有静态变量
公有静态函数

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

懒汉式-线程不安全：延迟实例化在多线程下 uniqueInstance 会被实例化多次。
饿汉式-线程安全：直接实例化 uniqueInstance。
懒汉式：对 getUniqueInstance() 方法加锁。线程阻塞时间过长。
双重校验锁：两次校验中加上 synchronized (Singleton.class)。uniqueInstance 采用 volatile 关键字修饰。
静态内部类：在静态内部类中声明和初始化 uniqueInstance。
枚举：可以防止反射攻击。能应对对序列化和反序列化。

5.LRU
新的加到链表头，尾删除，有重复的摘下来放到链表头

6.重写equals为什么要重写hashCode
Object默认的hashcode方法是根据对象的内存地址经哈希算法得来的。
两个对象equals，hashcode一定相等。为了满足这个条件需要重写hashCode。









有什么想问的：
1.进去之后会接触到什么技术？
2.多久可以知道面试结果？
3.对我的表现有什么评价？
