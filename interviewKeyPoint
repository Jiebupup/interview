1.TCP和UDP
UDP丢包问题解决：包多的时候，要能保证接收端在收到数据后能立刻再次回到监听状态，委托回调；每个包不要携带过长的数据量，可以拆分成若干小包后在每个包头前编号；降低发送方发送包的速度。
UDP实现可靠传输：在应用层实现重传，确认和序号机制（利用包）。

TCP包最大1500B，UDP包最大64KB。

2.Hashmap
数组+链表，16个桶。
Entry存储key-value对，拉链法解决冲突（头插法）。
桶数小，数据量大，趋于线性查找，时间复杂度度O（n）。
avl树，二三树。

jdk1.8红黑树：一个桶存储的链表长度大于 8 时会将链表转换为红黑树。
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 
（4）如果一个节点是红色的，则它的子节点必须是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
（5）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
插入和删除时自平衡，变色和旋转，时间复杂度O（logn）

与HashTable 的比较：
HashTable 使用 synchronized 来进行同步。
HashMap 可以插入键为 null 的 Entry。
HashMap 的迭代器是 fail-fast 迭代器。
HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
ConcurrentHashMap

3.I/O 复用：select/poll/epoll
select/poll比较：
select 会修改描述符，而 poll 不会；
select 的描述符类型使用数组实现，而 poll 的描述符类型使用链表实现；
poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高；
如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。select 和 poll 速度都比较慢;
几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

epoll:
红黑树;
仅适用于 Linux;
epoll 中的所有描述符都存储在内核中；
epoll 比 select 和 poll 更加灵活而且没有描述符数量限制;
epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。
epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
epoll 的描述符事件有两种触发模式：LT和ET。

应用场景：
select 更加适用于实时性要求比较高的场景，select 可移植性更好，几乎被所有主流平台所支持。
poll 没有最大描述符数量的限制。
epoll只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。

4.static
编译时静态绑定，随着类的加载而加载的，因此可以直接用类进行访问。 
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，静态变量在内存中只存在一份。
静态方法：不依赖于任何实例，必须有实现，只能访问所属类的静态变量和静态方法。从内存的角度上静态方法不可以被重写。

5.单例模式Singleton
确保一个类只有一个实例，并提供该实例的全局访问点。
使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

懒汉式（线程不安全->安全） 饿汉式 
双重校检锁 
静态内部类

6.LRU
新的加到链表头，尾删除，有重复的摘下来放到链表头

7.重写equals为什么要重写hashCode
Object默认的hashcode方法是根据对象的内存地址经哈希算法得来的。
两个对象equals，hashcode一定相等。为了满足这个条件需要重写hashCode。









有什么想问的
1.实习进去之后会接触到什么技术？
2.如何知道自己是否通过面试？
3.对我的表现有什么评价？
