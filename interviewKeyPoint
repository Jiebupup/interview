1.多态
编译时多态主要指方法的重载
运行时多态指同一个方法在运行时根据对象引用的不同类型产生不同的表现。
条件：继承，重写，向上转型。

例子：普通员工类和经理类是员工类的子类，使用父类来引用普通员工类和经理类对象，并调用设置工资方法，会执行子类的方法。

2.TCP和UDP
传输层协议，端到端
UDP无连接，面向报文
TCP有连接，提供可靠的服务（通过序号，确认和重传机制），面向字节流，通过滑动窗口实现流量控制，拥塞控制（慢开始与拥塞避免，快重传与快恢复），全双工通信
TCP的三次握手和四次挥手

UDP丢包问题解决：包多的时候，要能保证接收端在收到数据后能立刻再次回到监听状态，委托回调；每个包不要携带过长的数据量，可以拆分成若干小包后在每个包头前编号；降低发送方发送包的速度。
UDP实现可靠传输：在应用层实现重传，确认和序号机制（利用包）。
报文首部：UDP8B，源端口，目的端口，首部+数据长度，检验和；TCP最少20B，源端口，目的端口，序号，确认号，首部长度，6位，窗口，检验和，选项。

TCP包最大1500B，UDP包最大64KB。

3.Hashmap
数组+链表，16个桶。
Entry存储key-value对，拉链法解决冲突（头插法）。
桶数小，数据量大，趋于线性查找，时间复杂度度O（n）。
avl树，二三树。

jdk1.8红黑树：一个桶存储的链表长度大于 8 时会将链表转换为红黑树。
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 
（4）如果一个节点是红色的，则它的子节点必须是黑色的。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
（5）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
插入和删除时自平衡，变色和旋转，时间复杂度O（logn）

与HashTable 的比较：
HashTable 使用 synchronized 来进行同步。
HashMap 可以插入键为 null 的 Entry。
HashMap 的迭代器是 fail-fast 迭代器。
HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
ConcurrentHashMap

4.UNP
I/O模型：阻塞式 I/O，非阻塞式 I/O，I/O 复用，信号驱动 I/O，异步 I/O
五大 I/O 模型比较：UNPp127

I/O 复用：select/poll/epoll
select/poll比较：
select 会修改描述符，而 poll 不会；
select 的描述符类型使用数组实现，而 poll 的描述符类型使用链表实现；
poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高；
如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。select 和 poll 速度都比较慢;
几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

epoll:
红黑树;
仅适用于 Linux;
epoll 中的所有描述符都存储在内核中；
epoll 比 select 和 poll 更加灵活而且没有描述符数量限制;
epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。
epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
epoll 的描述符事件有两种触发模式：LT和ET。

应用场景：
select 更加适用于实时性要求比较高的场景，select 可移植性更好，几乎被所有主流平台所支持。
poll 没有最大描述符数量的限制。
epoll只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。

5.进程间通信
（1）管道
（2）FIFO，也称为命名管道，它是一种文件类型。
FIFO可以在无关的进程之间交换数据，与无名管道不同。
FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

（3）消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

（4）信号量，一个计数器，用于实现进程间的互斥与同步。
信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

（5）共享内存，指两个或多个进程共享一个给定的存储区。
共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
因为多个进程可以同时操作，所以需要进行同步。
信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

五种方式总结：
管道：速度慢，容量有限，只有父子进程能通讯    
FIFO：任何进程间都能通讯，但速度慢    
消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
信号量：不能传递复杂消息，只能用来同步    
共享内存区：能够很容易控制容量，速度快，但要保持同步

6.static
编译时静态绑定，随着类的加载而加载的，因此可以直接用类进行访问。 
静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，静态变量在内存中只存在一份。
静态方法：不依赖于任何实例，必须有实现，只能访问所属类的静态变量和静态方法。从内存的角度上静态方法不可以被重写。

7.单例模式Singleton
确保一个类只有一个实例，并提供该实例的全局访问点。
使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

懒汉式（线程不安全->安全） 饿汉式 
双重校检锁 
静态内部类

8.LRU
新的加到链表头，尾删除，有重复的摘下来放到链表头

9.设计模式
SOLID
S（单一功能原则）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。
O（开闭原则）软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。
L（里氏替换原则）派生类必须能完全取代其基类
I（接口隔离原则） 客户不依赖于他不使用的方法。
D(控制反转原则)高层级的模块不应该依赖于低层级的模块，他们应该都依赖于抽象。细节依赖于抽象，而不是抽象依赖于细节。

10.死锁
线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。
死锁产生的条件：互斥，请求和保持，不剥夺，循环等待

死锁的避免：
加锁顺序：如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。
加锁时限：在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行。
死锁检测

11.观察者模式
一对多依赖关系，每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。
优点：观察者的数量动态可变。对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。观察者和被观察者之间松耦合。满足开-闭原则。
缺点：观察者对象很多的话，将所有的观察者都通知到会花费很多时间。被观察者之间有循环依赖会导致系统崩溃。只发送通知不能了解到观察者发生的具体变化。

观察者模式被广泛应用于游戏引擎的事件系统。

12.重写equals为什么要重写hashCode
Object默认的hashcode方法是根据对象的内存地址经哈希算法得来的。
两个对象equals，hashcode一定相等。为了满足这个条件需要重写hashCode。

13.静态代理和动态代理
静态代理
优点：可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。
缺点：因为代理对象，需要实现与目标对象一样的接口，接口与代理类是1对1的，会导致代理类十分繁多，不易维护，同时一旦接口增加方法，则目标对象和代理类都需要维护。

动态代理：使用了反射
优点：代理对象无需实现接口，免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需在事件处理器中添加对方法的判断即可。
缺点：代理对象不需要实现接口，但是目标对象一定要实现接口，否则无法使用JDK动态代理。






有什么想问的
1.实习进去之后会接触到什么技术？
2.如何知道自己是否通过面试？
3.对我的表现有什么评价？





























































