String:length()长度，charAt()字符,substring(begin,end)子串,compareTo()比较,equals()相等,indexOf()匹配,split()分割,trim()删除头尾空白符

stack:Stack<Integer> stack = new Stack<Integer>();
isEmpty() push() pop() peek() 

queue:Queue<Integer> q=new LinkedList<>();
isEmpty() size() offer() poll() add() remove()

PriorityQueue<Integer> pq=new PriorityQueue<>();
isEmpty() size() offer() poll() add() remove() peek()

Collections:reverse()反转,shuffle()随机排序,sort()排序,swap()交换,rotate()旋转,binarySearch()二分查找,max()最大,fill()填充,frequency()统计次数,indexOfSubList()子集合出现的位置,replaceAll()用新元素代替旧元素。                    
Arrays:sort()排序，binarySearch()二分查找，equals()相等，fill()填充，asList()转成列表，toString()转成字符串，copyOf()复制数组。

TreeSet:floor(val)返回小于val的值,ceiling()大于。

ArrayList:clear()清空,stream().mapToInt(Integer::intValue).toArray()转化为int[]。

1.插入:
public void insertSort(int[] a){
    for(int i=1;i<a.length;i++){
        int tmp=a[i];
        int j=i-1;
        while(j>=0&&a[j]>tmp){
            a[j+1]=a[j];
            j--;
        }
        a[j+1]=tmp;
    }
}

希尔：
public void shellSort(int[] a){
    int n=1;
    while(n<a.length/3){
        n=3*n+1;
    }
    while(n>=1){
        for(int i=n;i<a.length;i++){
            for(int j=i;j>=n&&a[j]<a[j-n];j-=n){
                int tmp=a[j];
                a[j]=a[j-n];
                a[j-n]=tmp; 
            }
        }
        n/=3;
    }
}

2.交换
冒泡：
public void bubbleSort(int[] a){
    boolean isSorted=false; 
    for(int i=a.length-1;i>0&&!isSorted;i--){
        isSorted=true;
        for(int j=0;j<i;j++){
            if(a[j]>a[j+1]){
                isSorted=false;
                int tmp=a[j];
                a[j]=a[j+1];
                a[j+1]=tmp; 
            }
        }
    }
}

快排：
private int partiton(int[] a,int l,int r) {
    int i=l,j=r,pivot=a[l];
    while(i<j){
        while(i<j&&a[j]>=pivot) j--;
        a[i]=a[j];
        while(i<j&&a[i]<=pivot) i++;
        a[j]=a[i];
    }
    a[i]=pivot;
    return i;
}
public void quickSort1(int[] a,int l,int r){
    if(l<r){
        int idx=Partition(a,l,r);
        QuickSort(a,l,idx-1);
        QuickSort(a,idx+1,r);
    }
}
    
public void quickSort2(int[] a,int l,int r){
    if(l<r){
        int i=l,j=r,pivot=a[i];
        while(i<j){
            while(i<j&&a[j]>=pivot) j--;
            if(i<j) a[i++]=a[j];
            while(i<j&&a[i]<=pivot) i++;
            if(i<j) a[i]=a[j--];
        }
        a[i]=pivot;
        QuickSort2(a,l,i-1); 
        QuickSort2(a,i+1,r);
    }
}

三路快排
快速选择

稳定版：创建一个数组存储要交换的数据，记录位置信息

3.选择:
public void selectSort(int[] a){
    for(int i=0;i<a.length-1;i++){
        int min=i;
        for(int j=i+1;j<a.length;j++){
            if(a[j]<a[min]) min=j;
        }
        int tmp=a[i];
        a[i]=a[min];
        a[min]=tmp;
    }
}

堆排序：java的PriorityQueue默认小根堆
private int[] buildMaxHeap(int[] a){
    for(int i=a.length/2;i>=0;i--){
        adjust(a,a.length,i);
    }
    return a;
}

private void adjust(int[] a,int len,int idx){       //向下调整
    int tmp=a[idx];
    for(int i=2*idx+1;i<len-1;i=i*2+1){
        if(i<len&&a[i]<a[i+1]) i++;
        if(a[i]<=tmp) break;
        a[k]=a[i];
        k=i;
    }
    a[k]=tmp;
}

public void heapSort(int[] a){
    a=buildMaxHeap(a);
    for(int i=a.length-1;i>=1;i--){
        int tmp=a[0];
        a[0]=a[i];
        a[i]=tmp;
        adjust(a,i,0;)
    }
}

private void delete(int[] a){
    a[0]=a[a.length-1];
    a[a.length-1]=Integer.MIN_VALUE;
    adjust(a,a.length,0);
}

private void insert(int[] a,int n){                 //向上调整
    a[a.length]=n;
    int k=a.length,parent=(k-1)/2;
    while(parent>=0&&n>a[parent]){
        a[k]=a[parent];
        k=parent;
        if(parent==0) break;
        parent=(parent-1)/2;
    }
    a[k]=n;
}

4.归并:
private void merge(int[] a,int l,int m,int h){
    int[] tmp=new int[h-l+1];
    int i=l,j=m+1,k=0;
    while(i<=mid&&j<=h){
        if(a[i]<a[j]) tmp[k++]=a[i++];
        else tmp[k++]=a[j++];
    }
    while(i<=mid) tmp[k++]=a[i++];
    while(j<=h) tmp[k++]=a[j++];
    for(int n=0;n<tmp.length;n++){
        a[l+n]=tmp[n];
    }
}

public void mergeSort(int[] a,int l,int h){
    if(l<h){
        int m=l+(h-l)>>1;
        mergeSort(a,l,m);
        mergeSort(a,m+1,h);
        merge(a,l,m,h);
    }
}

5.二分查找
public int binarySearch1(int[] a, int n) {
    int i=0,j=a.length-1;
    while(i<=j){
        int mid=i+(j-i)>>1;
        if(a[mid]<n) i=mid+1;
        else if(a[mid]>n)j=mid-1;
        else return mid;
    }
    return -1;
}

public int binarySearch2(int[] a, int n) {
    int i=0,j=a.length-1;
    while(i<j){
        int mid=i+(j-i)>>1;
        if(a[mid]<n) i=mid+1;
        else j=mid;
    }
    return i;
}

6.单例模式
双检锁
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
静态内部类
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
枚举
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}

7.四则运算计算器
public int calculate(String s){
    if(s==null||s.length()<1) return 0;
    int num=0,res=0;
    char op='+';    
    Stack<Integer> stack=new Stack<>();
    for(int i=0;i<s.length();i++){
        if(Character.isDigit(s.charAt(i))) num=num*10+s.charAt(i)-'0';
        else if(s[i]=='('){
            int cnt=0;
            int j=i;
            for(;i<s.length();i++){
                if(s[i]=='(') cnt++;
                if(s[i]==')') cnt--;
                if(cnt==0) break;
            }
            num=calculate(s.substring(j+1,i-j-1));
        }
        if(!Character.isDigit(s.charAt(i))&&s.charAt(i)!=' '||i==s.length()-1){
            if(op=='+') stack.push(num);
            if(op=='-') stack.push(-num);
            if(op=='*') stack.push(stack.pop()*num);
            if(op=='/') stack.push(stack.pop()/num);
            op=s.charAt(i);
            num=0;
        }
    }
    for(int i:stack){
        res+=i;
    }
    return res;
}

8.代理模式
静态代理：
public interface Movie {
	void play();
}

public class RealMovie implements Movie {

	@Override
	public void play() {
		// TODO Auto-generated method stub
		System.out.println("您正在观看电影 《肖申克的救赎》");
	}

}

public class Cinema implements Movie {
	
	RealMovie movie;
	
	public Cinema(RealMovie movie) {
		super();
		this.movie = movie;
	}


	@Override
	public void play() {
		
		guanggao(true);
		
		movie.play();
		
		guanggao(false);
	}
	
	public void guanggao(boolean isStart){
		if ( isStart ) {
			System.out.println("电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！");
		} else {
			System.out.println("电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！");
		}
	}

}

public class ProxyTest {

	public static void main(String[] args) {
		
		RealMovie realmovie = new RealMovie();
		
		Movie movie = new Cinema(realmovie);
		
		movie.play();

	}

}
结果：
电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！
您正在观看电影 《肖申克的救赎》
电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！

JDK动态代理：
public interface Service {
	public void add();
	public void update();
}


public class AService implements Service {	
	public void add() {
		System.out.println("AService add>>>>>>>>>>>>>>>>>>");
	}
	public void update() {
		System.out.println("AService update>>>>>>>>>>>>>>>");
	}
}

public class MyInvocationHandler implements InvocationHandler {
	private Object target; 
	MyInvocationHandler() {
		super();
	} 
	MyInvocationHandler(Object target) {
		super();
		this.target = target;
	}
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// 程序执行前加入逻辑，MethodBeforeAdviceInterceptor
		System.out.println("before-----------------------------");
		// 程序执行
		Object result = method.invoke(target, args);
		// 程序执行后加入逻辑，MethodAfterAdviceInterceptor
		System.out.println("after------------------------------");
		return result;
	}
}

public class Test {
	public static void main(String[] args) {
		Service aService = new AService();
		MyInvocationHandler handler = new MyInvocationHandler(aService);
		// Proxy为InvocationHandler实现类动态创建一个符合某一接口的代理实例
		Service aServiceProxy = (Service) Proxy.newProxyInstance(aService.getClass().getClassLoader(), aService.getClass().getInterfaces(), handler);
		// 由动态生成的代理对象来aServiceProxy 代理执行程序，其中aServiceProxy 符合Service接口
		aServiceProxy.add();
		System.out.println();
		aServiceProxy.update();
	}
}
结果：
before-----------------------------
AService add>>>>>>>>>>>>>>>>>>
after------------------------------
before-----------------------------
AService update>>>>>>>>>>>>>>>
after------------------------------

CGLIB动态代理：
public class Base {
	//不需要定义目标类的统一接口
	public void add() {
		System.out.println("add ------------");
	}
}

public class CglibProxy implements MethodInterceptor {
	public Object intercept(Object object, Method method, Object[] args,MethodProxy proxy) throws Throwable {
		// 添加切面逻辑（advise），此处是在目标类代码执行之前，即为MethodBeforeAdviceInterceptor。
		System.out.println("before-------------");
		// 执行目标类add方法
		proxy.invokeSuper(object, args);
		// 添加切面逻辑（advise），此处是在目标类代码执行之后，即为MethodAfterAdviceInterceptor。
		System.out.println("after--------------");
		return null;
	}
}

public class Factory {
	public static Base getInstance(CglibProxy proxy) {
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(Base.class);
		//回调方法的参数为代理类对象CglibProxy，最后增强目标类调用的是代理类对象CglibProxy中的intercept方法
		enhancer.setCallback(proxy);
		// 此刻，base不是单纯的目标类，而是增强过的目标类
		Base base = (Base) enhancer.create();
		return base;
	}
}

public class Test {
	public static void main(String[] args) {
		CglibProxy proxy = new CglibProxy();
		// base为生成的增强过的目标类
		Base base = Factory.getInstance(proxy);
		base.add();
	}
}
结果：
before-------------
add ------------
after--------------

9.工厂模式
简单工厂：
public interface Shape {
    void draw();
}

public class Circle implements Shape {
    public Circle() {
        System.out.println("Circle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Circle");
    }
}

public class ShapeFactory {
    // 使用 getShape 方法获取形状类型的对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 获取 Circle 的对象，并调用它的 draw 方法
        Shape circle = ShapeFactory.getShape("CIRCLE");
        circle.draw();
    }
}
结果：
Circle
Draw Circle

反射改善满足开放-封闭原则：
public class ShapeFactory2 {
    public static Object getClass(Class<? extends Shape> clazz) {
        Object obj = null;
        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return obj;
    }
}

public class Test2 {
    public static void main(String[] args) {
        Circle circle = (Circle) ShapeFactory2.getClass(factory_pattern.Circle.class);
        circle.draw();
    }
}

工厂方法：
public abstract class Factory {
    abstract public Product createProduct();
    public void doSomething() {
        Product product = createProduct();
        // do something with the product
    }
}

public class FactoryMethod extends Factory {
    public Product createProduct() {
        return new factoryMethodProduct();
    }
}

public class Client {
    public static void main(String[] args) {
        FactoryMethod factoryMethod = new FactoryMethod();
        Product product = factoryMethod.createProduct();
        // do something with the product
    }
}

抽象工厂：

10.生产者消费者问题
