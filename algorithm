1.插入

2.交换

快排：
private int Partiton(int[] a,int l,int r) {
    int i=l,j=r,pivot=a[l];
    while(i<j){
        while(i<j&&pivot<=a[j]) j--;
        a[i]=a[j];
        while(i<j&&pivot>=a[i]) i++;
        a[j]=a[i];
    }
    a[i]=pivot;
    return i;
}
public void QuickSort1(int[] a,int l,int r){
    if(l<r){
        int idx=Partition(a,l,r);
        QuickSort(a,l,idx-1);
        QuickSort(a,idx+1,r);
    }
}
    
public void QuickSort2(int[] a,int l,int r){
    if(l<r){
        int i=l,j=r,pivot=a[l];
        while(i<j){
            while(i<j&&pivot<=a[j]) j--;
            if(i<j) a[i++]=a[j];
            while(i<j&&pivot>=a[i]) i++;
            if(i<j) a[i]=a[j--];
        }
        a[i]=pivot;
        QuickSort2(a,l,i-1); 
        QuickSort2(a,i+1,r);
    }
}

稳定版：创建一个数组存储要交换的数据，记录位置信息

3.选择

4.归并

5.二分查找
public int binarySearch1(int[] a, int n) {
    int i=0,j=a.length-1;
    while(i<=j){
        int mid=i+(j-i)>>1;
        if(a[mid]<n) i=mid+1;
        else if(a[mid]>n)j=mid-1;
        else return mid;
    }
    return -1;
}

public int binarySearch2(int[] a, int n) {
    int i=0,j=a.length-1;
    while(i<j){
        int mid=i+(j-i)>>1;
        if(a[mid]<n) i=mid+1;
        else j=mid;
    }
    return i;
}

6.单例模式
双检锁
public class Singleton{
    private volatile static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
    }
}
静态内部类
public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
}
枚举
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
