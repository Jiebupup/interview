1.多点登录和消息漫游
“多点登录”是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点；
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

“消息漫游”是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端；
每个端本地存储last_msg_id，在登录时可以到云端同步历史消息；
云端存储所有消息成本较高，一般会对历史消息时间(或者条数)进行限制。

2.两次点击，怎么防止重复下订单
在下单时产生订单号
阻止第二次点击并报错或者允许第二次点击：
（1）基于Redis的分布式锁:
服务器A接收到请求之后,获取锁,获取成功
服务器A进行业务处理,订单提交成功
服务器B接收到相同的请求,获取锁,失败。因为锁被服务器A获取了,并且未释放
服务器A处理完成,释放锁

（2）利用数据库unique约束：对请求信息求hash值

3.海量数据处理
先计算容量：1KB=2^10B 1E个整数占400MB
再拆分：可以将海量数据拆分到多台机器上和拆分到多个文件上
拆分的策略
按出现的顺序拆分：当有新数据到达时，先放进当前机器，填满之后再将数据放到新增的机器上。这种方法的优点是充分利用系统的资源，因为每台机器都会尽可能被填满。缺点是需要一个查找表来保存数据到机器的映射，查找表可能会非常复杂并且非常大。
按散列值拆分：优点是不需要使用查找表，缺点是可能会导致一台机器存储的数据过多，甚至超出它的最大容量。
按数据的实际含义拆分：优点是方便查找。缺点同样是需要使用查找表。
最后整合。

判重
HashSet：时间复杂度O(1)完成。
BitSet：要求海量数据是整数并且范围不大，还可以解决一个整数出现次数的问题。
布隆过滤器：空间开销极小，但会有一定的误判（将一个不存在的数判断为已经存在，可以使用白名单的方式进行补救）概率。先经过 k 个哈希函得到 k 个位置，并将 BitSet 中对应位置设置为 1。查找时所有k位置上都为 1，那么表示这个数据存在。
Trie字典树：字符串。

排序
外部排序：拆分后的数据装入内存并排序，合并时用多路归并方法。小顶堆解决合并节点仍然无法将所有数据读入内存的问题，并设置缓存应对频繁地读写磁盘。
BitMap：待排序的数据是整数，或者是其它范围比较小的数据。某个数据存在时就将对应的比特数组位置设置为 1，最后从头遍历比特数组就能得到一个排序的整数序列。只能处理数据不重复的情况，如果数据重复，就要将比特数组转换成整数数组用于计数，称为计数排序。
Trie字典树：字符串。按字典序先序遍历 Trie 树就能得到已排序的数据。为了处理数据重复问题，可以使用 Trie 树的节点存储计数信息。

TopK问题
第 K 大问题：先找到 Kth Element 之后，再遍历一遍，大于等于 Kth Element 的数都是 TopK Elements。
快速选择：时间复杂度 O(N)、空间复杂度 O(1)。允许修改数组元素。
堆排序：最大的TopK用小顶堆，时间复杂度 O(NlogK)，空间复杂度 O(K)。

最频繁出现的 K 个数
HashMap统计频率->TopK问题
Count-Min Sketch：类似于布隆过滤器，也具有一定的误差
Trie：节点保存出现的频率

分而治之/Hash映射 + HashMap统计 + 堆/快速/归并排序
Hash映射成多个小部分，HashMap计数各个部分并排序，最后归并或者最小堆生成最终结果。

多层划分

Bloom filter/Bitmap
位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。
一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。

Trie树/数据库/倒排索引

外排序

分布式处理之Hadoop/MapReduce
简单的说就是将大批量的工作（数据）分解（MAP）执行，Shuffle整合，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。Mapreduce的原理就是一个归并排序。

4.单元测试
测试驱动的开发(TDD)要求我们先写单元测试，再写实现代码。

一般使用Mockito的步骤:
模拟任何外部依赖并将这些模拟对象插入测试代码中
执行测试中的代码
验证代码是否按照预期执行

5.限流算法
如果一段时间内请求的数量过大，就会给服务器造成很大压力，可能导致服务器无法提供其它服务。

单机限流
计数器算法：通过一个计数器 counter 来统计一段时间内请求的数量，并且在指定的时间之后重置计数器。实现简单，但是有临界问题,在重置计数器的前后一小段时间内请求突增。
滑动窗口算法：是计数器算法的一种改进，将原来的一个时间窗口划分成多个时间窗口，并且不断向右滑动该窗口。在临界位置的突发请求都会被算到时间窗口内，因此可以解决计数器算法的临界问题。    
漏桶算法：能够以恒定速率处理请求。请求需要先放入缓存中，当缓存满了时，请求会被丢弃。
令牌桶算法：和漏桶算法的区别在于它是以恒定速率添加令牌，当一个请求到来时，先从令牌桶取出一个令牌，如果能取到令牌那么就可以处理该请求。令牌桶的大小有限，超过一定的令牌之后再添加进来的令牌会被丢弃。允许突发请求但是它不会出现临界问题。

集群限流：每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问/index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。

6.秒杀场景设计
要达到强一致性

架构原则
尽量将请求拦截在上游：对于秒杀系统来说，系统的瓶颈一般在数据库层，资源是有限的，所以为了更好的保护底层有限的数据库资源，尽量将请求拦截在上游。
充分利用缓存：缓存不但极大的提高了数据的访问效率，更重要的是承载了底层数据库的访问压力，所以对于读多写少的业务场景充分利用好缓存

热点隔离
业务隔离：将热点数据分散处理，来降低系统负载压力。
系统隔离：实现系统的软硬隔离，不光是实现软件的隔离，还可以实现硬件的隔离，尽最大限度的减少秒杀带来的高并发安全性问题。
数据隔离：启用单独的cache集群或数据库来存放热点数据。

优化方案
页面端优化：按钮置灰来禁止用户重复提交请求，通过JS控制在一定时间内只能提交一次请求。

web server层优化
动静分离：如将几乎不变的静态页面直接通过NG或CDN来路由访问，只有动态变换的页面可以请求到web server端
页面缓存化
Nginx反向代理实现web server端的水平扩展

后端service服务层优化
使用缓存（Redis、Memchched）：将读多写少的业务数据放入缓存，如秒杀业务中可以将更新频繁的商品库存信息放入Redis缓存处理，最好分为多份放入不同key的缓存中，这样将数据分散操作可以达到更高的读写性能。
使用队列处理：将请求放入队列排队处理，以可控的速度来访问底层DB
异步处理：如将秒杀成功的订单通知信息通过消息队列（RabbitMQ、Kafka）来异步处理

DB层优化
读写分离
分表分库
数据库集群

秒杀场景应付突然的爆发流量：消息队列削峰，分层过滤（CDN静动态资源划分和缓存）。

7.为什么用递归比用栈差？
递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。
递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分。

尾递归：在进入新的递归函数时，尾递归不再需要使用栈帧保存数据，允许抛弃旧的栈帧，那么只需要保存一个栈帧即可，能够有效解决 StackOverflowError。

8.软件测试
白盒测试也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。
黑盒测试又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。

黑盒测试方法：等价类划、边界值分析、因果图、错误推测
白盒测试方法：程序结构分析、逻辑覆盖测试、基本路径测试

单元测试属于白盒测试。

9.扫二维码登录过程
传统的登录方式需要用户在浏览器中输入账号密码，完成输入之后点击登录按钮将这些数据发送到服务器上，服务器对这些数据进行验证并返回特定的状态码和 Cookie 等信息给浏览器。
扫二维码登录方式不需要用户输入账号密码，这些信息保存在手机 APP 中，并由 APP 发送到服务器上。

登录二维码包含了服务器的 URL 地址，也包含了 uuid 参数。当用户使用手机 APP 扫描二维码登录之后，发送用户名、密码、uuid 等信息给服务器，服务器验证之后就将 uuid 和该账户关联并保存到 Session 中。
浏览器需要不断地向服务器发送 AJAX 请求，该请求包含了 uuid 参数，当查询到服务器已经存在 uuid 和账户的关联信息之后，就可以知道是某个账户扫描了该二维码登录，服务器返回 200 成功状态码、Cookie 和账户信息等数据，浏览器接收到这些数据之后就可以完成登录操作。
应该注意到，为了使的浏览器能不断发送 AJAX 请求，建立的 HTTP 连接需要是长连接。

10.Web 页面请求过程
输入网址
浏览器查找域名的IP地址。DNS查找过程：浏览器缓存、系统缓存、路由器缓存、ISP DNS缓存、递归搜索
浏览器发起端口80的TCP连接（三次握手）。
浏览器给服务器发送一个HTTP请求
服务器接收并处理请求，返回HTML响应。
浏览器显示HTML，获取嵌入在HTML的对象

高并发下，为满足低响应时间和高吞吐量，伸缩性、扩展性、可用性、安全性等要求，网站普遍使用缓存和集群等技术。
缓存减轻服务器的压力并降低响应时间。
集群使用负载均衡器将请求转发到集群中的某个服务器上，避免单一服务器的负载压力过大导致性能降低。

11.短网址生成系统TinyURL
过长的网址不利于传播，TinyURL可以将一个网址变短。在浏览器中输入短网址之后，TinyURL 会将该短网址转换成原始网址并进行重定向。
生成短网址：https://tinyurl.com/ID
映射：为了让原始网址和短网址能一一对应，就需要存储双向映射。映射关系可以表示为键值对，可以使用 LevelDB 这种基于磁盘的键值存储系统来存储海量键值对数据，而使用 Redis 作为缓存。
重定向：TinyURL 会将输入的短网址转换为原始网址并进行重定向，HTTP 主要有两种重定向方式：永久重定向 301 和临时重定向 302。如果使用 301 的话，搜索引擎会直接展示原始网址，那么 TinyURL 就无法收集用户的 User Agent 等信息。这些信息可以用来做一些大数据分析，从而为 TinyURL 带来收益，所以需要使用 302 重定向。
