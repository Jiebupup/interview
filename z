1.多点登录和消息漫游
“多点登录”是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点；
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

“消息漫游”是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端；
每个端本地存储last_msg_id，在登录时可以到云端同步历史消息；
云端存储所有消息成本较高，一般会对历史消息时间(或者条数)进行限制。

2.两次点击，怎么防止重复下订单
在下单时产生订单号
阻止第二次点击并报错或者允许第二次点击：
（1）基于Redis的分布式锁:
服务器A接收到请求之后,获取锁,获取成功
服务器A进行业务处理,订单提交成功
服务器B接收到相同的请求,获取锁,失败。因为锁被服务器A获取了,并且未释放
服务器A处理完成,释放锁

（2）利用数据库unique约束：对请求信息求hash值

3.单元测试
测试驱动的开发(TDD)要求我们先写单元测试，再写实现代码。

一般使用Mockito的步骤:
模拟任何外部依赖并将这些模拟对象插入测试代码中
执行测试中的代码
验证代码是否按照预期执行

4.软件测试
白盒测试也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。
黑盒测试又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。

黑盒测试方法：等价类划、边界值分析、因果图、错误推测
白盒测试方法：程序结构分析、逻辑覆盖测试、基本路径测试

单元测试属于白盒测试。

5.秒杀场景设计
要达到强一致性

架构原则
尽量将请求拦截在上游：对于秒杀系统来说，系统的瓶颈一般在数据库层，资源是有限的，所以为了更好的保护底层有限的数据库资源，尽量将请求拦截在上游。
充分利用缓存：缓存不但极大的提高了数据的访问效率，更重要的是承载了底层数据库的访问压力，所以对于读多写少的业务场景充分利用好缓存

热点隔离
业务隔离：将热点数据分散处理，来降低系统负载压力。
系统隔离：实现系统的软硬隔离，不光是实现软件的隔离，还可以实现硬件的隔离，尽最大限度的减少秒杀带来的高并发安全性问题。
数据隔离：启用单独的cache集群或数据库来存放热点数据。

优化方案
页面端优化：按钮置灰来禁止用户重复提交请求，通过JS控制在一定时间内只能提交一次请求。

web server层优化
动静分离：如将几乎不变的静态页面直接通过NG或CDN来路由访问，只有动态变换的页面可以请求到web server端
页面缓存化
Nginx反向代理实现web server端的水平扩展

后端service服务层优化
使用缓存（Redis、Memchched）：将读多写少的业务数据放入缓存，如秒杀业务中可以将更新频繁的商品库存信息放入Redis缓存处理，最好分为多份放入不同key的缓存中，这样将数据分散操作可以达到更高的读写性能。
使用队列处理：将请求放入队列排队处理，以可控的速度来访问底层DB
异步处理：如将秒杀成功的订单通知信息通过消息队列（RabbitMQ、Kafka）来异步处理

DB层优化
读写分离
分表分库
数据库集群

秒杀场景应付突然的爆发流量：消息队列削峰，分层过滤（CDN静动态资源划分和缓存）。

6.Web 2.0，指的是一个利用万维网（Web）的平台，一个由用户主导而生成内容的互联网产品模式，且为了区别传统由网站雇员主导生成的内容而定义的。

7.单点登录 
SSO：在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。

单系统登录：Session 保存用户信息
用户登录时，验证用户的账户和密码
生成一个 Token 保存在数据库中，将 Token 写到 Cookie 中
将用户数据保存在 Session 中
请求时都会带上 Cookie，检查有没有登录，如果已经登录则放行

多系统：Session 不共享
SSO 系统生成一个 token，并将用户信息存到 Redis 中，并设置过期时间
其他系统请求 SSO 系统进行登录，得到 SSO 返回的 token，写到 Cookie 中
每次请求时，Cookie 都会带上，拦截器得到 token，判断是否已经登录

变化：将登陆功能抽取为一个系统（SSO），其他系统请求 SSO 进行登录本来将用户信息存到 Session，现在将用户信息存到 Redis。

Cookie 不能跨域的解决方案：
服务端将 Cookie 写到客户端后，客户端对 Cookie 进行解析，将 Token 解析出来，此后请求都把这个 Token 带上就行了
多个域名共享 Cookie，在写到客户端的时候设置 Cookie 的 domain。
将 Token 保存在 SessionStroage 中（不依赖 Cookie 就没有跨域的问题了）

CAS（Central Authentication Service）：SSO 认证中心类似一个中转站。
