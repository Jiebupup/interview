1.多点登录和消息漫游
“多点登录”是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点；
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

“消息漫游”是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端；
每个端本地存储last_msg_id，在登录时可以到云端同步历史消息；
云端存储所有消息成本较高，一般会对历史消息时间(或者条数)进行限制。

2.两次点击，怎么防止重复下订单
在下单时产生订单号
阻止第二次点击并报错或者允许第二次点击：
（1）基于Redis的分布式锁:
服务器A接收到请求之后,获取锁,获取成功
服务器A进行业务处理,订单提交成功
服务器B接收到相同的请求,获取锁,失败。因为锁被服务器A获取了,并且未释放
服务器A处理完成,释放锁

（2）利用数据库unique约束：对请求信息求hash值

3.海量数据处理
分而治之/Hash映射 + HashMap统计 + 堆/快速/归并排序
Hash映射成多个小部分，HashMap计数各个部分并排序，最后归并或者最小堆生成最终结果。

多层划分

Bloom filter/Bitmap
位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。
一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。

Trie树/数据库/倒排索引

外排序

分布式处理之Hadoop/Mapreduce
简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。Mapreduce的原理就是一个归并排序。

4.单元测试
测试驱动的开发(TDD)要求我们先写单元测试，再写实现代码。

一般使用Mockito的步骤:
模拟任何外部依赖并将这些模拟对象插入测试代码中
执行测试中的代码
验证代码是否按照预期执行

5.限流算法
单机限流
令牌桶算法：是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择等待可用的令牌，或者直接拒绝。
漏桶算法：漏桶作为计量工具，无论输入多大，输出是恒定的。可以用于流量整形和流量控制。消除"突刺现象"（如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝）。无法应对短时间的突发流量。
计数器算法：累加到一定值后后续请求会被拒绝。存在"突刺现象"。

集群限流：每次有相关操作的时候，就向redis服务器发送一个incr命令，比如需要限制某个用户访问/index接口的次数，只需要拼接用户id和接口名生成redis的key，每次该用户访问此接口时，只需要对这个key执行incr命令，在这个key带上过期时间，就可以实现指定时间的访问频率。
