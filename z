1.多点登录和消息漫游
“多点登录”是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点；
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

“消息漫游”是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端；
每个端本地存储last_msg_id，在登录时可以到云端同步历史消息；
云端存储所有消息成本较高，一般会对历史消息时间(或者条数)进行限制。

2.降级处理hystrix
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。 
高峰期，为了保证核心服务正常运行，需要停掉一些不太重要的业务，或者某些服务不可用时，执行备用逻辑从故障服务中快速失败或快速返回，以保障主体业务不受影响。
Hystrix提供的降级主要是为了容错，保证当前服务不受依赖服务故障的影响

Hystrix在以下几种情况下会走降级逻辑：
执行construct()或run()抛出异常
熔断器打开导致命令短路
命令的线程池和队列或信号量的容量超额，命令被拒绝
命令执行超时

降级回退方式：
Fail Fast 快速失败：快速失败是最普通的命令执行方法，命令没有重写降级逻辑。 如果命令执行发生任何类型的故障，它将直接抛出异常。
Fail Silent 无声失败：指在降级方法中通过返回null，空Map，空List或其他类似的响应来完成。
Fallback: Static：指在降级方法中返回静态默认值。 这不会导致服务以“无声失败”的方式被删除，而是导致默认行为发生。如：应用根据命令执行返回true / false执行相应逻辑，但命令执行失败，则默认为true。
Fallback: Stubbed：当命令返回一个包含多个字段的复合对象时，适合以Stubbed 的方式回退。
Fallback: Cache via Network：有时，如果调用依赖服务失败，可以从缓存服务（如redis）中查询旧数据版本。由于又会发起远程调用，所以建议重新封装一个Command，使用不同的ThreadPoolKey，与主线程池进行隔离。
Primary + Secondary with Fallback：有时系统具有两种行为- 主要和次要，或主要和故障转移。主要和次要逻辑涉及到不同的网络调用和业务逻辑，所以需要将主次逻辑封装在不同的Command中，使用线程池进行隔离。
为了实现主从逻辑切换，可以将主次command封装在外观HystrixCommand的run方法中，并结合配置中心设置的开关切换主从逻辑。由于主次逻辑都是经过线程池隔离的HystrixCommand，因此外观HystrixCommand可以使用信号量隔离，而没有必要使用线程池隔离引入不必要的开销。

3.两次点击，怎么防止重复下订单
在下单时产生订单号
阻止第二次点击并报错或者允许第二次点击：
（1）基于Redis的分布式锁:
服务器A接收到请求之后,获取锁,获取成功
服务器A进行业务处理,订单提交成功
服务器B接收到相同的请求,获取锁,失败。因为锁被服务器A获取了,并且未释放
服务器A处理完成,释放锁

（2）利用数据库unique约束：对请求信息求hash值

4.海量数据处理
分而治之/Hash映射 + HashMap统计 + 堆/快速/归并排序
Hash映射成多个小部分，HashMap计数各个部分并排序，最后归并或者最小堆生成最终结果。

多层划分

Bloom filter/Bitmap
位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。
一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。

Trie树/数据库/倒排索引

外排序

分布式处理之Hadoop/Mapreduce
简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。Mapreduce的原理就是一个归并排序。

5.单元测试
测试驱动的开发(TDD)要求我们先写单元测试，再写实现代码。

一般使用Mockito的步骤:
模拟任何外部依赖并将这些模拟对象插入测试代码中
执行测试中的代码
验证代码是否按照预期执行
