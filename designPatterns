1.单例模式
保证一个类中有一个实例,并提供一个访问它的全局访问点。

做法：
将构造方法私有化。
在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。
定义一个静态方法返回这个唯一对象。

2.策略模式
能够根据所传递的参数对象的不同而具有不同行为

3.观察者模式
一对多依赖关系，每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。
优点：观察者的数量动态可变。对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。观察者和被观察者之间松耦合。满足开-闭原则。
缺点：观察者对象很多的话，将所有的观察者都通知到会花费很多时间。被观察者之间有循环依赖会导致系统崩溃。只发送通知不能了解到观察者发生的具体变化。

观察者模式被广泛应用于游戏引擎的事件系统。

4.适配器模式
接受拥有的的接口，并产生需要的接口。

5.工厂方法模式
生成遵循某个接口的对象。
与直接调用构造器不同，在工厂对象上调用的是创建方法，并由该工厂对象生成接口的某个实现对象。将对象的创建工作交给类自己完成。

6.迭代器设计模式
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

7.模板模式
模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。模板方法是保持不变的，可覆盖的方法是变化的。

8.命令模式
将命令封装成对象中，具有以下作用：
使用命令来参数化其它对象
将命令放入队列中进行排队
将命令的操作记录到日志中
支持可撤销的操作

9.代理模式
为了提供额外的或不同的操作，插入的用来代替实际对象的对象。

10.装饰器模式
使用组合和形式化结构，允许向一个现有的对象添加新的功能,同时又不改变其结构。

11.享元模式
使得对象的一部分可被具体化，在更加高效的外部表中查找对象的一部分或整体（或通过某些其他节省空间的计算来产生对象的一部分或整体）。
