1.单例模式
保证一个类中有一个实例,并提供一个访问它的全局访问点。

做法：
私有构造函数
私有静态变量
公有静态函数

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

懒汉式-线程不安全：延迟实例化在多线程下 uniqueInstance 会被实例化多次。
饿汉式-线程安全：直接实例化 uniqueInstance。
懒汉式：对 getUniqueInstance() 方法加锁。线程阻塞时间过长。
双重校验锁：两次校验中加上 synchronized (Singleton.class)。uniqueInstance 采用 volatile 关键字修饰。
静态内部类：在静态内部类中声明和初始化 uniqueInstance。
枚举：可以防止反射攻击。能应对对序列化和反序列化。

2.策略模式
定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。
能够根据所传递的参数对象的不同而具有不同行为

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。
但是状态模式是通过状态转移（指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变）来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。

3.观察者模式
定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
主题（Subject）是被观察的对象。主题具有注册和移除观察者、并通知所有观察者的功能，通过维护一张观察者列表来实现这些操作的。

优点：观察者的数量动态可变。对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。观察者和被观察者之间松耦合。满足开-闭原则。
缺点：观察者对象很多的话，将所有的观察者都通知到会花费很多时间。被观察者之间有循环依赖会导致系统崩溃。只发送通知不能了解到观察者发生的具体变化。

观察者模式被广泛应用于游戏引擎的事件系统。

4.适配器模式
把一个类接口转换成另一个用户需要的接口。

5.工厂方法模式
定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
与直接调用构造器不同，在工厂对象上调用的是创建方法，并由该工厂对象生成接口的某个实现对象。将对象的创建工作交给类自己完成。

在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。
抽象工厂模式创建的是对象家族，而工厂方法模式只是用于创建一个对象。

6.迭代器设计模式
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

7.模板模式
定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

8.命令模式
将命令封装成对象中，具有以下作用：
使用命令来参数化其它对象
将命令放入队列中进行排队
将命令的操作记录到日志中
支持可撤销的操作

9.代理模式
为了提供额外的或不同的操作，插入的用来代替实际对象的对象。控制对其它对象的访问。

10.装饰器模式
使用组合和形式化结构，允许向一个现有的对象动态地添加新的功能,同时又不改变其结构。

11.享元模式
利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。
使得对象的一部分可被具体化，在更加高效的外部表中查找对象的一部分或整体（或通过某些其他节省空间的计算来产生对象的一部分或整体）。
