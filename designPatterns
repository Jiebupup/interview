1.单例模式
保证一个类中有一个实例,并提供一个访问它的全局访问点。

做法：
私有构造函数
私有静态变量
公有静态函数

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

懒汉式-线程不安全：延迟实例化在多线程下 uniqueInstance 会被实例化多次。
饿汉式-线程安全：直接实例化 uniqueInstance。
懒汉式：对 getUniqueInstance() 方法加锁。线程阻塞时间过长。
双重校验锁：两次校验中加上 synchronized (Singleton.class)。uniqueInstance 采用 volatile 关键字修饰。
静态内部类：在静态内部类中声明和初始化 uniqueInstance。
枚举：可以防止反射攻击。能应对对序列化和反序列化。

2.策略模式
定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。
能够根据所传递的参数对象的不同而具有不同行为

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。
但是状态模式是通过状态转移（指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变）来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。

3.观察者模式
定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
主题（Subject）是被观察的对象。主题具有注册和移除观察者、并通知所有观察者的功能，通过维护一张观察者列表来实现这些操作的。

优点：观察者的数量动态可变。对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。观察者和被观察者之间松耦合。满足开-闭原则。
缺点：观察者对象很多的话，将所有的观察者都通知到会花费很多时间。被观察者之间有循环依赖会导致系统崩溃。只发送通知不能了解到观察者发生的具体变化。

观察者模式被广泛应用于游戏引擎的事件系统。

4.适配器模式
把一个类接口转换成另一个用户需要的接口。

5.工厂方法模式
定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
与直接调用构造器不同，在工厂对象上调用的是创建方法，并由该工厂对象生成接口的某个实现对象。将对象的创建工作交给类自己完成。

在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。
抽象工厂模式创建的是对象家族，而工厂方法模式只是用于创建一个对象。

6.迭代器设计模式
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

7.模板模式
定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

8.命令模式
将命令封装成对象中，具有以下作用：
使用命令来参数化其它对象
将命令放入队列中进行排队
将命令的操作记录到日志中
支持可撤销的操作

9.代理模式
代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 
按照代理的创建时期，代理类可以分为两种。 
静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。每一个代理类只能为一个接口服务，会产生过多的代理和重复代码。

动态代理：在程序运行时，运用反射机制动态创建而成。 一个代理类完成全部的代理功能。
JDK的动态代理依靠接口实现
cglib是针对类来实现代理，使用继承，对指定的目标类生成一个子类，并覆盖其中方法实现增强

10.装饰器模式
使用组合和形式化结构，允许向一个现有的对象动态地添加新的功能,同时又不改变其结构。

11.享元模式
利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。
使得对象的一部分可被具体化，在更加高效的外部表中查找对象的一部分或整体（或通过某些其他节省空间的计算来产生对象的一部分或整体）。
