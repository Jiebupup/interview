## 1.SQL 优化

**尽量不要使用 select *，而是 select 具体字段。**

只取需要的字段，节省资源、减少网络开销。

select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。

**如果知道查询结果只有一条或者只要最大/最小一条记录，建议用 limit 1。**

加上 limit 1 后，只要找到了对应的一条记录，就不会继续向下扫描了，效率将会大大提高。

当然，如果是唯一索引的话，是不必要加上 limit 1 了，因为 limit 的存在主要就是为了防止全表扫描，从而提高性能，如果一个语句本身可以预知不用全表扫描，有没有 limit，性能的差别并不大。

**应尽量避免在 where 子句中使用 or 来连接条件。**

使用 or 可能会使索引失效，从而全表扫描。or 有个条件无索引，因此需要全表扫描+索引扫描+合并，MySQL 是有优化器的，处于效率与成本考虑，遇到 or 条件，索引可能失效，看起来也合情合理。

**优化 limit 分页。**

当偏移量 offset 特别大的时候，查询效率就变得低下。因为 MySQL 并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。通过 buffer pool 加载的数据页数量可以看出这一点，并且直接使用 offset 会造成 buffer pool 的污染。                      

可以通过返回上次查询的最大记录（偏移量），或 order by +索引，或者使用子查询。

**优化 like 语句。**

like 很可能让你的索引失效。如 like '%123' 没有走索引，而 like '123%' 走索引。

**使用 where 条件限定要查询的数据，避免返回多余的行。**

**尽量避免在索引列上使用 MySQL 的内置函数，防止索引失效。**

**应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫描。**

**应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。**

**inner join、left join、right join，优先使用 inner join。如果是 left join，左边表结果尽量小，条件尽量放到左边处理。**

**使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。**

**对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。**

**如果插入数据过多，考虑批量插入。或删除**

**使用覆盖索引，能够使得你的 SQL 语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。**

**慎用 distinct 关键字，在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。**

因为数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，过滤的过程会占用系统资源和 cpu 时间。

**删除冗余和重复索引**

重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能的。

**where 子句中考虑使用默认值代替 null。**

并不是说使用了 is null 或者 is not null 就会不走索引了，这个跟 MySQL 版本以及查询成本都有关。

如果 MySQL 优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件 ！=，is null，is not null 经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃的。

如果把 null 值换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。

**不要有超过 5 个以上的表连接。**

连表越多，编译的时间和开销也就越大。

把连接表拆开成较小的几个执行，可读性更高。

如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。

**exist & in 的合理利用**

exist 先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true 或者 false），来决定主查询的数据结果是否得意保留。

所以先 A 表再 B 表 select * from A where exists (select 1 from B where A.deptId = B.deptId);

而 in 先 B 表再 A 表 select * from A where deptId in (select deptId from B);

数据库最费劲的就是跟程序链接释放，先进行的表是链接，因此选择最外层循环小的。MySQL 的优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。

**尽量用 union all 替换 union**

如果使用 union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。

如果已知检索结果没有重复记录，使用 union all 代替 union，这样会提高效率。

**索引不宜太多，一般 5 个以内。**

索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。

insert 或 update 时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。

一个表的索引数最好不要超过 5 个，若太多需要考虑一些索引是否没有存在的必要。

**尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型。相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。**

**索引不适合建在有大量重复数据的字段上**

如性别这类型数据库字段。因为 SQL 优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，MySQL 查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。

**尽量避免向客户端返回过多数据量，设置 limit。**

**当在 SQL 语句中连接多个表时，请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。**

**尽可能使用 varchar/nvarchar 代替 char/nchar。**

因为首先变长字段存储空间小，可以节省存储空间。

其次对于查询来说，在一个相对较小的字段内搜索，效率更高。

**为了提高 group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。**

**如何字段类型是字符串，where 时一定用引号括起来，否则索引失效。不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL 会做隐式的类型转换，把它们转换为浮点数再做比较。**

**使用 explain 分析你 SQL 的计划，尤其是走不走索引这一块。**



## 2.MySQL 大表优化

当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降。

除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署和运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。

而事实上很多时候 MySQL 单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量。

#### 字段

尽量使用 TINYINT、SMALLINT、MEDIUM_INT 作为整数类型而非 INT，如果非负则加上 UNSIGNED。

VARCHAR 的长度只分配真正需要的空间。

使用枚举或整数代替字符串类型。

尽量使用 TIMESTAMP 而非 DATETIME。

单表不要有太多字段，建议在 20 以内。

避免使用 NULL 字段，很难查询优化且占用额外索引空间。

用整型来存 IP。

#### 索引

索引并不是越多越好，要根据查询有针对性的创建，考虑在 WHERE 和 ORDER BY 命令上涉及的列建立索引，可根据 EXPLAIN 来查看是否用了索引还是全表扫描。

应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描。

值分布很稀少的字段不适合建索引，例如性别这种只有两三个值的字段。

字符字段只建前缀索引。

字符字段最好不要做主键。

不用外键，由程序保证约束。

尽量不用 UNIQUE，由程序保证约束。

使用多列索引时注意顺序和查询条件保持一致，同时删除不必要的单列索引。

#### 查询 SQL

可通过开启慢查询日志来找出较慢的 SQL。

不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边。

sql 语句尽可能简单：一条 sql 只能在一个 cpu 运算；大语句拆小语句，减少锁时间；一条大 sql 可以堵死整个库。

不用 SELECT *。

OR 改写成 IN：OR 的效率是 n 级别，IN 的效率是 log(n) 级别，in 的个数建议控制在 200 以内。

不用函数和触发器，在应用程序实现。

避免 %xxx 式查询。

少用 JOIN。

使用同类型进行比较，比如用 '123' 和 '123' 比，123 和 123 比。

尽量避免在 WHERE 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。

对于连续数值，使用 BETWEEN 不用 IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5。

列表数据不要拿全表，要使用 LIMIT 来分页，每页数量也不要太大。

读写分离：一般不要采用双主或多主引入很多复杂性。

#### 缓存

MySQL 内部：系统调优参数。

数据访问层：比如 MyBatis 针对 SQL 语句做缓存，而 Hibernate 可以精确到单个记录，这里缓存的对象主要是持久化对象 Persistence Object。

应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象 Data Transfer Object。

Web 层：针对 web 页面做缓存。

浏览器客户端：用户端的缓存。

服务层：直写式 Write Through，在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如 Spring Cache 的工作方式。这种实现非常简单，同步好，但效率一般。

回写式 Write Back，当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。

表分区

#### 分片原则

能不分就不分，参考单表优化。

分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。

分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性 Hash 分片，这几种分片都有利于扩容。

如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。

尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题。

查询条件尽量优化，尽量避免 Select * 的方式，大量数据结果集下，会消耗大量带宽和 CPU 资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。

通过数据冗余和表分区赖降低跨库 Join 的可能。

总体上来说，分片的选择是取决于最频繁的查询 SQL 的条件，因为不带任何 Where 语句的查询 SQL，会遍历所有的分片，性能相对最差，因此这种 SQL 越多，对系统的影响越大，所以我们要尽量避免这种 SQL 的产生。

把数据迁移到 NoSQL，彻底解决水平扩展问题，例如：

日志类、监控类和统计类数据。

非结构化或弱结构化数据。

对事务要求不强，且无太多关联操作的数据。