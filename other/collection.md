## 1.测试

#### 白盒测试

也称为结构测试，主要用于检测软件编码过程中的错误。

单元测试属于白盒测试。

#### 黑盒测试

也称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试。给输入值，看输出是否为预期值。

#### 单元测试

JUnit 集成了 main 方法。

步骤：初始化数据，执行测试代码，验证测试结果 Assert，清理测试数据。

@Before、@After、@BeforeClass、@AfterClass。

测试驱动的开发 TDD 要求我们先写单元测试，再写实现代码。

需要保证测试方法的独立性，不能有方法间的依赖。  

#### 性能测试

JMeter




## 2.如何设计一个安全的对外接口？

安全措施大体来看主要在两个方面：传输，服务器端如何识别数据不被攻击。

数据加密：数据在传输过程中是很容易被抓包，所以必须对数据加密。
常见的做法对关键字段加密（如用户密码）直接通过 MD5 加密。
现在主流的做法是使用 HTTPS 协议，在 HTTP 和 TCP 之间添加一层加密层 SSL，这一层负责数据的加密和解密。

数据加签：数据加签就是由发送者产生一段无法伪造的一段数字串，来保证数据在传输过程中不被篡改。
HTTPS 加密只在外网，在内网中都需要经过很多服务跳转，这里的加签可以防止内网中数据被篡改。
数据签名使用比较多的是 MD5 算法，将需要提交的数据通过某种方式组合成一个字符串，然后通过 MD5 生成一段加密字符串。

时间戳机制：防止不法者直接拿到抓取的数据包进行恶意请求，超过一定时间范围的请求会被视为非法请求。
解密后的数据，经过签名认证后，我们拿到数据包中的客户端时间戳字段。

appid 机制：并不是谁都可以调用，需要使用接口的用户需要在后台开通 appid，提供给用户相关的密钥。在调用的接口中需要提供 appid+密钥，服务器端会进行相关的验证。
唯一，但根据实际情况看是否需要全局唯一，snowflake 生成全局唯一 id。要趋势递增，在保存数据库的时候，使用索引性能更好。尽量不要连续的，容易发现规律。

限流机制：防止出现频繁调用接口的情况，需要给相关 appid 限流处理，常用的限流算法有令牌桶和漏桶算法。
黑名单机制：将该 appid 列入黑名单，所有请求直接返回错误码。给用户设定状态，或者在配置中心保存黑名单列表。
数据合法性校验：常规性校验，包括签名校验，必填校验，长度校验，类型校验，格式校验等。业务校检。



## 3.秒杀场景设计

秒杀瞬时访问量会翻数十倍，甚至数百倍。
保证秒杀系统的高性能和稳定性，同时还要保证日常业务不受影响。
要达到强一致性。

#### 动静分离

**分离出动态数据**

用户和时间信息通过动态请求进行异步获取。分为：

ESI 方案：Web 代理服务器上请求动态数据，并将动态数据插入到静态页面中，用户看到页面时已经是一个完整的页面。这种方式对服务端性能要求高，但用户体验较好。

CSI 方案：Web 代理服务器上只返回静态页面，前端单独发起一个异步 JS 请求动态数据。这种方式对服务端性能友好，但用户体验稍差。

**缓存静态数据**

直接缓存整个 HTTP 连接。

浏览器当然是第一选择，但用户的浏览器是不可控的，主要体现在如果用户不主动刷新，系统很难主动地把消息推送给用户（静态数据可能会变），如此可能会导致用户端在很长一段时间内看到的信息都是错误的。对于秒杀系统，保证缓存可以在秒级时间内失效是不可或缺的。

服务端主要进行动态逻辑计算及加载，本身并不擅长处理大量连接，每个连接消耗内存较多，同时 Servlet 容器解析 HTTP 较慢，容易侵占逻辑计算资源。另外，静态数据下沉至此也会拉长请求路径。

因此通常将静态数据缓存在 CDN。

**CDN**
秒杀是运营提前安排的活动，要秒杀哪些商品、商品价格等信息在秒杀活动开始前已经确定下来，所以我们可以把秒杀商品详情页做成静态页面，把商品详情、商品价格等参数、评论评价等信息全部放在这个静态页面里，然后把这个静态页面上传到 CDN 上预热。动静分离。

用 CDN 扛流量，这样大量的商品详情页的访问请求就不用访问自己的网站。这样既可以提高访问速度，也没有给网站增加压力，同时也减少了网站带宽压力。

CDN 更擅长处理大并发的静态文件请求，既可以做到主动失效，又离用户尽可能近，同时规避 Java 语言层面的弱点。

选择 CDN 作为二级缓存比较合适，因为二级缓存数量偏少，容量也更大，访问量相对集中，这样就可以较好解决 CDN 的失效问题以及命中率问题。

#### 流量削峰	

**答题**

能达到防止作弊和延缓请求的作用。

**排队**

排队本质是在业务层将一步操作转变成两步操作，从而起到缓冲的作用。

消息队列、线程池加锁、本地内存蓄洪、本地文件序列化写再顺序读。

排队弊端：请求积压和用户体验差。

**过滤**

过滤的核心目的是通过减少无效请求的数据 IO 保障有效请求的 IO 性能。

读限流：对读请求做限流保护，将超出系统承载能力的请求过滤掉。
读缓存：对读请求做数据缓存，将重复的请求过滤掉。
写限流：对写请求做限流保护，将超出系统承载能力的请求过滤掉。
写校验：对写请求做一致性校验，只保留最终的有效数据。

**业务**

将一部分流量分散到其他系统。

#### **请求拦截**

尽量将请求拦截在上游：对于秒杀系统来说，系统的瓶颈一般在数据库层，资源是有限的，所以为了更好的保护底层有限的数据库资源，尽量将请求拦截在上游。

**前端页面**

相关按钮点击后置灰，防止重复提交，通过 JS 控制在一定时间内只能提交一次请求。

**网关层**

Zuul 和 Nginx，为了避免前端恶意请求，比如一些攻击脚本，在网关层要对下单等接口按 userID 限流，几秒钟只能访问一次（接口防刷）。考虑到秒杀场景参与人多，秒杀成功的人极少，我们可以把绝大部分抢购下单请求在网关层直接拒掉，按秒杀失败处理。这样就极大减少了后端服务的压力。    

分段放行，除了限制了机器人和自动脚本，把请求分散在各个时间段，还进一步缓解了后端服务的压力。分段放行总时间不能太长，不然用户就会明显感知到下单早的人没秒杀成功，下单晚的人反而秒杀成功了，用户体验会变差。

秒杀过程网关压力会比较大，网关可以做成集群，多节点分摊访问压力。

网关层除了对 userID 做限流外，还要做整体限流。在实际访问量超过预估访问量时，整体限流可以起到保护作用，避免系统被压垮。

同时，防止重复下单，按 userID 限流已经起到了防止重复下单的作用。假如限制同一个用户 10 分钟能下一次单，一般情况下 10 分钟内，商品早已经被抢光了，用户也就没有再次下单的机会了。

Nginx 负载均衡

#### 数据库

**分层校验（读）**

分层校验的核心思想是：不同层次尽可能过滤掉无效请求，只在漏斗 最末端进行有效处理，从而缩短系统瓶颈的影响路径。

即在读链路时，只进行不影响性能的检查操作，如用户是否具有秒杀资格等，而不做一致性校验等容易引发瓶颈的检查操作。直到写链路时，才对库存做一致性检查，在数据层保证最终准确性。

因此，在分层校验设定下，系统可以采用分布式缓存甚至 LocalCache 来抵抗高并发读。即允许读场景下一定的脏数据，这样只会导致少量原本无库存的下单请求被误认为是有库存的，等到真正写数据时再保证最终一致性，由此做到高可用和一致性之间的平衡。

**解决 DB 并发锁问题（写）**

应用层排队：通过缓存加入集群分布式锁，从而控制集群对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用过多的数据库连接。

数据层排队：应用层排队是有损性能的，数据层排队是最为理想的。排队和锁竞争是有区别的，如果熟悉 MySQL 的话，就会知道 InnoDB 内部的死锁检测，以及 MySQL Server 和 InnoDB 的切换都是比较消耗性能的。



充分利用缓存：缓存不但极大的提高了数据的访问效率，更重要的是承载了底层数据库的访问压力，所以对于读多写少的业务场景充分利用好缓存。

DB 层优化：读写分离，分表分库，数据库集群。

数据库的压力：扣减库存，创建订单。

库存可以放到 Reids 缓存中，来提高扣减库存吞吐能力。对于热点商品的库存可以利用 Redis 分片存储。

创建订单可以走异步消息队列。后端服务接到下单请求，直接放进消息队列，监听服务取出消息后，先将订单信息写入 Redis，每隔 100ms 或者积攒 100 条订单，批量写入数据库一次。前端页面下单后定时向后端拉取订单信息，获取到订单信息后跳转到支付页面。用这种批量异步写入数据库的方式大幅减少了数据库写入频次，从而明显降低了订单数据库写入压力。

#### 消息队列

MQ 削峰。可控的速度来访问底层 DB。秒杀成功的订单通知信息异步处理。

缓存放读多写少的数据，分为多份放入不同 key 的缓存中，这样将数据分散操作可以达到更高的读写性能。

#### 热点

**热点操作**

限制用户的不良热点操作。

**热点数据**

提前预测静态热点数据。

热点数据的动态发现能力：

- 异步采集交易链路各个环节的热点 Key 信息，如 Nginx 采集访问 URL 或 Agent 采集热点日志（一些中间件本身已具备热点发现能力），提前识别潜在的热点数据。
- 聚合分析热点数据，达到一定规则的热点数据，通过订阅分发推送到链路系统，各系统根据自身需求决定如何处理热点数据，或限流或缓存，从而实现热点保护

热点数据采集最好采用异步方式，一方面不会影响业务的核心交易链路，一方面可以保证采集方式的通用性。

热点发现最好做到秒级实时。

#### 隔离

**业务隔离**

从业务上把秒杀和日常售卖区分开来，把秒杀做为营销活动，要参与秒杀的商品需要提前报名参加活动。对已知热点做缓存预热。

**系统隔离**

秒杀相关服务和日常服务要分组部署，不能因为秒杀出问题影响日常售卖业务。可以申请单独的秒杀域名，从网络入口层就开始分流。网关也单独部署，秒杀走自己单独的网关，从而避免日常网关受到影响。秒杀可以复用订单，库存，支付等日常服务，只是需要一些小的改造（比如下单流程走消息队列，批量写入订单库，以及在 Redis 中扣减库存）。

**数据隔离**

为了避免秒杀活动影响到日常售卖业务，Redis 缓存需要单独部署，甚至数据库也需要单独部署。数据隔离后，秒杀剩余的库存会在秒杀活动结束后，归还到日常库存继续做为普通商品售卖。秒杀订单和日常订单不在相同的数据库，对于订单查询，在创建秒杀订单后发消息到消息队列，日常订单服务采取拉的方式消费消息，这时日常订单服务是主动方，可以采用线程池的方式，根据机器的性能来增加或缩小线程池的大小，控制拉取消息的速度，来控制订单数据库的写入压力。



当然，实现隔离还有很多种办法。比如，可以按照用户来区分，为不同的用户分配不同的 Cookie，入口层路由到不同的服务接口中；再比如，域名保持一致，但后端调用不同的服务接口；又或者在数据层给数据打标进行区分等等，这些措施的目的都是把已经识别的热点请求和普通请求区分开来。

#### 网络

秒杀前要和网络运营商、CDN 服务商提前申请带宽。

#### 代码优化

减少序列化、减少数据的编码转换、裁剪日志异常堆栈、去组件框架。

#### 其他细节

**如何避免超卖（一致性问题）？**

**下单减库存**

秒杀的商品售卖价格非常低，基本都是抢到即赚到，成功下单后却不付款的情况非常少，所以我们采用下单减库存的方案，下单时扣减库存，然后再进行支付。

假如真有个别订单不付款怎么办？没关系，秒杀好活动最主要的目的是吸引流量，个别订单不支付对秒杀活动本身影响不大。况且，没支付剩下的库存还可以作为普通商品继续售卖。不过要注意对机器人和自动脚本的防御（恶意下单）。

**付款减库存**

导致很多买家下单成功后却付不了款，购物体验自然是比较差的。

**预扣库存**

业界最为常见的是预扣库存，实际就是下单减库存和付款减库存两种方式的结合，将两次操作进行了前后关联，下单时预扣库存，付款时释放库存。下单后一般都有个有效付款时间，超过该时间订单自动释放。

首先结合安全和反作弊措施来制止恶意下单。

然后是一致性问题的解决方案：

一是在通过事务来判断，即保证减后库存不能为负，否则就回滚。

二是直接设置数据库字段类型为无符号整数，这样一旦库存为负就会在执行 SQL 时报错。

三是使用 CASE WHEN 判断语句。

四如果在 Redis 中扣减库存，可以利用 decr 命令扣减库存，decr 是原子操作，在分布式环境下也不会有并发问题，decr 扣减库存后，判断返回值，如果返回值小于 0，扣减库存失败，秒杀也就失败了；如果在数据库中扣减库存可以在 where 后面加上库存大于 0 的条件，来避免库存被减成负值。这样就可以避免超卖情况发生了。



可以结合风控系统，在网关层把羊毛党等有问题的用户请求直接拒掉。

可以在网关层上面再加一层防火墙或者高防服务，来防御 DDos 等分布式网络攻击。



## 4.单点登录 SSO

用户登陆多个子系统的其中一个，就有权访问与其相关的其他系统。

单系统登录：Session 保存用户信息
用户登录时，验证用户的账户和密码。
生成一个 token 保存在数据库中，将 token 写到 Cookie 中。
将用户数据保存在 Session 中。
请求时都会带上 Cookie，检查有没有登录，如果已经登录则放行。

多系统：Session 不共享
SSO 系统生成一个 token，并将用户信息存到 Redis 中，并设置过期时间。
其他系统请求 SSO 系统进行登录，得到 SSO 返回的 token，写到 Cookie 中。
每次请求时，Cookie 都会带上，拦截器得到 token，判断是否已经登录。

变化：将登陆功能抽取为一个系统 SSO，其他系统请求 SSO 进行登录本来将用户信息存到 Session，现在将用户信息存到 Redis。

Cookie 不能跨域的解决方案：
服务端将 Cookie 写到客户端后，客户端对 Cookie 进行解析，将 token 解析出来，此后请求都把这个 token 带上就行了。
多个域名共享 Cookie，在写到客户端的时候设置 Cookie 的 domain。
将 token 保存在 SessionStroage 中（不依赖 Cookie 就没有跨域的问题了）。

CAS（Central Authentication Service）：SSO 认证中心类似一个中转站。

多点登录和消息漫游
多点登录是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点。
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

消息漫游是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端。
每个端本地存储 last_msg_id，在登录时可以到云端同步历史消息。
云端存储所有消息成本较高，一般会对历史消息时间 (或者条数) 进行限制。



## 5.Arthas

Arthas 是 Alibaba 开源的 Java 诊断工具，可以帮助你解决：
这个类从哪个 JAR 包加载的？为什么会报各种类相关的 Exception？
我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？
遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？
线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！
是否有一个全局视角来查看系统的运行状况？
有什么办法可以监控到 JVM 的实时运行状态？
怎么快速定位应用的热点，生成火焰图？

trace：动态计算方法调用路径和时间。
trace 方法内部调用路径，并输出方法路径上的每个节点上耗时。
trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。

stack：反向查找调用路径。
watch：动态监测方法调用数据。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。



## 6.认证 Authentication 和授权 Authorization

认证：你是谁。验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，认证被称为身份/用户验证。
授权：你有权限干什么。发生在认证之后，主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。
这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。

Cookie & Session
Token，JWT
OAuth：授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。
SSO
Spring Security 
