#### PriorityQueue

PriorityQueue< Integer> pq=new PriorityQueue<>();  // 默认最小堆

多了 peek()

堆排序的复杂度 CNlogN，堆排序会有很多无用的比较，C 会比较大。

堆排序无法利用局部性原理缓存，大量的元素比较。

#### ArrayList

clear() 清空

stream().mapToInt(Integer::intValue).toArray() 转化为 int[]

toArray() 转化为数组

#### TreeSet

floor(val) 返回小于 val 的值

ceiling() 大于

#### Deque

addLast/removeLast

#### String

concat() 拼接

substring(begin,end) 子串（左闭右开）

compareTo() 比较

indexOf() 索引（首次出现）

split() 分割（regex 注意 . 和 \\.）

trim() 删除头尾空白符

replace() 字符替换

#### Arrays

sort() 排序（默认升序）

binarySearch() 二分查找

equals() 相等

fill() 填充

asList() 转成列表

copyOf() 复制数组

#### Collections

clear() 清空

contains() 包含

toArray() 转换为数组

reverse() 反转

addAll() 添加

shuffle() 随机排序

sort() 排序

swap() 交换

rotate() 旋转

binarySearch() 二分查找

max() 最大

fill() 填充

frequency() 统计次数

indexOfSubList() 子集合出现的位置

replaceAll() 用新元素代替旧元素                 

#### 注意

sequence 不需要连续。

**整数溢出**

Integer.MAX_VALUE=2^31-1=2147483647。

Integer.MAX_VALUE+1=-2^31 =-2147483648=Integer.MIN_VALUE。

**随机数**

Random r=new Random();

int num=r.nextInt(10);  //左闭右开

**求中点**

mid = (start + end) / 2 溢出，start + (end - start) / 2 和  mid = (start + end) >>> 1 不会溢出，后者因为 >>> 右移最高位补 0，>> 有符号右移就不行。javac 会将 /2 优化成 >>1。



## 排序算法

| 算法             | 稳定性 | 时间复杂度                   | 空间复杂度 | 备注                     |
| ---------------- | ------ | ---------------------------- | ---------- | ------------------------ |
| 选择排序         | ×      | N2                           | 1          |                          |
| 冒泡排序         | √      | N2                           | 1          |                          |
| 插入排序         | √      | N ~ N2                       | 1          | 时间复杂度和初始顺序有关 |
| 希尔排序         | ×      | N 的若干倍乘于递增序列的长度 | 1          | 改进版插入排序           |
| 快速排序         | ×      | NlogN                        | logN       |                          |
| 三向切分快速排序 | ×      | N ~ NlogN                    | logN       | 适用于有大量重复主键     |
| 归并排序         | √      | NlogN                        | N          |                          |
| 堆排序           | ×      | NlogN                        | 1          | 无法利用局部性原理       |

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。

快排稳定版：创建一个数组存储要交换的数据，记录位置信息。

使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。



## 正则表达式

正则表达式用于文本内容的查找和替换。

正则表达式一般是区分大小写的，但也有些实现不区分。

#### **匹配单个字符**

**.** 可以用来匹配任何的单个字符。

在绝大多数实现里面，不能匹配换行符。

如果需要匹配 . 字符，那么要用 \ 进行转义，即在 . 前面加上 \ 。

#### **重复匹配**

**+** 匹配 1 个或者多个字符。

***** 匹配 0 个或者多个字符。

**?** 匹配 0 个或者 1 个字符。

{n} 匹配 n 个字符

{m,n} 匹配 m~n 个字符

{m,} 至少匹配 m 个字符

#### **匹配一组字符**

**[ ]** 定义一个字符集合。

0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。

**-** 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符。

**^** 在 [ ] 中是取非操作。

**例子**

匹配以 abc 为开头，并且最后一个字母不为数字的字符串：

正则表达式：abc**[^0-9]**

匹配结果：abcd，abc1，abc2

#### 使用元字符

**空白字符**

\b：删除一个字符

\f：换页符

\n：换行符

\r：回车符

\t：制表符

\v：垂直制表符



\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。

\r\n\r\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行。

**数字元字符**

\d：数字字符，等价于 [0-9]

\D：非数字字符，等价于 **[^0-9]**

**字母数字元字符**

\w：大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]

\W：对 \w 取非

**空白字符元字符**

\s：任何一个空白字符，等价于 [\f\n\r\t\v]

\S：对 \s 取非

**进制元字符**

\x：十六进制字符

\0：八进制字符

#### 位置匹配

**单词边界**

\b 匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置。\b 只匹配位置，不匹配字符。

\B 匹配一个不是单词边界的位置。

**字符串边界**

^ 匹配整个字符串的开头，$ 匹配结尾。

分行匹配模式 multiline 下，换行被当做字符串的边界。

**例子**

匹配代码中以 // 开始的注释行。

正则表达式：^\s*\/\/.*$

匹配结果：

1. public void fun() {
2.    **// 注释 1**
3.    int a = 1;
4.    int b = 2;
5.    **// 注释 2**
6.    int c = a + b;
7. }

#### 子表达式

使用 ( ) 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。

子表达式可以嵌套，但是嵌套层次过深会变得很难理解。

**例子**

匹配 IP 地址，IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：

- 一位数字
- 不以 0 开头的两位数字
- 1 开头的三位数
- 2 开头，第 2 位是 0-4 的三位数
- 25 开头，第 3 位是 0-5 的三位数

正则表达式：((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))

匹配结果：

1. 192.168.0.1
2. 00.00.00.00
3. 555.555.555.555

#### **回溯引用**

回溯引用使用 \n 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致。

#### 前后查找

前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。

向前查找使用 ?= 定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。

向后匹配用 ?<= 定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。

**例子**

查找出邮件地址 @ 字符前面的部分。

正则表达式：\w+(?=@)

匹配结果：abc@qq.com

#### 替换

需要用到两个正则表达式。

**例子**

修改电话号码格式：313-555-1234

查找正则表达式：(\d{3})(-)(\d{3})(-)(\d{4})

替换成 (313) 555-1234，正则表达式：

```
($1) $3-$5
```

**大小写转换**

\l：把下个字符转换为小写

\u：把下个字符转换为大写

\L：把\L 和\E 之间的字符全部转换为小写

\U：把\U 和\E 之间的字符全部转换为大写

\E：结束\L 或者\U

**例子**

把文本的第二个和第三个字符转换为大写：abcd

查找正则表达式：(\w)(\w{2})(\w)

替换成 aBCd，正则表达式：

```
$1\U$2\E$3
```

#### 嵌入条件

?(n) 条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。

?(?=-) 条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。