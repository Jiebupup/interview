1.测试
白盒测试：也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。
黑盒测试：也称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。

黑盒测试方法：等价类划、边界值分析、因果图、错误推测。
白盒测试方法：程序结构分析、逻辑覆盖测试、基本路径测试。

测试驱动的开发 TDD 要求我们先写单元测试，再写实现代码。
单元测试属于白盒测试。
JUnit：集成了 main 方法。

性能测试 JMeter   

2.秒杀场景设计
秒杀瞬时访问量会翻数十倍，甚至数百倍。
保证秒杀系统的高性能和稳定性，同时还要保证日常业务不受影响。
要达到强一致性。

下单减库存：
秒杀的商品售卖价格非常低，基本都是抢到即赚到，成功下单后却不付款的情况非常少，所以我们采用下单减库存的方案，下单时扣减库存，然后再进行支付。
假如真有个别订单不付款怎么办？没关系，秒杀好活动最主要的目的是吸引流量，个别订单不支付对秒杀活动本身影响不大。况且，没支付剩下的库存还可以作为普通商品继续售卖。不过要注意对机器人和自动脚本的防御。

CDN：
秒杀开始前几分钟，大量用户开始进入秒杀商品详情页面，很多人开始频繁刷新秒杀商品详情页，这时秒杀商品详情页访问量会猛增。
如果请求全部打到后端服务，那后端服务的压力会非常大，因为后端服务要处理业务逻辑，而且还要访问数据库，吞吐量比较低。
秒杀是运营提前安排的活动，要秒杀哪些商品、商品价格等信息在秒杀活动开始前已经确定下来，所以我们可以把秒杀商品详情页做成静态页面，把商品详情、商品价格等参数、评论评价等信息全部放在这个静态页面里，然后把这个静态页面上传到 CDN 上预热。动静分离。
用 CDN 扛流量，这样大量的商品详情页的访问请求就不用访问自己的网站。这样既可以提高访问速度，也没有给网站增加压力，同时也减少了网站带宽压力。

请求拦截
前端页面：相关按钮点击后置灰，防止重复提交，通过 JS 控制在一定时间内只能提交一次请求。

网关层：
Zuul 和 Nginx，为了避免前端恶意请求，比如一些攻击脚本，在网关层要对下单等接口按 userID 限流，几秒钟只能访问一次（接口防刷）。考虑到秒杀场景参与人多，秒杀成功的人极少，我们可以把绝大部分抢购下单请求在网关层直接拒掉，按秒杀失败处理。这样就极大减少了后端服务的压力。         
分段放行，除了限制了机器人和自动脚本，把请求分散在各个时间段，还进一步缓解了后端服务的压力。分段放行总时间不能太长，不然用户就会明显感知到下单早的人没秒杀成功，下单晚的人反而秒杀成功了，用户体验会变差。
秒杀过程网关压力会比较大，网关可以做成集群，多节点分摊访问压力。
网关层除了对 userID 做限流外，还要做整体限流。在实际访问量超过预估访问量时，整体限流可以起到保护作用，避免系统被压垮。
同时，防止重复下单，按 userID 限流已经起到了防止重复下单的作用。假如限制同一个用户 10 分钟能下一次单，一般情况下 10 分钟内，商品早已经被抢光了，用户也就没有再次下单的机会了。
Nginx 负载均衡

数据库的压力：扣减库存，创建订单。
库存可以放到 Reids 缓存中，来提高扣减库存吞吐能力。对于热点商品的库存可以利用 Redis 分片存储。
创建订单可以走异步消息队列。后端服务接到下单请求，直接放进消息队列，监听服务取出消息后，先将订单信息写入 Redis，每隔 100ms 或者积攒 100 条订单，批量写入数据库一次。前端页面下单后定时向后端拉取订单信息，获取到订单信息后跳转到支付页面。用这种批量异步写入数据库的方式大幅减少了数据库写入频次，从而明显降低了订单数据库写入压力。

MQ 削峰。可控的速度来访问底层 DB。秒杀成功的订单通知信息异步处理。
缓存放读多写少的数据，分为多份放入不同 key 的缓存中，这样将数据分散操作可以达到更高的读写性能。

隔离
业务隔离：从业务上把秒杀和日常的售卖区分开来，把秒杀做为营销活动，要参与秒杀的商品需要提前报名参加活动，这样我们就能提前知道哪些商家哪些商品要参与秒杀，可以根据提报的商品提前生成静态页面并上传到 CDN 预热，提报的商品库存也需要提前预热，可以将商品库存在活动开始前预热到 Redis，避免秒杀开始后大量的缓存穿透。
部署隔离：秒杀相关服务和日常服务要分组部署，不能因为秒杀出问题影响日常售卖业务。可以申请单独的秒杀域名，从网络入口层就开始分流。网关也单独部署，秒杀走自己单独的网关，从而避免日常网关受到影响。秒杀可以复用订单，库存，支付等日常服务，只是需要一些小的改造（比如下单流程走消息队列，批量写入订单库，以及在 Redis 中扣减库存）。
数据隔离：为了避免秒杀活动影响到日常售卖业务，Redis 缓存需要单独部署，甚至数据库也需要单独部署。数据隔离后，秒杀剩余的库存会在秒杀活动结束后，归还到日常库存继续做为普通商品售卖。秒杀订单和日常订单不在相同的数据库，对于订单查询，在创建秒杀订单后发消息到消息队列，日常订单服务采取拉的方式消费消息，这时日常订单服务是主动方，可以采用线程池的方式，根据机器的性能来增加或缩小线程池的大小，控制拉取消息的速度，来控制订单数据库的写入压力。

网络：秒杀前要和网络运营商、CDN 服务商提前申请带宽。

其他细节：
如何避免超卖？如果在 Redis 中扣减库存，可以利用 decr 命令扣减库存，decr 是原子操作，在分布式环境下也不会有并发问题，decr 扣减库存后，判断返回值，如果返回值小于 0，扣减库存失败，秒杀也就失败了；如果在数据库中扣减库存可以在 where 后面加上库存大于 0 的条件，来避免库存被减成负值。这样就可以避免超卖情况发生了。
可以结合风控系统，在网关层把羊毛党等有问题的用户请求直接拒掉。
可以在网关层上面再加一层防火墙或者高防服务，来防御 DDos 等分布式网络攻击。

架构原则
尽量将请求拦截在上游：对于秒杀系统来说，系统的瓶颈一般在数据库层，资源是有限的，所以为了更好的保护底层有限的数据库资源，尽量将请求拦截在上游。
充分利用缓存：缓存不但极大的提高了数据的访问效率，更重要的是承载了底层数据库的访问压力，所以对于读多写少的业务场景充分利用好缓存。

热点隔离
业务隔离：将热点数据分散处理，来降低系统负载压力。
系统隔离：实现系统的软硬隔离，不光是实现软件的隔离，还可以实现硬件的隔离，尽最大限度的减少秒杀带来的高并发安全性问题。
数据隔离：启用单独的 cache 集群或数据库来存放热点数据。

web server 层还可以对页面缓存化。

DB 层优化：读写分离，分表分库，数据库集群。

3.单点登录 SSO
用户登陆多个子系统的其中一个，就有权访问与其相关的其他系统。

单系统登录：Session 保存用户信息
用户登录时，验证用户的账户和密码。
生成一个 token 保存在数据库中，将 token 写到 Cookie 中。
将用户数据保存在 Session 中。
请求时都会带上 Cookie，检查有没有登录，如果已经登录则放行。

多系统：Session 不共享
SSO 系统生成一个 token，并将用户信息存到 Redis 中，并设置过期时间。
其他系统请求 SSO 系统进行登录，得到 SSO 返回的 token，写到 Cookie 中。
每次请求时，Cookie 都会带上，拦截器得到 token，判断是否已经登录。

变化：将登陆功能抽取为一个系统 SSO，其他系统请求 SSO 进行登录本来将用户信息存到 Session，现在将用户信息存到 Redis。

Cookie 不能跨域的解决方案：
服务端将 Cookie 写到客户端后，客户端对 Cookie 进行解析，将 token 解析出来，此后请求都把这个 token 带上就行了。
多个域名共享 Cookie，在写到客户端的时候设置 Cookie 的 domain。
将 token 保存在 SessionStroage 中（不依赖 Cookie 就没有跨域的问题了）。

CAS（Central Authentication Service）：SSO 认证中心类似一个中转站。

多点登录和消息漫游
多点登录是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点。
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

消息漫游是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端。
每个端本地存储 last_msg_id，在登录时可以到云端同步历史消息。
云端存储所有消息成本较高，一般会对历史消息时间 (或者条数) 进行限制。

4.大型网站系统架构
哪些方法提升网站性能，可用性以及并发量：
提高硬件能力、增加系统服务器。
使用缓存：本地缓存 JDK 自带的 Map、Guava Cache，分布式缓存 Redis、Memcache。
消息队列：解耦 + 削峰 + 异步。
采用分布式开发：不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署的缺点，大大提高的系统并发量。
数据库分库分表：读写分离、水平分表、垂直分表。
采用集群：多台机器提供相同的服务。
CDN 加速：将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点。
浏览器缓存。
使用合适的连接池：数据库连接池、线程池等等。
适当使用多线程进行开发。

设计高可用系统
高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。
一般情况下，我们使用多少个 9 来评判一个系统的可用性。除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量。

导致系统不可用的情况：
黑客攻击
硬件故障，如服务器宕机。
并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。
代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。
网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。
自然灾害或者人为破坏。

做法
降级：服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。
总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。 

代码质量：常见问题有内存泄漏和循环依赖。使用 code review 工具如 sonarqube 和 Arthas。
集群：避免单点故障。
限流：达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮。
超时和重试机制：一旦用户请求超过某个时间的得不到响应，就抛出异常。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求（雪崩）。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力。                          
熔断：当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。Netflix 的 Hystrix 和 alibaba 的 Sentinel。
异步调用：不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做。使用异步之后我们可能需要适当修改业务流程进行配合。秒杀场景用得比较多。
缓存：避免大量请求直接落到数据库，将数据库击垮。并且储存在内存中，速度相当地快。
回滚机制：快速修复错误版本。

其他：更好的硬件，监控系统资源使用情况增加报警设置，备份并在必要时回滚，灰度发布，定期检查和更换硬件，性能测试。

现代互联网应用系统通常具有的特点
高并发，大流量。
高可用：系统 7×24 小时不间断服务。
海量数据：需要存储、管理海量数据，需要使用大量服务器。
用户分布广泛，网络情况复杂：许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。
安全环境恶劣：由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会被黑客攻击。
需求快速变更，发布频繁：和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率是极高的；
渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来。

单台服务器无法处理越来越多的流量
简单的扩容，增加系统的服务器，提高硬件能力。
水平拆分和垂直拆分数据/应用，来提升系统的伸缩性，进一步扩容提升系统负载能力。
根据现有系统特性，架构层面进行重构甚至是重新设计。
对于系统设计，理想的情况下应支持线性扩容和弹性扩容，即在系统瓶颈时，只需要增加机器就可以解决系统瓶颈，如降低延迟提升吞吐量，从而实现扩容需求。
拆分需要适应自己的业务。

5.Arthas
Arthas 是 Alibaba 开源的 Java 诊断工具，可以帮助你解决：
这个类从哪个 JAR 包加载的？为什么会报各种类相关的 Exception？
我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？
遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？
线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！
是否有一个全局视角来查看系统的运行状况？
有什么办法可以监控到 JVM 的实时运行状态？
怎么快速定位应用的热点，生成火焰图？

trace：动态计算方法调用路径和时间。
trace 方法内部调用路径，并输出方法路径上的每个节点上耗时。
trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。

stack：反向查找调用路径。
watch：动态监测方法调用数据。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。

6.认证 Authentication 和授权 Authorization
认证：你是谁。验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，认证被称为身份/用户验证。
授权：你有权限干什么。发生在认证之后，主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。
这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。

Cookie & Session
Token，JWT
OAuth：授权机制，它的最终目的是为第三方应用颁发一个有时效性的令牌 Token，使得第三方应用能够通过该令牌获取相关的资源。
SSO
Spring Security 

7.幂等性
幂等性就是一个接口，多次发起同一个请求，必须保证操作只能执行一次。

常见解决方案：
唯一索引：防止新增脏数据。
Token 机制：防止页面重复提交。
悲观锁：获取数据的时候加锁，锁表或锁行。
乐观锁：基于版本号 version 实现，在更新数据那一刻校验数据。
分布式锁：Redis 或 ZooKeeper 实现。
状态机：状态变更，更新数据时判断状态。

Sprinig Boot + Redis 实现思路：
为需要保证幂等性的每一次请求创建一个唯一标识 Token，先获取 Token，并将此 Token 存入 Redis，请求接口时，将此 Token 放到 header 或者作为请求参数请求接口，后端接口判断 Redis 中是否存在此 Token。
如果存在，正常处理业务逻辑，并从 Redis 中删除此 Token。如果是重复请求，由于 Token 已被删除，则不能通过校验，返回请勿重复操作提示。
每次请求保证唯一性，通过拦截器 + 注解，也可以利用 Spring AOP 实现。
