1.测试
白盒测试：也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。
黑盒测试：也称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。

黑盒测试方法：等价类划、边界值分析、因果图、错误推测。
白盒测试方法：程序结构分析、逻辑覆盖测试、基本路径测试。

测试驱动的开发 TDD 要求我们先写单元测试，再写实现代码。
单元测试属于白盒测试。
JUnit：集成了 main 方法。

性能测试 JMeter   

2.秒杀场景设计
要达到强一致性

架构原则
尽量将请求拦截在上游：对于秒杀系统来说，系统的瓶颈一般在数据库层，资源是有限的，所以为了更好的保护底层有限的数据库资源，尽量将请求拦截在上游。
充分利用缓存：缓存不但极大的提高了数据的访问效率，更重要的是承载了底层数据库的访问压力，所以对于读多写少的业务场景充分利用好缓存。

热点隔离
业务隔离：将热点数据分散处理，来降低系统负载压力。
系统隔离：实现系统的软硬隔离，不光是实现软件的隔离，还可以实现硬件的隔离，尽最大限度的减少秒杀带来的高并发安全性问题。
数据隔离：启用单独的 cache 集群或数据库来存放热点数据。

优化方案
页面端优化：按钮置灰来禁止用户重复提交请求，通过 JS 控制在一定时间内只能提交一次请求。

web server 层优化
动静分离：如将几乎不变的静态页面直接通过 NG 或 CDN 来路由访问，只有动态变换的页面可以请求到服务端。
页面缓存化
Nginx 反向代理实现 web server 端的水平扩展。

后端 service 服务层优化
使用缓存（Redis、Memchched）：将读多写少的业务数据放入缓存，如秒杀业务中可以将更新频繁的商品库存信息放入 Redis 缓存处理，最好分为多份放入不同 key 的缓存中，这样将数据分散操作可以达到更高的读写性能。
使用队列处理：将请求放入队列排队处理，以可控的速度来访问底层 DB。
异步处理：如将秒杀成功的订单通知信息通过消息队列（RabbitMQ、Kafka）来异步处理。

DB 层优化
读写分离
分表分库
数据库集群

秒杀场景应付突然的爆发流量：消息队列削峰，分层过滤（CDN 静动态资源划分和缓存）。

3.单点登录 SSO
在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。

单系统登录：Session 保存用户信息
用户登录时，验证用户的账户和密码。
生成一个 token 保存在数据库中，将 token 写到 Cookie 中。
将用户数据保存在 Session 中。
请求时都会带上 Cookie，检查有没有登录，如果已经登录则放行。

多系统：Session 不共享
SSO 系统生成一个 token，并将用户信息存到 Redis 中，并设置过期时间。
其他系统请求 SSO 系统进行登录，得到 SSO 返回的 token，写到 Cookie 中。
每次请求时，Cookie 都会带上，拦截器得到 token，判断是否已经登录。

变化：将登陆功能抽取为一个系统 SSO，其他系统请求 SSO 进行登录本来将用户信息存到 Session，现在将用户信息存到 Redis。

Cookie 不能跨域的解决方案：
服务端将 Cookie 写到客户端后，客户端对 Cookie 进行解析，将 token 解析出来，此后请求都把这个 token 带上就行了。
多个域名共享 Cookie，在写到客户端的时候设置 Cookie 的 domain。
将 token 保存在 SessionStroage 中（不依赖 Cookie 就没有跨域的问题了）。

CAS（Central Authentication Service）：SSO 认证中心类似一个中转站。

多点登录和消息漫游
多点登录是指多个端同时登录一个帐号，同时收发消息，关键点是：
需要在服务端存储同一个用户多个端的状态与登陆点。
发出消息时，要对发送方的多端与接收端的多端，都进行消息投递。

消息漫游是指一个用户在任何端，都可以拉取到历史消息，关键点是：
所有消息存储在云端。
每个端本地存储 last_msg_id，在登录时可以到云端同步历史消息。
云端存储所有消息成本较高，一般会对历史消息时间 (或者条数) 进行限制。

4.大型网站系统架构
哪些方法提升网站性能，可用性以及并发量：
提高硬件能力、增加系统服务器。
使用缓存：本地缓存 JDK 自带的 Map、Guava Cache，分布式缓存 Redis、Memcache。
消息队列：解耦 + 削峰 + 异步。
采用分布式开发：不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署的缺点，大大提高的系统并发量。
数据库分库分表：读写分离、水平分表、垂直分表。
采用集群：多台机器提供相同的服务。
CDN 加速：将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点。
浏览器缓存。
使用合适的连接池：数据库连接池、线程池等等。
适当使用多线程进行开发。

设计高可用系统
高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。
一般情况下，我们使用多少个 9 来评判一个系统的可用性。除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量。

导致系统不可用的情况：
黑客攻击
硬件故障，如服务器宕机。
并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。
代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。
网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。
自然灾害或者人为破坏。

做法
降级：服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。
总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。 

代码质量：常见问题有内存泄漏和循环依赖。使用 code review 工具如 sonarqube 和 Arthas。
集群：避免单点故障。
限流：达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮。
超时和重试机制：一旦用户请求超过某个时间的得不到响应，就抛出异常。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求（雪崩）。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力。                          
熔断：当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。Netflix 的 Hystrix 和 alibaba 的 Sentinel。
异步调用：不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做。使用异步之后我们可能需要适当修改业务流程进行配合。秒杀场景用得比较多。
缓存：避免大量请求直接落到数据库，将数据库击垮。并且储存在内存中，速度相当地快。
回滚机制：快速修复错误版本。

其他：更好的硬件，监控系统资源使用情况增加报警设置，备份并在必要时回滚，灰度发布，定期检查和更换硬件，性能测试。

现代互联网应用系统通常具有的特点
高并发，大流量。
高可用：系统 7×24 小时不间断服务。
海量数据：需要存储、管理海量数据，需要使用大量服务器。
用户分布广泛，网络情况复杂：许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。
安全环境恶劣：由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会被黑客攻击。
需求快速变更，发布频繁：和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率是极高的；
渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来。

单台服务器无法处理越来越多的流量
简单的扩容，增加系统的服务器，提高硬件能力。
水平拆分和垂直拆分数据/应用，来提升系统的伸缩性，进一步扩容提升系统负载能力。
根据现有系统特性，架构层面进行重构甚至是重新设计。
对于系统设计，理想的情况下应支持线性扩容和弹性扩容，即在系统瓶颈时，只需要增加机器就可以解决系统瓶颈，如降低延迟提升吞吐量，从而实现扩容需求。
拆分需要适应自己的业务。

5.代码优化
1.尽量指定类、方法的 final 修饰符
Java 编译器会寻找机会内联所有的 final 方法，内联对于提升 Java 运行效率作用重大。

2.尽量重用对象
特别是 String 对象的使用，出现字符串连接时应该使用 StringBuilder 或 StringBuffer 代替。
由于 Java 虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。

3.尽可能使用局部变量
调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快。其他变量如静态变量、实例变量等，都在堆中创建，速度较慢。
另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。

4.及时关闭流
进行数据库连接、I/O 流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。

5.尽量减少对变量的重复计算
int length = list.size();
for (int i = 0; i < length; i++)  
这种方式要好

6.尽量采用懒加载的策略，即在需要的时候才创建
7.慎用异常
异常对性能不利。抛出异常首先要创建一个新的对象，Throwable 接口的构造函数调用名为 fillInStackTrace() 的本地同步方法，fillInStackTrace() 方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。
异常只能用于错误处理，不应该用来控制程序流程。

8.不要在循环中使用 try...catch...
应该把其放在最外层。

9.如果能估计到待添加的内容长度，为底层以数组方式实现的集合或工具类指定初始长度
数组扩容需要新建数组，复制原数组，删除原数组。
比如 ArrayList、StringBuilder、StringBuffer、HashMap、HashSet 等等，扩容方法是当前容量的 2 倍，指定初始长度避免扩容时浪费空间，提升效率。
初始大小建议设置为 2 的 N 次幂。

10.当复制大量数据时，使用 System.arraycopy() 命令
11.乘法和除法使用移位操作
用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的。

12.循环内不要不断创建对象引用
这种做法会导致内存中有很多份对象引用存在。
应该在循环外创建对象引用，内存中只有一份对象引用，每次在循环内 new 的时候，对象引用指向不同的变量罢了，但是内存中只有一份，这样就大大节省了内存空间。

13.基于效率和类型检查的考虑，应该尽可能使用 Array，无法确定数组大小时才使用 ArrayList
14.尽量使用 HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用 Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销
15.不要将数组声明为public static final
数组的内容还是可以随意改变的，将数组声明为 public 更是一个安全漏洞，这意味着这个数组可以被外部类所改变。

16.尽量在合适的场合使用单例
使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率。
单例主要适用于以下三个方面：
控制资源的使用，通过线程同步来控制资源的并发访问。
控制实例的产生，以达到节约资源的目的。
控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。

17.尽量避免随意使用静态变量
当某个对象被定义为 static 的变量所引用，那么 GC 通常是不会回收这个对象所占有的堆内存的。
如果类不被卸载，那么引用指向的对象会常驻内存，直到程序终止。

18.及时清除不再需要的会话
为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间。
当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据最近最频繁使用 MRU 算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。

19.实现 RandomAccess 接口的集合比如 ArrayList，应当使用最普通的 for 循环而不是 foreach 循环来遍历
20.使用同步代码块替代同步方法
除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。

21.将常量声明为 static final，并以大写命名
这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。

22.不要创建一些不使用的对象，不要导入一些不使用的类
23.程序运行过程中避免使用反射
不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是 Method 的 invoke 方法。
如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。

24.使用数据库连接池和线程池
这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。

25.使用带缓冲的输入输出流进行 I/O 操作
可以极大地提升 I/O 效率。

26.顺序插入和随机访问用 ArrayList，其他用 LinkedList
27.不要让 public 方法中有太多的形参
太多的形参，和面向对象的编程思想并不契合。
参数太多势必导致方法调用的出错概率增加。

28.字符串变量和字符串常量 equals 的时候将字符串常量写在前面
可以避免空指针异常。

29.if 语句中 变量放在 == 之前
30.不要对数组使用 toString() 方法
31.不要对超出范围的基本数据类型做向下强制转型
32.公用的集合类中不使用的数据一定要及时 remove 掉
如果一个集合类是公用的，那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。
如果公用集合里面的某些数据不使用而不去 remove 掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。

33.把一个基本数据类型转为字符串，toString() 是最快的方式、String.valueOf() 次之、数据 + "" 最慢
34.使用最有效率的方式 Iterator 去遍历 Map
35.对资源的 close() 建议分开操作
两个资源需要两个 try...catch...，避免资源泄露。
