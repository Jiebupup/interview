stack:Stack<Integer> stack = new Stack<Integer>();
isEmpty() push() pop() peek() 

queue:Queue<Integer> q=new LinkedList<>();
isEmpty() size() offer() poll() add() remove()

PriorityQueue<Integer> pq=new PriorityQueue<>();
isEmpty() size() offer() poll() add() remove() peek()

String：length() 长度，charAt() 字符，concat() 拼接，substring(begin,end) 子串（左闭右开），compareTo() 比较，equals() 相等，indexOf() 索引（首次出现），split() 分割（regex 注意 . 和 \\.），trim() 删除头尾空白符。
Collections：clear() 清空，contains() 包含，toArray() 转换为数组，reverse() 反转，addAll() 添加，shuffle() 随机排序，sort() 排序，swap() 交换，rotate() 旋转，binarySearch() 二分查找，max() 最大，fill() 填充，frequency() 统计次数，indexOfSubList() 子集合出现的位置，replaceAll() 用新元素代替旧元素。                    
Arrays：sort() 排序（默认升序），binarySearch() 二分查找，equals() 相等，fill() 填充，asList() 转成列表，toString() 转成字符串，copyOf() 复制数组。
TreeSet：floor(val) 返回小于 val 的值，ceiling() 大于。
ArrayList：get() 获取元素，clear() 清空，stream().mapToInt(Integer::intValue).toArray() 转化为 int[]。
LinkedList：add()/push() 等效于 addFirst，remove()/pop() 等效于 removeFirst()。

sequence 不需要连续

快排稳定版：创建一个数组存储要交换的数据，记录位置信息。
堆排序：Java 的 PriorityQueue 默认小根堆，复杂度 CNlogN（堆排序会有很多无用的比较，C 会比较大）。

1.二分查找
public int binarySearch1(int[] a, int n) {
    int i=0,j=a.length-1;
    while(i<=j){
        int mid=i+(j-i)>>1;
        if(a[mid]<n) i=mid+1;
        else if(a[mid]>n)j=mid-1;
        else return mid;
    }
    return -1;
}

public int binarySearch2(int[] a, int n) {
    int i=0,j=a.length-1;
    while(i<j){
        int mid=i+(j-i)>>1;
        if(a[mid]<n) i=mid+1;
        else j=mid;
    }
    return i;
}

2.单例模式
双检锁
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}

静态内部类
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}

枚举
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}

3.四则运算计算器
public int calculate(String s){
    if(s==null||s.length()<1) return 0;
    int num=0,res=0;
    char op='+';    
    Stack<Integer> stack=new Stack<>();
    for(int i=0;i<s.length();i++){
        if(Character.isDigit(s.charAt(i))) num=num*10+s.charAt(i)-'0';
        else if(s[i]=='('){
            int cnt=0;
            int j=i;
            for(;i<s.length();i++){
                if(s[i]=='(') cnt++;
                if(s[i]==')') cnt--;
                if(cnt==0) break;
            }
            num=calculate(s.substring(j+1,i-j-1));
        }
        if(!Character.isDigit(s.charAt(i))&&s.charAt(i)!=' '||i==s.length()-1){
            if(op=='+') stack.push(num);
            if(op=='-') stack.push(-num);
            if(op=='*') stack.push(stack.pop()*num);
            if(op=='/') stack.push(stack.pop()/num);
            op=s.charAt(i);
            num=0;
        }
    }
    for(int i:stack){
        res+=i;
    }
    return res;
}

4.代理模式
静态代理： 
public interface Subject {  //接口
    void request();
}

public class RealSubject implements Subject {  //实体
    @Override
    public void request() {
        System.out.println("real subject execute request");
    }
}

public class Proxy implements Subject {  //代理，实体和代理实现同一接口

    private RealSubject realSubject;

    public Proxy(RealSubject realSubject) {  
        this.realSubject = realSubject;
    }

    @Override
    public void request() {
        System.out.println("before");
        try {
            realSubject.request();
        } catch (Exception e) {
            System.out.println("ex:" + e.getMessage());
            throw e;
        } finally {
            System.out.println("after");
        }
    }
}

public class Client {

    public static void main(String[] args) {
        Subject subject = new Proxy(new RealSubject());
        subject.request();
    }
}

JDK 动态代理：
public interface Subject {  //接口
    void request();
}

public class RealSubject implements Subject {  //实体
    @Override
    public void request() {
        System.out.println("real subject execute request");
    }
}

//import java.lang.reflect.InvocationHandler;
//import java.lang.reflect.Method;

public class JDKProxySubject implements InvocationHandler {

    private RealSubject realSubject;

    public JDKProxySubject(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("before");
        Object result = null;
        try {
            result = method.invoke(realSubject, args);
        } catch (Exception e) {
            System.out.println("ex:" + e.getMessage());
            throw e;
        } finally {
            System.out.println("after");
        }
        return result;
    }
}

//import java.lang.reflect.Proxy;

public class Client {

    public static void main(String[] args){
        Subject subject = (Subject) Proxy.newProxyInstance(Client.class.getClassLoader(),new Class[]{Subject.class},new JDKProxySubject(new RealSubject()));
        subject.request();
    }
}

CGLIB 动态代理：
public interface Subject {  //接口
    void request();
}

public class RealSubject implements Subject {  //实体
    @Override
    public void request() {
        System.out.println("real subject execute request");
    }
}

//import net.sf.cglib.proxy.MethodInterceptor;
//import net.sf.cglib.proxy.MethodProxy;
//import java.lang.reflect.Method;

public class DemoMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("before");
        Object result = null;
        try {
            result = methodProxy.invokeSuper(o, objects);
        } catch (Exception e) {
            System.out.println("ex:" + e.getMessage());
            throw e;
        } finally {
            System.out.println("after");
        }
        return result;
    }
}

//import net.sf.cglib.proxy.Enhancer;

public class Client {

    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(RealSubject.class);
        enhancer.setCallback(new DemoMethodInterceptor());
        Subject subject = (Subject) enhancer.create();
        subject.request();
    }
}

结果：
before
real subject execute request
after

5工厂模式
简单工厂：
public interface Shape {
    void draw();
}

public class Circle implements Shape {
    public Circle() {
        System.out.println("Circle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Circle");
    }
}

public class ShapeFactory {
    // 使用 getShape 方法获取形状类型的对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        }
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        // 获取 Circle 的对象，并调用它的 draw 方法
        Shape circle = ShapeFactory.getShape("CIRCLE");
        circle.draw();
    }
}
结果：
Circle
Draw Circle

反射改善满足开放-封闭原则：
public class ShapeFactory2 {
    public static Object getClass(Class<? extends Shape> clazz) {
        Object obj = null;
        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return obj;
    }
}

public class Test2 {
    public static void main(String[] args) {
        Circle circle = (Circle) ShapeFactory2.getClass(factory_pattern.Circle.class);
        circle.draw();
    }
}

工厂方法：
public abstract class Factory {
    abstract public Product createProduct();
    public void doSomething() {
        Product product = createProduct();
        // do something with the product
    }
}

public class FactoryMethod extends Factory {
    public Product createProduct() {
        return new factoryMethodProduct();
    }
}

public class Client {
    public static void main(String[] args) {
        FactoryMethod factoryMethod = new FactoryMethod();
        Product product = factoryMethod.createProduct();
        // do something with the product
    }
}

抽象工厂：

6.生产者消费者问题

7.泛型实现最小值函数
方法只能接受 Number 的子类并且实现了 Comparable 接口。
private static <T extends Number & Comparable<? super T>> T min(T[] values) {
    if (values == null || values.length == 0) return null;
    T min = values[0];
    for (int i = 1; i < values.length; i++) {
        if (min.compareTo(values[i]) > 0) min = values[i];
    }
    return min;
}

int minInteger = min(new Integer[]{1, 2, 3});  //result:1
double minDouble = min(new Double[]{1.2, 2.2, -1d});  //result:-1d
String typeError = min(new String[]{"1", "3"});  //报错
