1.简介
HTTP超文本传输协议，是一个客户端和服务端之间请求和应答的标准，通常使用TCP协议，服务器上默认端口为80。
HTTPS通过计算机网络进行安全通信的传输协议。

2.HTTP方法
GET：获取资源
POST：传输数据
PUT：上传文件。不带验证机制，任何人都可以上传文件，因此存在安全性问题。
PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源。
DELETE：与PUT对应
OPTIONS：查询指定的 URL 能够支持的方法。
CONNECT：使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
TRACE：追踪路径，服务器会将通信路径返回给客户端。
HEAD：获取报文首部，主要用于确认 URL 的有效性以及资源更新的日期时间等。

两者区别：
GET请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&连接。URL的编码格式采用的是ASCII编码，即所有的非ASCII字符都要编码之后再传输。POST请求会把请求的数据放置在HTTP请求包的包体requrest body中。因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。
GET传输数据会受到URL长度的限制。POST理论上是不会受限制的
GET 方法是安全的，而 POST 却不是。安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。安全的方法GET、HEAD、OPTIONS。不安全的方法POST、PUT、DELETE。
GET 是幂等的，连续调用多次，客户端接收到的结果都是一样的。POST 不是，如果调用多次，就会增加多行记录。幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。幂等方法不应该具有副作用
GET 可缓存，POST 在多数情况下不可缓存。
在使用 XMLHttpRequest（为客户端提供了在客户端和服务器之间传输数据的功能） 的 GET 方法时浏览器将会把 Header 和 Data 一起发送。 而POST 方法，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐。
POST的安全性要比GET的安全性高。
GET在浏览器回退时是无害的，POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET只接受ASCII字符的参数的数据类型，而POST没有限制。
GET效率比POST高。
  
3.HTTP状态码
1XX：Informational（信息性状态码），接收的请求正在处理。
100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

2XX：Success（成功状态码），请求正常处理完毕。
200 OK
204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

3XX：Redirection（重定向状态码），需要进行附加操作以完成请求。
301 Moved Permanently ：永久性重定向
302 Found ：临时性重定向
303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
（虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。）
304 Not Modified ：不满足请求报文首部包含的一些条件。
307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

4XX：Client Error（客户端错误状态码），服务器无法处理请求。
400 Bad Request ：请求报文中存在语法错误。
401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
403 Forbidden ：请求被拒绝。
404 Not Found

5XX，Server Error（服务器错误状态码），服务器处理请求出错。
500 Internal Server Error ：服务器正在执行请求时发生错误。
503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

4.应用
短连接与长连接：
长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。
从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；
在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。

流水线：是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

Cookie
HTTP 协议是无状态的（协议对于事务处理没有记忆能力），主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。
Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，会带来额外的性能开销。Cookie 曾一度用于客户端数据的存储，但渐渐被淘汰，新的浏览器 API 已经允许开发者直接将数据存储到本地。
用途：会话状态管理，个性化设置，浏览器行为跟踪。
分类：
会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

Session 将用户信息存储在服务器端，存储在服务器端的信息更加安全。
Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。
通过 Session ID 来传递，并存放到浏览器的 Cookie 中。

浏览器禁用 Cookie：使用URL重写和隐藏表单域解决
此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术（把session id直接附加在URL路径的后面），将 Session ID 作为 URL 的参数进行传递。服务器能够解析重写后的URL获取Session ID。

Cookie 与 Session比较：
Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

缓存

代理：代理服务器接受客户端的请求，并且转发给其它服务器。
使用代理的主要目的：缓存、负载均衡、网络访问控制、访问日志记录
代理服务器分为正向代理和反向代理两种：用户察觉得到正向代理的存在；而反向代理一般位于内部网络中，用户察觉不到。

5.HTTPS
HTTP 有以下安全性问题：
使用明文进行通信，内容可能会被窃听；
不验证通信方的身份，通信方的身份有可能遭遇伪装；
无法证明报文的完整性，报文有可能遭篡改。

HTTPS让HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。
通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。
加密
对称密钥加密：加密和解密使用同一密钥。
优点：运算速度快；
缺点：无法安全地将密钥传输给通信方。

非对称（公开）密钥加密：加密和解密使用不同的密钥。
公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。
非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。
优点：可以更安全地将公开密钥传输给通信发送方；
缺点：运算速度慢。

HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。

认证
通过使用 证书 来对通信方进行认证。数字证书认证机构CA是客户端与服务器双方都可信赖的第三方机构。
服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

完整性保护
SSL 提供报文摘要功能来进行完整性保护。
HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。
HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

SSL/TLS：安全协议，确保互联网连接安全。TLS（Transport Layer Security）是更为安全的升级版 SSL。SSL/TLS是有状态的。

HTTPS 的缺点：
因为需要进行加密解密等过程，因此速度会更慢；
需要支付证书授权的高额费用。

6.HTTP/2.0
HTTP/1.x 缺陷：实现简单是以牺牲性能为代价的：
客户端需要使用多个连接才能实现并发和缩短延迟；Multiplexing多路传输，一个TCP连接中可以完成多个HTTP请求（并行）。
不会压缩请求和响应首部，从而导致不必要的网络流量；
不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

HTTP/2.0采用的技术：
二进制分帧层，服务端推送，首部压缩。
HTTP/2在其标准中定义了有状态组件。

HTTP/1.1 新特性：
默认是长连接，TCP连接不会在一个HTTP请求完成之后断开，SSL也可以使用之前的（刷新页面）。HTTP/1.0是短连接。
支持流水线，多个请求可以同时发送，Pipelining浏览器默认不开启。
支持同时打开多个 TCP 连接，Chrome最多允许一个host建立六个TCP连接。
支持虚拟主机
新增状态码 100
支持分块传输编码
新增缓存处理指令 max-age

首先考虑HTTP2使用Multiplexing多路传输，不行则在一个HOST上建立多个TCP连接。
