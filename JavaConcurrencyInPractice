1.线程安全性
当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

无状态对象一定是线程安全的：既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。

竞态条件：由于不恰当的执行时序而出现不正确的结果。
某个计算的正确性取决于多个线程的交替执行时序，就会发生竞态条件。
最常见的竞态条件：先检查后执行，即通过一个可能失效的观测结果来决定下一步的动作。常见的先检查后执行：延迟初始化。

内置锁（或称监视锁）支持原子性：同步代码块。
内置锁是可重入的。
可以用锁来保护共享或可变状态变量。
通过同步来避免多个线程在同一时刻访问相同的数据。

2.对象的共享
重排序：

对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位操作。为了安全性，需要用volatile关键字声明或用锁保护起来。

volatile声明变量后，编译和运行时注意到是共享的，不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此读取volatile变量时总会返回最新写入的值。
不会使线程阻塞。
加锁机制既可以保证可见性又可以保证原子性，volatile变量只能确保可见性。
使用volatile变量的条件：
1.对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
2.该变量不会与其他状态变量一起纳入不变性条件中。
3.在访问变量时不需要加锁。

发布：使对象能够在当前作用域之外的代码中使用。
逸出：不应该发布的对象被发布。

线程封闭：仅在单线程内访问数据。

不可变对象一定是线程安全的。
不变性条件：
1.对象创建以后其状态就不能修改。
2.对象的所有域都是final类型。
3.对象是正确创建的（对象在创建期间，this引用没有逸出）。

3.对象的组合
委托是创建线程安全类的一个最有效的策略：将线程安全性委托给现有的线程安全类，只需让现有的线程安全类管理所有的状态即可。

4.基础构建模块
同步容器类：Vector和Hashtable
实现线程安全的方式：将他们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

迭代器

并发容器：
ConcurrentHashmap:分段锁，不需要再迭代过程中对容器加锁，不能被加锁来执行独占访问。

CopyOnWriteArrayList:迭代期间不需要对容器进行加锁或复制。
“写入时复制”：每次修改时会创建并重新发布一个新的容器副本，迭代器保留指向底层基础数组的引用。
仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

阻塞队列BlockingQueue：可阻塞的put和take方法，定时的offer和poll方法。
LinkedBlockingQueue和ArrayBlockingQueue：FIFO队列。
PriorityBlockingQueue:按优先级排序。
SynchronousQueue

消费者-生产者模式：最常见的是线程池和工作队列的组合。Executor任务执行框架。

同步工具类：
阻塞队列
闭锁：确保某些活动直到其他活动都完成后才继续执行。
FutureTask
信号量
栅栏：CyclicBarrier和Exchanger。

5.任务执行









