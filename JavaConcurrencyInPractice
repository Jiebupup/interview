1.线程安全性
当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

无状态对象一定是线程安全的：既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。

竞态条件：由于不恰当的执行时序而出现不正确的结果。
某个计算的正确性取决于多个线程的交替执行时序，就会发生竞态条件。
最常见的竞态条件：先检查后执行，即通过一个可能失效的观测结果来决定下一步的动作。常见的先检查后执行：延迟初始化。

内置锁（或称监视锁）支持原子性：同步代码块。
内置锁是可重入的。
可以用锁来保护共享或可变状态变量。
通过同步来避免多个线程在同一时刻访问相同的数据。

2.对象的共享
重排序：

对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位操作。为了安全性，需要用volatile关键字声明或用锁保护起来。

volatile声明变量后，编译和运行时注意到是共享的，不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此读取volatile变量时总会返回最新写入的值。
不会使线程阻塞。
加锁机制既可以保证可见性又可以保证原子性，volatile变量只能确保可见性。
使用volatile变量的条件：
1.对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
2.该变量不会与其他状态变量一起纳入不变性条件中。
3.在访问变量时不需要加锁。

发布：使对象能够在当前作用域之外的代码中使用。
逸出：不应该发布的对象被发布。

线程封闭：仅在单线程内访问数据。

不可变对象一定是线程安全的。
不变性条件：
1.对象创建以后其状态就不能修改。
2.对象的所有域都是final类型。
3.对象是正确创建的（对象在创建期间，this引用没有逸出）。

3.对象的组合
委托是创建线程安全类的一个最有效的策略：将线程安全性委托给现有的线程安全类，只需让现有的线程安全类管理所有的状态即可。

4.基础构建模块
同步容器类：Vector和Hashtable
实现线程安全的方式：将他们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

迭代器

并发容器：
ConcurrentHashmap:分段锁，不需要再迭代过程中对容器加锁，不能被加锁来执行独占访问。

CopyOnWriteArrayList:迭代期间不需要对容器进行加锁或复制。
“写入时复制”：每次修改时会创建并重新发布一个新的容器副本，迭代器保留指向底层基础数组的引用。
仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

阻塞队列BlockingQueue：可阻塞的put和take方法，定时的offer和poll方法。
LinkedBlockingQueue和ArrayBlockingQueue：FIFO队列。
PriorityBlockingQueue:按优先级排序。
SynchronousQueue

消费者-生产者模式：最常见的是线程池和工作队列的组合。Executor任务执行框架。

同步工具类：
阻塞队列
闭锁：确保某些活动直到其他活动都完成后才继续执行。
FutureTask
信号量
栅栏：CyclicBarrier和Exchanger。

5.任务执行
第一步是要找出任务边界：自然的任务边界选择方式：以独立的客户请求为边界

串行执行的问题：糟糕的响应性和吞吐量
为每个任务分配一个线程的问题：资源管理的复杂性

任务执行的主要抽象：Executor
该框架支持多种不同类型的任务执行策略，将任务提交和执行解耦开来，并用Runnable来表示任务。提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。
Executor基于生产者-消费者模式，提交任务操作相当于生产者（生产待完成的工作单元），执行任务线程相当于消费者。

各种执行策略都是一种资源管理工具

线程池：管理一组同构工作线程的资源池。线程池与工作队列密切相关，在工作队列中保存了所有等待执行的任务。
优点：
1.通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。
2.当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，提高相应性。
3.通过适当调解线程池的大小，可以创建足够多的线程以使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。

newFixedThreadPool和newCachedThreadPool工厂方法返回通用的ThreadPoolExecutor实例，可以用来构造专门的executor。
newSingleThreadExecutor和newScheduledThreadPool

Executor生命周期：创建、提交、开始和完成。

Callable：携带结果的任务，并可能抛异常
Future：表示一个任务的生命周期，提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务。

6.取消与关闭
中断：一种协作机制，能够使一个线程终止另一个线程的当前工作。
通常，中断是实现取消的最合理的方式。

通过Future来实现取消

关闭：shutdown正常关闭和shutdownNow强行关闭
shutdownNow：首先关闭当前正在执行的任务，然后返回所有已提交尚未启动的任务清单，从而将这些任务写入日志或者保存起来以便之后进行处理。

毒丸对象：放置在队列中，当得到这个对象时，立即停止。

非正常的线程终止：RuntimeException

JVM关闭：关闭钩子，守护线程，终结器

7.线程池的使用
不仅能简化任务与线程的生命周期管理，而且还能提供一种简单灵活的方式将任务的提交与任务的执行策略解耦开来。

线程饥饿死锁：线程池中任务依赖于其他任务。

线程池大小
线程池过大：大量的线程将在相对很小的CPU和内存资源上发生竞争，不仅会导致更高的内存使用量，而且还可能会耗尽资源。
线程池过小：许多空闲的处理器无法执行工作，从而降低吞吐率。

ThreadPoolExecutor

8.避免活跃性危险
死锁
最常见的活跃性故障是锁顺序死锁。
避免产生锁顺序死锁：确保线程在获取多个锁时采用一致的顺序。
最好的解决方法是在程序中始终使用开放调用。

在持有锁时调用某个外部方法，将出现活跃性问题：可能会获取其他锁而产生死锁；或阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。

死锁的避免与诊断

其他活跃性问题：
饥饿：线程由于无法访问它所需要的资源而不能继续执行。
丢失信号
活锁：不会阻塞线程，也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。

9.性能和可伸缩性
Amdahl定律：在增加计算机资源的情况下，程序理论上能够实现最高加速比取决于程序中可并行组件与串行组件的比重。串行越小越好。

线程引入的开销：上下文切换，内存同步，阻塞。

通过减少锁的竞争优化性能：锁竞争会有串行操作降低可伸缩性，有上下文切换降低性能。

缩小锁的范围：将与锁无关的代码移除同步代码块。
减小锁的粒度：锁分解和锁分段
都是减小锁的持有时间
避免热点域
采用非独占的锁或非阻塞的锁来代替独占锁。

在并发程序中，对可伸缩性的最主要威胁和串行操作的主要来源是独占方式的资源锁。

10.显示锁







