1.简介
Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。
Spring Cloud 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。
阿里开源的 Spring Cloud Alibaba 是 Spring Cloud 规范的实现。Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。

2.微服务架构
描述了将软件应用程序设计为若干个可独立部署的服务套件的特定方法。
微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的进程中运行，并以轻量级机制（通常是 HTTP 资源 API）进行通信。
这些服务围绕业务功能构建，可通过全自动部署机制来独立部署。
这些服务共用一个最小型的集中式管理，它们可以使用不同的编程语言编写，并使用不同的数据存储技术。

单体风格：单体应用程序被构建为单一单元。
企业应用程序通常由三个部分构成：客户端用户界面、数据库和服务器端应用程序。
服务器端应用程序处理 HTTP 请求，执行一些逻辑处理，从数据库检索和更新数据，选择数据并填充到要发送到浏览器的 HTML 视图中。
这个服务器端应用程序是一个整体，是一个逻辑可执行文件。
对系统的任何更改都涉及构建和部署新版本的服务器端应用程序。

微服务架构风格：将应用程序构建为服务套件。除了服务可独立部署、独立扩展的事实之外，每个服务还提供了一个牢固的模块边界，甚至允许以不同的编程语言编写不同的服务。他们也可以由不同的团队管理。
微服务架构是一个分布式系统，按照业务进行划分成为不同的服务单元，解决单体系统性能等不足。
微服务是一种架构风格，一个大型软件应用由多个服务单元组成。系统中的服务单元可以单独部署，各个服务单元之间是松耦合的。

单体式迁移到微服务：不要大规模重写代码，相反应该采取逐步迁移单体式应用的策略，通过逐步生成微服务新应用，与旧的单体式应用集成，随着时间推移，单体式应用在整个架构中比例逐渐下降直到消失或者成为微服务架构一部分。
停止挖掘，将前端和后端分离，抽出服务。

微服务的好处：
模块化，降低耦合。屏蔽与自身业务无关技术细节。数据隔离，避免不同业务模块间的数据耦合。业务边界清晰，代码边界清晰。显著减少代码冲突。可复用。

微服务的问题：
微服务系统稳定性问题：微服务化后服务数量大幅增加，当一个服务故障后，依赖他的服务受到牵连也发生故障。  
服务调用关系错综复杂，链路过长，问题难定位。
跨服务的数据一致性问题。
数据拆分、迁移问题。

3.如何保障微服务系统稳定性
雪崩效应：微服务化后，服务变多，调用链路变长，如果一个调用链上某个服务节点出问题，很可能引发整个调用链路崩溃，也就是所谓的雪崩效应。
解决方案：使用 Hystrix，在服务间加熔断，或者在服务内（JVM 内）线程隔离。

如何应对突发流量对服务的巨大压力？
在网关层（Zuul，Gateway，Nginx 等）做限流，就按照一定策略抛弃超出阈值的访问请求。
全局限流和 IP 限流：应对突发流量，避免系统被压垮。
userID 限流和 IP 限流：防刷，防止机器人脚本等频繁调用服务。

数据冗余：可以结合熔断一起使用，作为熔断的后备方案。
部署隔离、数据隔离和业务隔离。

4.微服务的事件驱动数据管理
微服务和分布式数据管理问题：
单体式应用一般都会有一个关系型数据库，由此带来的好处是应用可以使用事务 ACID。
使用关系型数据库带来另外一个优势在于提供 SQL（功能强大，可声明的，表转化的查询语言）支持。用户可以非常容易通过查询将多个表的数据组合起来，RDBMS 查询调度器决定最佳实现方式，用户不需要担心例如如何访问数据库等底层问题。另外，因为所有应用的数据都在一个数据库中，很容易去查询。
对于微服务架构来说，数据访问变得非常复杂，这是因为数据都是微服务私有的，唯一可访问的方式就是通过 API。这种打包数据访问方式使得微服务之间松耦合，并且彼此之间独立。如果多个服务访问同一个数据，schema 会更新访问时间，并在所有服务之间进行协调。
不同的微服务经常使用不同的数据库。应用会产生各种不同数据，关系型数据库并不一定是最佳选择。某些场景，某个 NoSQL 数据库可能提供更方便的数据模型，提供更加的性能和可扩展性。
基于微服务的应用一般都使用 SQL 和 NoSQL 结合的数据库，也就是被称为 polyglot persistence 的方法。
polyglot persistent 架构用于存储数据有许多优势，包括松耦合服务和更佳性能和可扩展性。然而，随之而来的则是分布式数据管理带来的挑战：同时保持多个服务之间数据一致性，从多个服务中搜索数据。

事件驱动架构：
解决办法是采用事件驱动架构。在这种架构中，当某件重要事情发生时，微服务会发布一个事件。
事件驱动架构也是既有优点也有缺点，此架构可以使得交易跨多个服务且提供最终一致性，并且可以使应用维护最终视图。
而缺点在于编程模式比 ACID 交易模式更加复杂：为了从应用层级失效中恢复，还需要完成补偿性交易。另外，应用必须应对不一致的数据，这是因为临时交易造成的改变是可见的，另外当应用读取未更新的最终视图时也会遇见数据不一致问题。另外一个缺点在于订阅者必须检测和忽略冗余事件。

原子操作 Achieving Atomicity：
事件驱动架构还会碰到数据库更新和发布事件原子性问题。
使用本地交易发布事件，挖掘数据库交易日志，使用事件源。

总结：
在微服务架构中，每个微服务都有自己私有的数据集。不同微服务可能使用不同的 SQL 或者 NoSQL 数据库。尽管数据库架构有很强的优势，但是也面对数据分布式管理的挑战。第一个挑战就是如何在多服务之间维护业务交易一致性；第二个挑战是如何从多服务环境中获取一致性数据。
最佳解决办法是采用事件驱动架构。其中碰到的一个挑战是如何原子性的更新状态和发布事件。有几种方法可以解决此问题，包括将数据库视为消息队列、交易日志挖掘和事件源。

5.选择微服务部署策略
一个微服务应用由上百个服务构成，服务可以采用不同语言和框架分别写就。每个服务都是一个单一应用，可以有自己的部署、资源、扩展和监控需求。
单主机多服务实例模式：
需要提供若干台物理或者虚拟机，每台机器上运行多个服务实例。很多情况下，这是传统的应用部署方法。每个服务实例运行一个或者多个主机的 well-known 端口，主机可以看做宠物。
这种模式有一些参数，一个参数代表每个服务实例由多少进程构成。另外一个参数定义同一进程组内有多少服务实例运行。

单主机多服务实例模式也是优缺点并存：
主要优点在于资源利用有效性。多服务实例共享服务器和操作系统，如果进程组运行多个服务实例效率会更高。另一个优点在于部署服务实例很快。因为没有太多负载，启动服务很快。如果服务是自包含的进程，只需要启动就可以；否则，如果是运行在容器进程组中的某个服务实例，则需要动态部署进容器中，或者重启容器。
主要缺点是服务实例间很少或者没有隔离，除非每个服务实例是独立进程。如果想精确监控每个服务实例资源使用，就不能限制每个实例资源使用。因此有可能造成某个糟糕的服务实例占用了主机的所有内存或者 CPU。同一进程内多服务实例没有隔离。某个糟糕服务实例很容易攻击同一进程中其它服务；更甚至于，有可能无法监控每个服务实例使用的资源情况。另一个严重问题在于运维团队必须知道如何部署的详细步骤。服务可以用不同语言和框架写成，因此开发团队肯定有很多需要跟运维团队沟通事项。其中复杂性增加了部署过程中出错的可能性。

单主机单服务实例模式：
每个主机上服务实例都是各自独立的。有两种不同实现模式：单虚拟机单实例（一般将服务打包成虚拟机映像 image）和单容器单实例（每个服务实例都运行在各自容器中）。

Serverless 部署：
需要将服务打包成 ZIP 文件上载到 AWS Lambda 就可以部署。可以提供元数据，提供处理服务请求函数的名字（一个事件）。AWS Lambda 自动运行处理请求足够多的微服务，然而只根据运行时间和消耗内存量来计费。
Lambda 函数 是无状态服务。一般通过激活 AWS 服务处理请求。
四种方法激活 Lambda 函数。
AWS Lambda 是一种很方便部署微服务的方式。基于请求计费方式意味着用户只需要承担处理自己业务那部分的负载；另外，因为不需要了解基础架构，用户只需要开发自己的应用。
不少限制：不需要用来部署长期服务，请求必须在 300 秒内完成，服务必须是无状态，因为理论上 AWS Lambda 会为每个请求生成一个独立的实例；必须用某种支持的语言完成，服务必须启动很快，否则，会因为超时被停止。

6.微服务之间是如何独立通讯的
同步
REST HTTP 协议
REST 请求在微服务中是最为常用的一种通讯方式, 它依赖于 HTTP/HTTPS 协议。RESTFUL 的特点是：
每一个 URI 代表 1 种资源。
客户端使用 GET、POST、PUT、DELETE 4 个表示操作方式的动词对服务端资源进行操作。
通过操作资源的表现形式来操作资源。
资源的表现形式是 XML 或者 HTML。
客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。

RPC TCP 协议
远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。

异步：消息中间件。

7.Dubbo 和 Spring Cloud 的关系
未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。
在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。我们后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。

Spring Cloud 是一个规范，Spring Cloud Netflix 和 Spring Cloud Alibaba 都是其实现。目前使用 Spring Cloud 的第一选择是 Spring Cloud Netflix。
Spring Cloud Netflix 包括 Ribbon、Feign、Eureka（停止更新）、Hystrix 等。抽象了一套通用的开发模式，目的是让开发者更快更好地开发业务。但是这套开发模式运行时还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。
Spring Cloud Alibaba 包括 Sentinel、Dubbo、Nacos、RocketMQ、Seata 等。
现在开发微服务也可以直接使用 Kubernetes。

8.微服务开发
Spring 目前是 Java web 开发人员必不可少的一个框架，Spring Boot 简化了 Spring 开发的配置目前也是业内主流开发框架。

9.服务注册发现 Eureka
Eureka 是基于表现层状态转换 REST 的服务，主要在 AWS 云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为 Eureka 服务器。Eureka 还带有一个基于 Java 的客户端组件 Eureka Client，它使与服务的交互变得更加容易。
客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。
在 Netflix，更复杂的负载均衡器将 Eureka 包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。

角色：服务提供者 Eureka Client Provider、消费者、中介 Eureka Server（服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者）。
服务提供者
服务注册 Register：当 Eureka Client Provider 向 Eureka Server 注册时（REST 请求），它提供自身的元数据 metaData，比如 IP 地址、端口，运行状况指示符 URL，主页等。
服务续约 Renew：Eureka 客户会每隔 30 秒(默认情况下)发送一次心跳来续约。通过续约来告知 Eureka Server 该 Eureka 客户仍然存在，没有出现问题。正常情况下，如果 Eureka Server 在 90 秒没有收到 Eureka 客户的续约，它会将实例从其注册表中删除（服务剔除 Eviction）。
服务同步：两个服务提供者分别注册到了两个不同的服务注册中心上，信息分别被两个服务注册中心所维护。此时，由于服务注册中心之间因互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取到。

服务消费者
获取注册列表信息 Fetch Registries：
Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。
该注册列表信息定期（每 30 秒钟）更新一次。每次返回注册列表信息可能与 Eureka 客户端的缓存信息不同，Eureka 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka 客户端则会重新获取整个注册表信息。
Eureka 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。
Eureka 客户端和 Eureka 服务器可以使用 JSON/XML 格式进行通讯。在默认的情况下 Eureka 客户端使用压缩 JSON 格式来获取注册列表的信息。
对于访问实例的选择，Eureka 中有 Region 和 Zone 的概念，一个 Region 中可以包含多个 Zone，每个服务客户端需要被注册到一个 Zone 中，所以每个客户端对应一个 Region 和一个 Zone。在进行服务调用的时候，优先访问同处一个一个 Zone 中的服务提供方，若访问不到，就访问其他的 Zone。

服务下线 Cancel：Eureka 客户端在程序关闭时向 Eureka 服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除，并把该下线事件传播出去。该下线请求不会自动完成。

服务注册中心
失效剔除：Eureka Server 在启动的时候会创建一个定时任务，默认每隔一段时间（默认为 60 秒）将当前清单中超时（默认为 90 秒）没有续约的服务剔除出去。
自我保护：
Eureka Server 在运行期间，会统计心跳失败的比例在 15 分钟之内是否低于 85%，如果出现低于的情况，Eureka Server 会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。
但是，在这段保护期间内实例若出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败的情况，所以客户端必须要有容错机制，比如可以使用请求重试、断路器等机制。

可以充当服务发现的组件有很多：Zookeeper，Consul，Eureka 等。

10.负载均衡 Ribbon
Ribbon 是 Netflix 公司的一个开源的负载均衡项目，是一个客户端/进程内负载均衡器，运行在消费者端。
其工作原理就是 Consumer 端获取到了所有的服务列表之后，在其内部使用负载均衡算法，进行对多个系统的调用。
Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡器，需要和 Eureka 配合。

Nginx 和 Ribbon 的对比：
Nignx 和 Ribbon 不同的是，它是一种集中式的负载均衡器。将所有请求都集中起来，然后再进行负载均衡。
Nginx 中请求是先进入负载均衡器，而在 Ribbon 中是先在客户端进行负载均衡才进行请求的。

Ribbon 中有更多的负载均衡调度算法，其默认是使用的 RoundRobinRule 轮询策略。还有 RandomRule 随机策略和 RetryRule 重试策略。
在 Ribbon 中你还可以自定义负载均衡算法，你只需要实现 IRule 接口，然后修改配置文件或者自定义 Java Config 类。

通过 Spring Cloud Ribbon 的封装，我们在微服务架构中使用客户端负载均衡调用只需要如下两步：
服务提供者只需要启动多个服务实例并且注册到一个注册中心或是多个相关联的服务注册中心。
服务消费者直接通过调用被 @LoadBalanced 注解修饰过的 RestTemplate 来实现面向服务的接口调用。

11.Feign
Feign 的关键机制是使用了动态代理。
RestTemplate 是 Spring 提供的一个访问 Http 服务的客户端类，微服务之间的调用是使用的 RestTemplate。Eureka 框架中的注册、续约等，底层都是使用的 RestTemplate。
每次都调用 RestRemplate 的 API 太麻烦，可以将被调用的服务代码映射到消费者端，就是 Open Feign。
Open Feign 也是运行在消费者端的，使用 Ribbon 进行负载均衡，所以 Open Feign 直接内置了 Ribbon。

Feign 是和 Ribbon 以及 Eureka 紧密协作的：
首先 Ribbon 会从 Eureka Client 里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口。
然后 Ribbon 就可以使用默认的 Round Robin 算法，从中选择一台机器。
Feign 就会针对这台机器，构造并发起请求。

12.Zuul
Zuul 是从设备和 web 站点到 Netflix 流应用后端的所有请求的前门。作为边界服务应用，Zuul 是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个亚马逊自动缩放组（亚马逊的一种云计算方式）的能力。
网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行鉴权、限流、 路由、监控等功能。
Zuul中最关键的功能：路由和过滤器。
Zuul 首先需要向 Eureka 进行注册，能拿到所有 Consumer 的信息如元数据(名称，ip，端口)来进行路由映射。对于路由规则的维护，Zuul 默认会将通过以服务名作为 ContextPath 的方式来创建路由映射。
过滤：能实现限流，灰度发布，权限控制等等。对微服务接口的拦截和校验。
Zuul 作为网关肯定也存在单点问题，如果我们要保证 Zuul 的高可用，我们就需要进行 Zuul 的集群配置，这个时候可以借助额外的一些负载均衡器比如 Nginx。

13.配置管理 Config
既能对配置文件统一地进行管理，又能在项目运行时动态修改配置文件。
Spring Cloud Config 为分布式系统中的外部化配置提供服务器和客户端支持。使用 Config服务器，可以在中心位置管理所有环境中应用程序的外部属性。
Spring Cloud Config 就是能将各个应用/系统/模块的配置文件存放到统一的地方然后进行管理(Git 或者 SVN)。
启动的时候才会进行配置文件的加载，那么我们的 Spring Cloud Config 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。
Webhooks，这是 github 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。
使用 Bus 消息总线 + Spring Cloud Config 进行配置的动态刷新。
Spring Cloud Bus：用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。
Spring Cloud Bus 的作用就是管理和广播分布式系统中的消息，也就是消息引擎系统中的广播模式。当然作为消息总线的 Spring Cloud Bus 可以做很多事而不仅仅是客户端的配置刷新功能。
拥有了 Spring Cloud Bus 之后，我们只需要创建一个简单的请求，并且加上 @ResfreshScope 注解就能进行配置的动态修改了。

14.微服务 2.0 技术栈选型
服务框架
Spring Boot/Cloud：RESTful 框架（不是 RPC 框架），序列化协议主要采用基于文本的 JSON，通讯协议一般基于 HTTP。
RESTful 框架天然支持跨语言，任何语言只要有 HTTP 客户端都可以接入调用，但是客户端一般需要自己解析 payload。
目前 Spring 框架也支持 Swagger 契约编程模型，能够基于契约生成各种语言的强类型客户端，极大方便不同语言栈的应用接入，但是因为 RESTful 框架和 Swagger 规范的弱契约特性，生成的各种语言客户端的互操作性还是有不少坑的。

Dubbo：基于 Java 的 RPC 框架，当当 Dubbox 扩展了 Dubbo 支持 RESTful 接口暴露能力。Dubbo 主要面向 Java 技术栈，跨语言支持不足是它的一个弱项，另外因为治理能力太丰富，以至于这个框架比较重，完全用好这个框架的门槛比较高。

运行时支撑服务
服务注册中心：Eureka，客户端配合 Ribbon 可以实现灵活的客户端软负载均衡。
服务网关：Zuul，支持灵活的动态过滤器脚本机制，异步性能不足。
配置中心：Spring Cloud Config

日志监控：ELK
服务容错：Hystrix，Zuul 网关也可以集成 Hystrix 实现网关层集中式限流容错。

后台服务
消息系统：Kafka，RocketMQ，RabbitMQ
数据库访问中间层 proxy 模式：阿里 Cobar 演化出来的社区开源分库分表中间件 MyCAT。

服务安全：OAuth
权限认证：Shiro

服务部署平台
集群资源调度系统：Kubernetes
镜像治理：Docker
